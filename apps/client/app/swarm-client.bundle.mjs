export default "40507\n{\"version\":0,\"id\":\"5dfb79347cb91d524815d7510f2f176093b4e9606b67c49427883d0b67c5224c\",\"main\":\"/backend/swarm-client.mjs\",\"imports\":{},\"resolutions\":{\"/../../node_modules/@hyperswarm/secret-stream/index.js\":{\"#package\":\"/../../node_modules/@hyperswarm/secret-stream/package.json\",\"./lib/bridge\":\"/../../node_modules/@hyperswarm/secret-stream/lib/bridge.js\",\"./lib/handshake\":\"/../../node_modules/@hyperswarm/secret-stream/lib/handshake.js\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"hypercore-crypto\":\"/../../node_modules/hypercore-crypto/index.js\",\"sodium-secretstream\":\"/../../node_modules/sodium-secretstream/index.js\",\"sodium-universal\":\"/../../node_modules/sodium-universal/index.js\",\"streamx\":\"/../../node_modules/streamx/index.js\",\"timeout-refresh\":\"/../../node_modules/timeout-refresh/index.js\",\"unslab\":\"/../../node_modules/unslab/index.js\"},\"/../../node_modules/@hyperswarm/secret-stream/lib/bridge.js\":{\"#package\":\"/../../node_modules/@hyperswarm/secret-stream/package.json\",\"streamx\":\"/../../node_modules/streamx/index.js\"},\"/../../node_modules/@hyperswarm/secret-stream/lib/handshake.js\":{\"#package\":\"/../../node_modules/@hyperswarm/secret-stream/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"noise-curve-ed\":\"/../../node_modules/noise-curve-ed/index.js\",\"noise-handshake\":\"/../../node_modules/noise-handshake/noise.js\",\"sodium-universal\":\"/../../node_modules/sodium-universal/index.js\"},\"/../../node_modules/@hyperswarm/secret-stream/package.json\":{},\"/../../node_modules/adaptive-timeout/index.js\":{\"#package\":\"/../../node_modules/adaptive-timeout/package.json\",\"xache\":\"/../../node_modules/xache/index.js\"},\"/../../node_modules/adaptive-timeout/package.json\":{},\"/../../node_modules/b4a/index.js\":{\"#package\":\"/../../node_modules/b4a/package.json\"},\"/../../node_modules/b4a/package.json\":{},\"/../../node_modules/bare-events/index.js\":{\"#package\":\"/../../node_modules/bare-events/package.json\",\"./lib/errors\":\"/../../node_modules/bare-events/lib/errors.js\"},\"/../../node_modules/bare-events/lib/errors.js\":{\"#package\":\"/../../node_modules/bare-events/package.json\"},\"/../../node_modules/bare-events/package.json\":{},\"/../../node_modules/bits-to-bytes/index.js\":{\"#package\":\"/../../node_modules/bits-to-bytes/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\"},\"/../../node_modules/bits-to-bytes/package.json\":{},\"/../../node_modules/blind-relay/index.js\":{\"#package\":\"/../../node_modules/blind-relay/package.json\",\"./lib/errors\":\"/../../node_modules/blind-relay/lib/errors.js\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"bits-to-bytes\":\"/../../node_modules/bits-to-bytes/index.js\",\"compact-encoding\":\"/../../node_modules/compact-encoding/index.js\",\"compact-encoding-bitfield\":\"/../../node_modules/compact-encoding-bitfield/index.js\",\"events\":\"/../../node_modules/bare-events/index.js\",\"protomux\":\"/../../node_modules/protomux/index.js\",\"sodium-universal\":\"/../../node_modules/sodium-universal/index.js\",\"streamx\":\"/../../node_modules/streamx/index.js\"},\"/../../node_modules/blind-relay/lib/errors.js\":{\"#package\":\"/../../node_modules/blind-relay/package.json\"},\"/../../node_modules/blind-relay/package.json\":{},\"/../../node_modules/bogon/index.js\":{\"#package\":\"/../../node_modules/bogon/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"compact-encoding\":\"/../../node_modules/compact-encoding/index.js\",\"compact-encoding-net\":\"/../../node_modules/compact-encoding-net/index.js\"},\"/../../node_modules/bogon/package.json\":{},\"/../../node_modules/compact-encoding-bitfield/index.js\":{\"#package\":\"/../../node_modules/compact-encoding-bitfield/package.json\",\"compact-encoding\":\"/../../node_modules/compact-encoding/index.js\"},\"/../../node_modules/compact-encoding-bitfield/package.json\":{},\"/../../node_modules/compact-encoding-net/index.js\":{\"#package\":\"/../../node_modules/compact-encoding-net/package.json\",\"compact-encoding\":\"/../../node_modules/compact-encoding/index.js\"},\"/../../node_modules/compact-encoding-net/package.json\":{},\"/../../node_modules/compact-encoding/endian.js\":{\"#package\":\"/../../node_modules/compact-encoding/package.json\"},\"/../../node_modules/compact-encoding/index.js\":{\"#package\":\"/../../node_modules/compact-encoding/package.json\",\"./endian\":\"/../../node_modules/compact-encoding/endian.js\",\"./lexint\":\"/../../node_modules/compact-encoding/lexint.js\",\"./raw\":\"/../../node_modules/compact-encoding/raw.js\",\"b4a\":\"/../../node_modules/b4a/index.js\"},\"/../../node_modules/compact-encoding/lexint.js\":{\"#package\":\"/../../node_modules/compact-encoding/package.json\"},\"/../../node_modules/compact-encoding/package.json\":{},\"/../../node_modules/compact-encoding/raw.js\":{\"#package\":\"/../../node_modules/compact-encoding/package.json\",\"./endian\":\"/../../node_modules/compact-encoding/endian.js\",\"b4a\":\"/../../node_modules/b4a/index.js\"},\"/../../node_modules/dht-rpc/index.js\":{\"#package\":\"/../../node_modules/dht-rpc/package.json\",\"./lib/commands\":\"/../../node_modules/dht-rpc/lib/commands.js\",\"./lib/errors\":\"/../../node_modules/dht-rpc/lib/errors.js\",\"./lib/health\":\"/../../node_modules/dht-rpc/lib/health.js\",\"./lib/io\":\"/../../node_modules/dht-rpc/lib/io.js\",\"./lib/peer\":\"/../../node_modules/dht-rpc/lib/peer.js\",\"./lib/query\":\"/../../node_modules/dht-rpc/lib/query.js\",\"./lib/session\":\"/../../node_modules/dht-rpc/lib/session.js\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"compact-encoding\":\"/../../node_modules/compact-encoding/index.js\",\"events\":\"/../../node_modules/bare-events/index.js\",\"kademlia-routing-table\":\"/../../node_modules/kademlia-routing-table/index.js\",\"nat-sampler\":\"/../../node_modules/nat-sampler/index.js\",\"sodium-universal\":\"/../../node_modules/sodium-universal/index.js\",\"time-ordered-set\":\"/../../node_modules/time-ordered-set/index.js\",\"udx-native\":\"/../../node_modules/udx-native/lib/udx.js\"},\"/../../node_modules/dht-rpc/lib/commands.js\":{\"#package\":\"/../../node_modules/dht-rpc/package.json\"},\"/../../node_modules/dht-rpc/lib/errors.js\":{\"#package\":\"/../../node_modules/dht-rpc/package.json\"},\"/../../node_modules/dht-rpc/lib/health.js\":{\"#package\":\"/../../node_modules/dht-rpc/package.json\"},\"/../../node_modules/dht-rpc/lib/io.js\":{\"#package\":\"/../../node_modules/dht-rpc/package.json\",\"./errors\":\"/../../node_modules/dht-rpc/lib/errors.js\",\"./peer\":\"/../../node_modules/dht-rpc/lib/peer.js\",\"adaptive-timeout\":\"/../../node_modules/adaptive-timeout/index.js\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"compact-encoding\":\"/../../node_modules/compact-encoding/index.js\",\"fast-fifo\":\"/../../node_modules/fast-fifo/index.js\",\"sodium-universal\":\"/../../node_modules/sodium-universal/index.js\"},\"/../../node_modules/dht-rpc/lib/peer.js\":{\"#package\":\"/../../node_modules/dht-rpc/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"compact-encoding\":\"/../../node_modules/compact-encoding/index.js\",\"compact-encoding-net\":\"/../../node_modules/compact-encoding-net/index.js\",\"sodium-universal\":\"/../../node_modules/sodium-universal/index.js\"},\"/../../node_modules/dht-rpc/lib/query.js\":{\"#package\":\"/../../node_modules/dht-rpc/package.json\",\"./commands\":\"/../../node_modules/dht-rpc/lib/commands.js\",\"./peer\":\"/../../node_modules/dht-rpc/lib/peer.js\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"streamx\":\"/../../node_modules/streamx/index.js\"},\"/../../node_modules/dht-rpc/lib/session.js\":{\"#package\":\"/../../node_modules/dht-rpc/package.json\"},\"/../../node_modules/dht-rpc/package.json\":{},\"/../../node_modules/events-universal/bare.js\":{\"#package\":\"/../../node_modules/events-universal/package.json\",\"bare-events\":\"/../../node_modules/bare-events/index.js\"},\"/../../node_modules/events-universal/package.json\":{},\"/../../node_modules/fast-fifo/fixed-size.js\":{\"#package\":\"/../../node_modules/fast-fifo/package.json\"},\"/../../node_modules/fast-fifo/index.js\":{\"#package\":\"/../../node_modules/fast-fifo/package.json\",\"./fixed-size\":\"/../../node_modules/fast-fifo/fixed-size.js\"},\"/../../node_modules/fast-fifo/package.json\":{},\"/../../node_modules/hypercore-crypto/index.js\":{\"#package\":\"/../../node_modules/hypercore-crypto/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"compact-encoding\":\"/../../node_modules/compact-encoding/index.js\",\"sodium-universal\":\"/../../node_modules/sodium-universal/index.js\"},\"/../../node_modules/hypercore-crypto/package.json\":{},\"/../../node_modules/hypercore-id-encoding/index.js\":{\"#package\":\"/../../node_modules/hypercore-id-encoding/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"z32\":\"/../../node_modules/z32/index.js\"},\"/../../node_modules/hypercore-id-encoding/package.json\":{},\"/../../node_modules/hyperdht/index.js\":{\"#package\":\"/../../node_modules/hyperdht/package.json\",\"./lib/connect\":\"/../../node_modules/hyperdht/lib/connect.js\",\"./lib/connection-pool\":\"/../../node_modules/hyperdht/lib/connection-pool.js\",\"./lib/constants\":\"/../../node_modules/hyperdht/lib/constants.js\",\"./lib/crypto\":\"/../../node_modules/hyperdht/lib/crypto.js\",\"./lib/errors\":\"/../../node_modules/hyperdht/lib/errors.js\",\"./lib/messages\":\"/../../node_modules/hyperdht/lib/messages.js\",\"./lib/persistent\":\"/../../node_modules/hyperdht/lib/persistent.js\",\"./lib/raw-stream-set\":\"/../../node_modules/hyperdht/lib/raw-stream-set.js\",\"./lib/router\":\"/../../node_modules/hyperdht/lib/router.js\",\"./lib/server\":\"/../../node_modules/hyperdht/lib/server.js\",\"./lib/socket-pool\":\"/../../node_modules/hyperdht/lib/socket-pool.js\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"compact-encoding\":\"/../../node_modules/compact-encoding/index.js\",\"dht-rpc\":\"/../../node_modules/dht-rpc/index.js\",\"hypercore-id-encoding\":\"/../../node_modules/hypercore-id-encoding/index.js\",\"safety-catch\":\"/../../node_modules/safety-catch/index.js\",\"sodium-universal\":\"/../../node_modules/sodium-universal/index.js\",\"xache\":\"/../../node_modules/xache/index.js\"},\"/../../node_modules/hyperdht/lib/announcer.js\":{\"#package\":\"/../../node_modules/hyperdht/package.json\",\"./constants\":\"/../../node_modules/hyperdht/lib/constants.js\",\"./encode\":\"/../../node_modules/hyperdht/lib/encode.js\",\"./messages\":\"/../../node_modules/hyperdht/lib/messages.js\",\"./persistent\":\"/../../node_modules/hyperdht/lib/persistent.js\",\"./sleeper\":\"/../../node_modules/hyperdht/lib/sleeper.js\",\"compact-encoding\":\"/../../node_modules/compact-encoding/index.js\",\"safety-catch\":\"/../../node_modules/safety-catch/index.js\",\"signal-promise\":\"/../../node_modules/signal-promise/index.js\"},\"/../../node_modules/hyperdht/lib/connect.js\":{\"#package\":\"/../../node_modules/hyperdht/package.json\",\"./constants\":\"/../../node_modules/hyperdht/lib/constants.js\",\"./crypto\":\"/../../node_modules/hyperdht/lib/crypto.js\",\"./errors\":\"/../../node_modules/hyperdht/lib/errors.js\",\"./holepuncher\":\"/../../node_modules/hyperdht/lib/holepuncher.js\",\"./noise-wrap\":\"/../../node_modules/hyperdht/lib/noise-wrap.js\",\"./secure-payload\":\"/../../node_modules/hyperdht/lib/secure-payload.js\",\"./semaphore\":\"/../../node_modules/hyperdht/lib/semaphore.js\",\"./sleeper\":\"/../../node_modules/hyperdht/lib/sleeper.js\",\"@hyperswarm/secret-stream\":\"/../../node_modules/@hyperswarm/secret-stream/index.js\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"blind-relay\":\"/../../node_modules/blind-relay/index.js\",\"bogon\":\"/../../node_modules/bogon/index.js\",\"safety-catch\":\"/../../node_modules/safety-catch/index.js\",\"unslab\":\"/../../node_modules/unslab/index.js\"},\"/../../node_modules/hyperdht/lib/connection-pool.js\":{\"#package\":\"/../../node_modules/hyperdht/package.json\",\"./errors\":\"/../../node_modules/hyperdht/lib/errors.js\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"events\":\"/../../node_modules/bare-events/index.js\"},\"/../../node_modules/hyperdht/lib/constants.js\":{\"#package\":\"/../../node_modules/hyperdht/package.json\",\"hypercore-crypto\":\"/../../node_modules/hypercore-crypto/index.js\"},\"/../../node_modules/hyperdht/lib/crypto.js\":{\"#package\":\"/../../node_modules/hyperdht/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"sodium-universal\":\"/../../node_modules/sodium-universal/index.js\"},\"/../../node_modules/hyperdht/lib/encode.js\":{\"#package\":\"/../../node_modules/hyperdht/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"compact-encoding\":\"/../../node_modules/compact-encoding/index.js\"},\"/../../node_modules/hyperdht/lib/errors.js\":{\"#package\":\"/../../node_modules/hyperdht/package.json\"},\"/../../node_modules/hyperdht/lib/holepuncher.js\":{\"#package\":\"/../../node_modules/hyperdht/package.json\",\"./constants\":\"/../../node_modules/hyperdht/lib/constants.js\",\"./nat\":\"/../../node_modules/hyperdht/lib/nat.js\",\"./sleeper\":\"/../../node_modules/hyperdht/lib/sleeper.js\",\"b4a\":\"/../../node_modules/b4a/index.js\"},\"/../../node_modules/hyperdht/lib/messages.js\":{\"#package\":\"/../../node_modules/hyperdht/package.json\",\"compact-encoding\":\"/../../node_modules/compact-encoding/index.js\",\"compact-encoding-net\":\"/../../node_modules/compact-encoding-net/index.js\"},\"/../../node_modules/hyperdht/lib/nat.js\":{\"#package\":\"/../../node_modules/hyperdht/package.json\",\"../lib/constants\":\"/../../node_modules/hyperdht/lib/constants.js\"},\"/../../node_modules/hyperdht/lib/noise-wrap.js\":{\"#package\":\"/../../node_modules/hyperdht/package.json\",\"./constants\":\"/../../node_modules/hyperdht/lib/constants.js\",\"./errors\":\"/../../node_modules/hyperdht/lib/errors.js\",\"./messages\":\"/../../node_modules/hyperdht/lib/messages.js\",\"@hyperswarm/secret-stream\":\"/../../node_modules/@hyperswarm/secret-stream/index.js\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"compact-encoding\":\"/../../node_modules/compact-encoding/index.js\",\"noise-curve-ed\":\"/../../node_modules/noise-curve-ed/index.js\",\"noise-handshake\":\"/../../node_modules/noise-handshake/noise.js\",\"sodium-universal\":\"/../../node_modules/sodium-universal/index.js\"},\"/../../node_modules/hyperdht/lib/persistent.js\":{\"#package\":\"/../../node_modules/hyperdht/package.json\",\"./constants\":\"/../../node_modules/hyperdht/lib/constants.js\",\"./encode\":\"/../../node_modules/hyperdht/lib/encode.js\",\"./messages\":\"/../../node_modules/hyperdht/lib/messages.js\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"compact-encoding\":\"/../../node_modules/compact-encoding/index.js\",\"record-cache\":\"/../../node_modules/record-cache/index.js\",\"sodium-universal\":\"/../../node_modules/sodium-universal/index.js\",\"unslab\":\"/../../node_modules/unslab/index.js\",\"xache\":\"/../../node_modules/xache/index.js\"},\"/../../node_modules/hyperdht/lib/raw-stream-set.js\":{\"#package\":\"/../../node_modules/hyperdht/package.json\"},\"/../../node_modules/hyperdht/lib/router.js\":{\"#package\":\"/../../node_modules/hyperdht/package.json\",\"./constants\":\"/../../node_modules/hyperdht/lib/constants.js\",\"./errors\":\"/../../node_modules/hyperdht/lib/errors.js\",\"./messages\":\"/../../node_modules/hyperdht/lib/messages.js\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"compact-encoding\":\"/../../node_modules/compact-encoding/index.js\",\"safety-catch\":\"/../../node_modules/safety-catch/index.js\",\"xache\":\"/../../node_modules/xache/index.js\"},\"/../../node_modules/hyperdht/lib/secure-payload.js\":{\"#package\":\"/../../node_modules/hyperdht/package.json\",\"./messages\":\"/../../node_modules/hyperdht/lib/messages.js\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"sodium-universal\":\"/../../node_modules/sodium-universal/index.js\"},\"/../../node_modules/hyperdht/lib/semaphore.js\":{\"#package\":\"/../../node_modules/hyperdht/package.json\"},\"/../../node_modules/hyperdht/lib/server.js\":{\"#package\":\"/../../node_modules/hyperdht/package.json\",\"./announcer\":\"/../../node_modules/hyperdht/lib/announcer.js\",\"./constants\":\"/../../node_modules/hyperdht/lib/constants.js\",\"./crypto\":\"/../../node_modules/hyperdht/lib/crypto.js\",\"./errors\":\"/../../node_modules/hyperdht/lib/errors.js\",\"./holepuncher\":\"/../../node_modules/hyperdht/lib/holepuncher.js\",\"./noise-wrap\":\"/../../node_modules/hyperdht/lib/noise-wrap.js\",\"./secure-payload\":\"/../../node_modules/hyperdht/lib/secure-payload.js\",\"@hyperswarm/secret-stream\":\"/../../node_modules/@hyperswarm/secret-stream/index.js\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"blind-relay\":\"/../../node_modules/blind-relay/index.js\",\"bogon\":\"/../../node_modules/bogon/index.js\",\"events\":\"/../../node_modules/bare-events/index.js\",\"safety-catch\":\"/../../node_modules/safety-catch/index.js\"},\"/../../node_modules/hyperdht/lib/sleeper.js\":{\"#package\":\"/../../node_modules/hyperdht/package.json\"},\"/../../node_modules/hyperdht/lib/socket-pool.js\":{\"#package\":\"/../../node_modules/hyperdht/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\"},\"/../../node_modules/hyperdht/package.json\":{},\"/../../node_modules/hyperswarm/index.js\":{\"#package\":\"/../../node_modules/hyperswarm/package.json\",\"./lib/connection-set\":\"/../../node_modules/hyperswarm/lib/connection-set.js\",\"./lib/peer-discovery\":\"/../../node_modules/hyperswarm/lib/peer-discovery.js\",\"./lib/peer-info\":\"/../../node_modules/hyperswarm/lib/peer-info.js\",\"./lib/retry-timer\":\"/../../node_modules/hyperswarm/lib/retry-timer.js\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"events\":\"/../../node_modules/bare-events/index.js\",\"hyperdht\":\"/../../node_modules/hyperdht/index.js\",\"shuffled-priority-queue\":\"/../../node_modules/shuffled-priority-queue/index.js\",\"streamx\":\"/../../node_modules/streamx/index.js\",\"unslab\":\"/../../node_modules/unslab/index.js\"},\"/../../node_modules/hyperswarm/lib/bulk-timer.js\":{\"#package\":\"/../../node_modules/hyperswarm/package.json\"},\"/../../node_modules/hyperswarm/lib/connection-set.js\":{\"#package\":\"/../../node_modules/hyperswarm/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\"},\"/../../node_modules/hyperswarm/lib/peer-discovery.js\":{\"#package\":\"/../../node_modules/hyperswarm/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"safety-catch\":\"/../../node_modules/safety-catch/index.js\"},\"/../../node_modules/hyperswarm/lib/peer-info.js\":{\"#package\":\"/../../node_modules/hyperswarm/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"events\":\"/../../node_modules/bare-events/index.js\",\"unslab\":\"/../../node_modules/unslab/index.js\"},\"/../../node_modules/hyperswarm/lib/retry-timer.js\":{\"#package\":\"/../../node_modules/hyperswarm/package.json\",\"./bulk-timer\":\"/../../node_modules/hyperswarm/lib/bulk-timer.js\"},\"/../../node_modules/hyperswarm/package.json\":{},\"/../../node_modules/kademlia-routing-table/index.js\":{\"#package\":\"/../../node_modules/kademlia-routing-table/package.json\",\"events\":\"/../../node_modules/bare-events/index.js\"},\"/../../node_modules/kademlia-routing-table/package.json\":{},\"/../../node_modules/nanoassert/index.js\":{\"#package\":\"/../../node_modules/nanoassert/package.json\"},\"/../../node_modules/nanoassert/package.json\":{},\"/../../node_modules/nat-sampler/index.js\":{\"#package\":\"/../../node_modules/nat-sampler/package.json\"},\"/../../node_modules/nat-sampler/package.json\":{},\"/../../node_modules/noise-curve-ed/index.js\":{\"#package\":\"/../../node_modules/noise-curve-ed/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"nanoassert\":\"/../../node_modules/nanoassert/index.js\",\"sodium-universal\":\"/../../node_modules/sodium-universal/index.js\"},\"/../../node_modules/noise-curve-ed/package.json\":{},\"/../../node_modules/noise-handshake/cipher.js\":{\"#package\":\"/../../node_modules/noise-handshake/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"sodium-universal\":\"/../../node_modules/sodium-universal/index.js\"},\"/../../node_modules/noise-handshake/dh.js\":{\"#package\":\"/../../node_modules/noise-handshake/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"nanoassert\":\"/../../node_modules/nanoassert/index.js\",\"sodium-universal\":\"/../../node_modules/sodium-universal/index.js\"},\"/../../node_modules/noise-handshake/hkdf.js\":{\"#package\":\"/../../node_modules/noise-handshake/package.json\",\"./hmac\":\"/../../node_modules/noise-handshake/hmac.js\",\"b4a\":\"/../../node_modules/b4a/index.js\"},\"/../../node_modules/noise-handshake/hmac.js\":{\"#package\":\"/../../node_modules/noise-handshake/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"sodium-universal\":\"/../../node_modules/sodium-universal/index.js\"},\"/../../node_modules/noise-handshake/noise.js\":{\"#package\":\"/../../node_modules/noise-handshake/package.json\",\"./hkdf\":\"/../../node_modules/noise-handshake/hkdf.js\",\"./symmetric-state\":\"/../../node_modules/noise-handshake/symmetric-state.js\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"nanoassert\":\"/../../node_modules/nanoassert/index.js\"},\"/../../node_modules/noise-handshake/package.json\":{},\"/../../node_modules/noise-handshake/symmetric-state.js\":{\"#package\":\"/../../node_modules/noise-handshake/package.json\",\"./cipher\":\"/../../node_modules/noise-handshake/cipher.js\",\"./dh\":\"/../../node_modules/noise-handshake/dh.js\",\"./hkdf\":\"/../../node_modules/noise-handshake/hkdf.js\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"nanoassert\":\"/../../node_modules/nanoassert/index.js\",\"sodium-universal\":\"/../../node_modules/sodium-universal/index.js\"},\"/../../node_modules/protomux/index.js\":{\"#package\":\"/../../node_modules/protomux/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"compact-encoding\":\"/../../node_modules/compact-encoding/index.js\",\"queue-tick\":\"/../../node_modules/queue-tick/process-next-tick.js\",\"safety-catch\":\"/../../node_modules/safety-catch/index.js\",\"unslab\":\"/../../node_modules/unslab/index.js\"},\"/../../node_modules/protomux/package.json\":{},\"/../../node_modules/queue-tick/package.json\":{},\"/../../node_modules/queue-tick/process-next-tick.js\":{\"#package\":\"/../../node_modules/queue-tick/package.json\",\"./queue-microtask\":\"/../../node_modules/queue-tick/queue-microtask.js\"},\"/../../node_modules/queue-tick/queue-microtask.js\":{\"#package\":\"/../../node_modules/queue-tick/package.json\"},\"/../../node_modules/record-cache/index.js\":{\"#package\":\"/../../node_modules/record-cache/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\"},\"/../../node_modules/record-cache/package.json\":{},\"/../../node_modules/require-addon/lib/bare.js\":{\"#package\":\"/../../node_modules/require-addon/package.json\"},\"/../../node_modules/require-addon/package.json\":{},\"/../../node_modules/safety-catch/index.js\":{\"#package\":\"/../../node_modules/safety-catch/package.json\"},\"/../../node_modules/safety-catch/package.json\":{},\"/../../node_modules/shuffled-priority-queue/index.js\":{\"#package\":\"/../../node_modules/shuffled-priority-queue/package.json\",\"unordered-set\":\"/../../node_modules/unordered-set/index.js\"},\"/../../node_modules/shuffled-priority-queue/package.json\":{},\"/../../node_modules/signal-promise/index.js\":{\"#package\":\"/../../node_modules/signal-promise/package.json\"},\"/../../node_modules/signal-promise/package.json\":{},\"/../../node_modules/sodium-native/binding.js\":{\"#package\":\"/../../node_modules/sodium-native/package.json\",\".\":\"linked:sodium-native.5.0.10.framework/sodium-native.5.0.10\",\"require-addon\":\"/../../node_modules/require-addon/lib/bare.js\"},\"/../../node_modules/sodium-native/index.js\":{\"#package\":\"/../../node_modules/sodium-native/package.json\",\"./binding\":\"/../../node_modules/sodium-native/binding.js\",\"which-runtime\":\"/../../node_modules/which-runtime/index.js\"},\"/../../node_modules/sodium-native/package.json\":{},\"/../../node_modules/sodium-secretstream/index.js\":{\"#package\":\"/../../node_modules/sodium-secretstream/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"sodium-universal\":\"/../../node_modules/sodium-universal/index.js\"},\"/../../node_modules/sodium-secretstream/package.json\":{},\"/../../node_modules/sodium-universal/index.js\":{\"#package\":\"/../../node_modules/sodium-universal/package.json\",\"sodium-native\":\"/../../node_modules/sodium-native/index.js\"},\"/../../node_modules/sodium-universal/package.json\":{},\"/../../node_modules/streamx/index.js\":{\"#package\":\"/../../node_modules/streamx/package.json\",\"events-universal\":\"/../../node_modules/events-universal/bare.js\",\"fast-fifo\":\"/../../node_modules/fast-fifo/index.js\",\"text-decoder\":\"/../../node_modules/text-decoder/index.js\"},\"/../../node_modules/streamx/package.json\":{},\"/../../node_modules/text-decoder/index.js\":{\"#package\":\"/../../node_modules/text-decoder/package.json\",\"./lib/pass-through-decoder\":\"/../../node_modules/text-decoder/lib/pass-through-decoder.js\",\"./lib/utf8-decoder\":\"/../../node_modules/text-decoder/lib/utf8-decoder.js\"},\"/../../node_modules/text-decoder/lib/pass-through-decoder.js\":{\"#package\":\"/../../node_modules/text-decoder/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\"},\"/../../node_modules/text-decoder/lib/utf8-decoder.js\":{\"#package\":\"/../../node_modules/text-decoder/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\"},\"/../../node_modules/text-decoder/package.json\":{},\"/../../node_modules/time-ordered-set/index.js\":{\"#package\":\"/../../node_modules/time-ordered-set/package.json\"},\"/../../node_modules/time-ordered-set/package.json\":{},\"/../../node_modules/timeout-refresh/browser.js\":{\"#package\":\"/../../node_modules/timeout-refresh/package.json\"},\"/../../node_modules/timeout-refresh/index.js\":{\"#package\":\"/../../node_modules/timeout-refresh/package.json\",\"./browser\":\"/../../node_modules/timeout-refresh/browser.js\",\"./node\":\"/../../node_modules/timeout-refresh/node.js\"},\"/../../node_modules/timeout-refresh/node.js\":{\"#package\":\"/../../node_modules/timeout-refresh/package.json\"},\"/../../node_modules/timeout-refresh/package.json\":{},\"/../../node_modules/udx-native/binding.js\":{\"#package\":\"/../../node_modules/udx-native/package.json\",\".\":\"linked:udx-native.1.19.2.framework/udx-native.1.19.2\",\"require-addon\":\"/../../node_modules/require-addon/lib/bare.js\"},\"/../../node_modules/udx-native/lib/ip.js\":{\"#package\":\"/../../node_modules/udx-native/package.json\"},\"/../../node_modules/udx-native/lib/network-interfaces.js\":{\"#package\":\"/../../node_modules/udx-native/package.json\",\"../binding\":\"/../../node_modules/udx-native/binding.js\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"events\":\"/../../node_modules/bare-events/index.js\"},\"/../../node_modules/udx-native/lib/socket.js\":{\"#package\":\"/../../node_modules/udx-native/package.json\",\"../binding\":\"/../../node_modules/udx-native/binding.js\",\"./ip\":\"/../../node_modules/udx-native/lib/ip.js\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"events\":\"/../../node_modules/bare-events/index.js\"},\"/../../node_modules/udx-native/lib/stream.js\":{\"#package\":\"/../../node_modules/udx-native/package.json\",\"../binding\":\"/../../node_modules/udx-native/binding.js\",\"./ip\":\"/../../node_modules/udx-native/lib/ip.js\",\"b4a\":\"/../../node_modules/b4a/index.js\",\"streamx\":\"/../../node_modules/streamx/index.js\"},\"/../../node_modules/udx-native/lib/udx.js\":{\"#package\":\"/../../node_modules/udx-native/package.json\",\"../binding\":\"/../../node_modules/udx-native/binding.js\",\"./ip\":\"/../../node_modules/udx-native/lib/ip.js\",\"./network-interfaces\":\"/../../node_modules/udx-native/lib/network-interfaces.js\",\"./socket\":\"/../../node_modules/udx-native/lib/socket.js\",\"./stream\":\"/../../node_modules/udx-native/lib/stream.js\",\"b4a\":\"/../../node_modules/b4a/index.js\"},\"/../../node_modules/udx-native/package.json\":{},\"/../../node_modules/unordered-set/index.js\":{\"#package\":\"/../../node_modules/unordered-set/package.json\"},\"/../../node_modules/unordered-set/package.json\":{},\"/../../node_modules/unslab/index.js\":{\"#package\":\"/../../node_modules/unslab/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\"},\"/../../node_modules/unslab/package.json\":{},\"/../../node_modules/which-runtime/index.js\":{\"#package\":\"/../../node_modules/which-runtime/package.json\"},\"/../../node_modules/which-runtime/package.json\":{},\"/../../node_modules/xache/index.js\":{\"#package\":\"/../../node_modules/xache/package.json\"},\"/../../node_modules/xache/package.json\":{},\"/../../node_modules/z32/index.js\":{\"#package\":\"/../../node_modules/z32/package.json\",\"b4a\":\"/../../node_modules/b4a/index.js\"},\"/../../node_modules/z32/package.json\":{},\"/backend/swarm-client.mjs\":{\"#package\":\"/package.json\",\"hyperswarm\":\"/../../node_modules/hyperswarm/index.js\"},\"/package.json\":{}},\"addons\":[\"linked:sodium-native.5.0.10.framework/sodium-native.5.0.10\",\"linked:udx-native.1.19.2.framework/udx-native.1.19.2\"],\"assets\":[],\"files\":{\"/../../node_modules/@hyperswarm/secret-stream/index.js\":{\"offset\":0,\"length\":16722,\"mode\":420},\"/../../node_modules/@hyperswarm/secret-stream/lib/bridge.js\":{\"offset\":16722,\"length\":1273,\"mode\":420},\"/../../node_modules/@hyperswarm/secret-stream/lib/handshake.js\":{\"offset\":17995,\"length\":1950,\"mode\":420},\"/../../node_modules/@hyperswarm/secret-stream/package.json\":{\"offset\":19945,\"length\":1132,\"mode\":420},\"/../../node_modules/adaptive-timeout/index.js\":{\"offset\":21077,\"length\":2424,\"mode\":420},\"/../../node_modules/adaptive-timeout/package.json\":{\"offset\":23501,\"length\":972,\"mode\":420},\"/../../node_modules/b4a/index.js\":{\"offset\":24473,\"length\":4054,\"mode\":420},\"/../../node_modules/b4a/package.json\":{\"offset\":28527,\"length\":1140,\"mode\":420},\"/../../node_modules/bare-events/index.js\":{\"offset\":29667,\"length\":8033,\"mode\":420},\"/../../node_modules/bare-events/lib/errors.js\":{\"offset\":37700,\"length\":671,\"mode\":420},\"/../../node_modules/bare-events/package.json\":{\"offset\":38371,\"length\":1399,\"mode\":420},\"/../../node_modules/bits-to-bytes/index.js\":{\"offset\":39770,\"length\":3083,\"mode\":420},\"/../../node_modules/bits-to-bytes/package.json\":{\"offset\":42853,\"length\":708,\"mode\":420},\"/../../node_modules/blind-relay/index.js\":{\"offset\":43561,\"length\":10851,\"mode\":420},\"/../../node_modules/blind-relay/lib/errors.js\":{\"offset\":54412,\"length\":1043,\"mode\":420},\"/../../node_modules/blind-relay/package.json\":{\"offset\":55455,\"length\":1046,\"mode\":420},\"/../../node_modules/bogon/index.js\":{\"offset\":56501,\"length\":4052,\"mode\":420},\"/../../node_modules/bogon/package.json\":{\"offset\":60553,\"length\":657,\"mode\":420},\"/../../node_modules/compact-encoding-bitfield/index.js\":{\"offset\":61210,\"length\":1963,\"mode\":420},\"/../../node_modules/compact-encoding-bitfield/package.json\":{\"offset\":63173,\"length\":827,\"mode\":420},\"/../../node_modules/compact-encoding-net/index.js\":{\"offset\":64000,\"length\":4109,\"mode\":420},\"/../../node_modules/compact-encoding-net/package.json\":{\"offset\":68109,\"length\":734,\"mode\":420},\"/../../node_modules/compact-encoding/endian.js\":{\"offset\":68843,\"length\":105,\"mode\":420},\"/../../node_modules/compact-encoding/index.js\":{\"offset\":68948,\"length\":23634,\"mode\":420},\"/../../node_modules/compact-encoding/lexint.js\":{\"offset\":92582,\"length\":2851,\"mode\":420},\"/../../node_modules/compact-encoding/package.json\":{\"offset\":95433,\"length\":801,\"mode\":420},\"/../../node_modules/compact-encoding/raw.js\":{\"offset\":96234,\"length\":4093,\"mode\":420},\"/../../node_modules/dht-rpc/index.js\":{\"offset\":100327,\"length\":29145,\"mode\":420},\"/../../node_modules/dht-rpc/lib/commands.js\":{\"offset\":129472,\"length\":107,\"mode\":420},\"/../../node_modules/dht-rpc/lib/errors.js\":{\"offset\":129579,\"length\":719,\"mode\":420},\"/../../node_modules/dht-rpc/lib/health.js\":{\"offset\":130298,\"length\":2174,\"mode\":420},\"/../../node_modules/dht-rpc/lib/io.js\":{\"offset\":132472,\"length\":16605,\"mode\":420},\"/../../node_modules/dht-rpc/lib/peer.js\":{\"offset\":149077,\"length\":631,\"mode\":420},\"/../../node_modules/dht-rpc/lib/query.js\":{\"offset\":149708,\"length\":9899,\"mode\":420},\"/../../node_modules/dht-rpc/lib/session.js\":{\"offset\":159607,\"length\":1103,\"mode\":420},\"/../../node_modules/dht-rpc/package.json\":{\"offset\":160710,\"length\":1390,\"mode\":420},\"/../../node_modules/events-universal/bare.js\":{\"offset\":162100,\"length\":40,\"mode\":420},\"/../../node_modules/events-universal/package.json\":{\"offset\":162140,\"length\":908,\"mode\":420},\"/../../node_modules/fast-fifo/fixed-size.js\":{\"offset\":163048,\"length\":875,\"mode\":420},\"/../../node_modules/fast-fifo/index.js\":{\"offset\":163923,\"length\":972,\"mode\":420},\"/../../node_modules/fast-fifo/package.json\":{\"offset\":164895,\"length\":682,\"mode\":420},\"/../../node_modules/hypercore-crypto/index.js\":{\"offset\":165577,\"length\":5040,\"mode\":420},\"/../../node_modules/hypercore-crypto/package.json\":{\"offset\":170617,\"length\":771,\"mode\":420},\"/../../node_modules/hypercore-id-encoding/index.js\":{\"offset\":171388,\"length\":923,\"mode\":420},\"/../../node_modules/hypercore-id-encoding/package.json\":{\"offset\":172311,\"length\":799,\"mode\":420},\"/../../node_modules/hyperdht/index.js\":{\"offset\":173110,\"length\":16291,\"mode\":420},\"/../../node_modules/hyperdht/lib/announcer.js\":{\"offset\":189401,\"length\":7533,\"mode\":420},\"/../../node_modules/hyperdht/lib/connect.js\":{\"offset\":196934,\"length\":23672,\"mode\":420},\"/../../node_modules/hyperdht/lib/connection-pool.js\":{\"offset\":220606,\"length\":3050,\"mode\":420},\"/../../node_modules/hyperdht/lib/constants.js\":{\"offset\":223656,\"length\":1211,\"mode\":420},\"/../../node_modules/hyperdht/lib/crypto.js\":{\"offset\":224867,\"length\":632,\"mode\":420},\"/../../node_modules/hyperdht/lib/encode.js\":{\"offset\":225499,\"length\":446,\"mode\":420},\"/../../node_modules/hyperdht/lib/errors.js\":{\"offset\":225945,\"length\":3712,\"mode\":420},\"/../../node_modules/hyperdht/lib/holepuncher.js\":{\"offset\":229657,\"length\":10003,\"mode\":420},\"/../../node_modules/hyperdht/lib/messages.js\":{\"offset\":239660,\"length\":11266,\"mode\":420},\"/../../node_modules/hyperdht/lib/nat.js\":{\"offset\":250926,\"length\":4714,\"mode\":420},\"/../../node_modules/hyperdht/lib/noise-wrap.js\":{\"offset\":255640,\"length\":1669,\"mode\":420},\"/../../node_modules/hyperdht/lib/persistent.js\":{\"offset\":257309,\"length\":8086,\"mode\":420},\"/../../node_modules/hyperdht/lib/raw-stream-set.js\":{\"offset\":265395,\"length\":1511,\"mode\":420},\"/../../node_modules/hyperdht/lib/router.js\":{\"offset\":266906,\"length\":6978,\"mode\":420},\"/../../node_modules/hyperdht/lib/secure-payload.js\":{\"offset\":273884,\"length\":1491,\"mode\":420},\"/../../node_modules/hyperdht/lib/semaphore.js\":{\"offset\":275375,\"length\":1577,\"mode\":420},\"/../../node_modules/hyperdht/lib/server.js\":{\"offset\":276952,\"length\":21156,\"mode\":420},\"/../../node_modules/hyperdht/lib/sleeper.js\":{\"offset\":298108,\"length\":690,\"mode\":420},\"/../../node_modules/hyperdht/lib/socket-pool.js\":{\"offset\":298798,\"length\":4343,\"mode\":420},\"/../../node_modules/hyperdht/package.json\":{\"offset\":303141,\"length\":2011,\"mode\":420},\"/../../node_modules/hyperswarm/index.js\":{\"offset\":305152,\"length\":18429,\"mode\":420},\"/../../node_modules/hyperswarm/lib/bulk-timer.js\":{\"offset\":323581,\"length\":728,\"mode\":420},\"/../../node_modules/hyperswarm/lib/connection-set.js\":{\"offset\":324309,\"length\":823,\"mode\":420},\"/../../node_modules/hyperswarm/lib/peer-discovery.js\":{\"offset\":325132,\"length\":9286,\"mode\":420},\"/../../node_modules/hyperswarm/lib/peer-info.js\":{\"offset\":334418,\"length\":2688,\"mode\":420},\"/../../node_modules/hyperswarm/lib/retry-timer.js\":{\"offset\":337106,\"length\":1889,\"mode\":420},\"/../../node_modules/hyperswarm/package.json\":{\"offset\":338995,\"length\":1228,\"mode\":420},\"/../../node_modules/kademlia-routing-table/index.js\":{\"offset\":340223,\"length\":4145,\"mode\":420},\"/../../node_modules/kademlia-routing-table/package.json\":{\"offset\":344368,\"length\":967,\"mode\":420},\"/../../node_modules/nanoassert/index.js\":{\"offset\":345335,\"length\":438,\"mode\":420},\"/../../node_modules/nanoassert/package.json\":{\"offset\":345773,\"length\":647,\"mode\":420},\"/../../node_modules/nat-sampler/index.js\":{\"offset\":346420,\"length\":1550,\"mode\":420},\"/../../node_modules/nat-sampler/package.json\":{\"offset\":347970,\"length\":608,\"mode\":420},\"/../../node_modules/noise-curve-ed/index.js\":{\"offset\":348578,\"length\":1642,\"mode\":420},\"/../../node_modules/noise-curve-ed/package.json\":{\"offset\":350220,\"length\":808,\"mode\":420},\"/../../node_modules/noise-handshake/cipher.js\":{\"offset\":351028,\"length\":2817,\"mode\":420},\"/../../node_modules/noise-handshake/dh.js\":{\"offset\":353845,\"length\":1439,\"mode\":420},\"/../../node_modules/noise-handshake/hkdf.js\":{\"offset\":355284,\"length\":1092,\"mode\":420},\"/../../node_modules/noise-handshake/hmac.js\":{\"offset\":356376,\"length\":1273,\"mode\":420},\"/../../node_modules/noise-handshake/noise.js\":{\"offset\":357649,\"length\":6437,\"mode\":420},\"/../../node_modules/noise-handshake/package.json\":{\"offset\":364086,\"length\":638,\"mode\":420},\"/../../node_modules/noise-handshake/symmetric-state.js\":{\"offset\":364724,\"length\":2206,\"mode\":420},\"/../../node_modules/protomux/index.js\":{\"offset\":366930,\"length\":18996,\"mode\":420},\"/../../node_modules/protomux/package.json\":{\"offset\":385926,\"length\":816,\"mode\":420},\"/../../node_modules/queue-tick/package.json\":{\"offset\":386742,\"length\":669,\"mode\":420},\"/../../node_modules/queue-tick/process-next-tick.js\":{\"offset\":387411,\"length\":160,\"mode\":420},\"/../../node_modules/queue-tick/queue-microtask.js\":{\"offset\":387571,\"length\":108,\"mode\":420},\"/../../node_modules/record-cache/index.js\":{\"offset\":387679,\"length\":3668,\"mode\":420},\"/../../node_modules/record-cache/package.json\":{\"offset\":391347,\"length\":612,\"mode\":420},\"/../../node_modules/require-addon/lib/bare.js\":{\"offset\":391959,\"length\":45,\"mode\":420},\"/../../node_modules/require-addon/package.json\":{\"offset\":392004,\"length\":1449,\"mode\":420},\"/../../node_modules/safety-catch/index.js\":{\"offset\":393453,\"length\":506,\"mode\":420},\"/../../node_modules/safety-catch/package.json\":{\"offset\":393959,\"length\":547,\"mode\":420},\"/../../node_modules/shuffled-priority-queue/index.js\":{\"offset\":394506,\"length\":2607,\"mode\":420},\"/../../node_modules/shuffled-priority-queue/package.json\":{\"offset\":397113,\"length\":691,\"mode\":420},\"/../../node_modules/signal-promise/index.js\":{\"offset\":397804,\"length\":1252,\"mode\":420},\"/../../node_modules/signal-promise/package.json\":{\"offset\":399056,\"length\":503,\"mode\":420},\"/../../node_modules/sodium-native/binding.js\":{\"offset\":399559,\"length\":89,\"mode\":420},\"/../../node_modules/sodium-native/index.js\":{\"offset\":399648,\"length\":66328,\"mode\":420},\"/../../node_modules/sodium-native/package.json\":{\"offset\":465976,\"length\":1356,\"mode\":420},\"/../../node_modules/sodium-secretstream/index.js\":{\"offset\":467332,\"length\":2257,\"mode\":420},\"/../../node_modules/sodium-secretstream/package.json\":{\"offset\":469589,\"length\":657,\"mode\":420},\"/../../node_modules/sodium-universal/index.js\":{\"offset\":470246,\"length\":42,\"mode\":420},\"/../../node_modules/sodium-universal/package.json\":{\"offset\":470288,\"length\":1217,\"mode\":420},\"/../../node_modules/streamx/index.js\":{\"offset\":471505,\"length\":33350,\"mode\":420},\"/../../node_modules/streamx/package.json\":{\"offset\":504855,\"length\":836,\"mode\":420},\"/../../node_modules/text-decoder/index.js\":{\"offset\":505691,\"length\":1378,\"mode\":420},\"/../../node_modules/text-decoder/lib/pass-through-decoder.js\":{\"offset\":507069,\"length\":273,\"mode\":420},\"/../../node_modules/text-decoder/lib/utf8-decoder.js\":{\"offset\":507342,\"length\":2529,\"mode\":420},\"/../../node_modules/text-decoder/package.json\":{\"offset\":509871,\"length\":987,\"mode\":420},\"/../../node_modules/time-ordered-set/index.js\":{\"offset\":510858,\"length\":1444,\"mode\":420},\"/../../node_modules/time-ordered-set/package.json\":{\"offset\":512302,\"length\":666,\"mode\":420},\"/../../node_modules/timeout-refresh/browser.js\":{\"offset\":512968,\"length\":1098,\"mode\":420},\"/../../node_modules/timeout-refresh/index.js\":{\"offset\":514066,\"length\":184,\"mode\":420},\"/../../node_modules/timeout-refresh/node.js\":{\"offset\":514250,\"length\":928,\"mode\":420},\"/../../node_modules/timeout-refresh/package.json\":{\"offset\":515178,\"length\":619,\"mode\":420},\"/../../node_modules/udx-native/binding.js\":{\"offset\":515797,\"length\":90,\"mode\":420},\"/../../node_modules/udx-native/lib/ip.js\":{\"offset\":515887,\"length\":2204,\"mode\":420},\"/../../node_modules/udx-native/lib/network-interfaces.js\":{\"offset\":518091,\"length\":1341,\"mode\":420},\"/../../node_modules/udx-native/lib/socket.js\":{\"offset\":519432,\"length\":7557,\"mode\":420},\"/../../node_modules/udx-native/lib/stream.js\":{\"offset\":526989,\"length\":12706,\"mode\":420},\"/../../node_modules/udx-native/lib/udx.js\":{\"offset\":539695,\"length\":2868,\"mode\":420},\"/../../node_modules/udx-native/package.json\":{\"offset\":542563,\"length\":1615,\"mode\":420},\"/../../node_modules/unordered-set/index.js\":{\"offset\":544178,\"length\":677,\"mode\":420},\"/../../node_modules/unordered-set/package.json\":{\"offset\":544855,\"length\":654,\"mode\":420},\"/../../node_modules/unslab/index.js\":{\"offset\":545509,\"length\":913,\"mode\":420},\"/../../node_modules/unslab/package.json\":{\"offset\":546422,\"length\":613,\"mode\":420},\"/../../node_modules/which-runtime/index.js\":{\"offset\":547035,\"length\":1231,\"mode\":420},\"/../../node_modules/which-runtime/package.json\":{\"offset\":548266,\"length\":602,\"mode\":420},\"/../../node_modules/xache/index.js\":{\"offset\":548868,\"length\":2378,\"mode\":420},\"/../../node_modules/xache/package.json\":{\"offset\":551246,\"length\":584,\"mode\":420},\"/../../node_modules/z32/index.js\":{\"offset\":551830,\"length\":2654,\"mode\":420},\"/../../node_modules/z32/package.json\":{\"offset\":554484,\"length\":701,\"mode\":420},\"/backend/swarm-client.mjs\":{\"offset\":555185,\"length\":24465,\"mode\":420},\"/package.json\":{\"offset\":579650,\"length\":961,\"mode\":420}}}\nconst { Pull, Push, HEADERBYTES, KEYBYTES, ABYTES } = require('sodium-secretstream')\nconst sodium = require('sodium-universal')\nconst crypto = require('hypercore-crypto')\nconst { Duplex, Writable, getStreamError } = require('streamx')\nconst b4a = require('b4a')\nconst Timeout = require('timeout-refresh')\nconst unslab = require('unslab')\nconst Bridge = require('./lib/bridge')\nconst Handshake = require('./lib/handshake')\n\nconst IDHEADERBYTES = HEADERBYTES + 32\nconst [NS_INITIATOR, NS_RESPONDER, NS_SEND] = crypto.namespace('hyperswarm/secret-stream', 3)\nconst MAX_ATOMIC_WRITE = 256 * 256 * 256 - 1\n\nmodule.exports = class NoiseSecretStream extends Duplex {\n  constructor(isInitiator, rawStream, opts = {}) {\n    super({ mapWritable: toBuffer })\n\n    if (typeof isInitiator !== 'boolean') {\n      throw new Error('isInitiator should be a boolean')\n    }\n\n    this.noiseStream = this\n    this.isInitiator = isInitiator\n    this.rawStream = null\n\n    this.publicKey = opts.publicKey || null\n    this.remotePublicKey = opts.remotePublicKey || null\n    this.handshakeHash = null\n    this.connected = false\n    this.keepAlive = opts.keepAlive || 0\n    this.timeout = 0\n    this.enableSend = opts.enableSend !== false\n\n    // pointer for upstream to set data here if they want\n    this.userData = null\n\n    let openedDone = null\n    this.opened = new Promise((resolve) => {\n      openedDone = resolve\n    })\n\n    this.rawBytesWritten = 0\n    this.rawBytesRead = 0\n\n    // metadata used by 'hyperdht'\n    this.relay = null\n    this.puncher = null\n\n    // unwrapped raw stream\n    this._rawStream = null\n\n    // handshake state\n    this._handshake = null\n    this._handshakePattern = opts.pattern || null\n    this._handshakeDone = null\n\n    // message parsing state\n    this._state = 0\n    this._len = 0\n    this._tmp = 1\n    this._message = null\n\n    this._openedDone = openedDone\n    this._startDone = null\n    this._drainDone = null\n    this._outgoingPlain = null\n    this._outgoingWrapped = null\n    this._utp = null\n    this._setup = true\n    this._ended = 2\n    this._encrypt = null\n    this._decrypt = null\n    this._timeoutTimer = null\n    this._keepAliveTimer = null\n    this._sendState = null\n\n    if (opts.autoStart !== false) this.start(rawStream, opts)\n\n    // wiggle it to trigger open immediately (TODO add streamx option for this)\n    this.resume()\n    this.pause()\n  }\n\n  static keyPair(seed) {\n    return Handshake.keyPair(seed)\n  }\n\n  static id(handshakeHash, isInitiator, id) {\n    return streamId(handshakeHash, isInitiator, id)\n  }\n\n  setTimeout(ms) {\n    if (!ms) ms = 0\n\n    this._clearTimeout()\n    this.timeout = ms\n\n    if (!ms || this.rawStream === null) return\n\n    this._timeoutTimer = Timeout.once(ms, destroyTimeout, this)\n    this._timeoutTimer.unref()\n  }\n\n  setKeepAlive(ms) {\n    if (!ms) ms = 0\n\n    this._clearKeepAlive()\n\n    this.keepAlive = ms\n\n    if (!ms || this.rawStream === null) return\n\n    this._keepAliveTimer = Timeout.on(ms, sendKeepAlive, this)\n    this._keepAliveTimer.unref()\n  }\n\n  sendKeepAlive() {\n    const empty = this.alloc(0)\n    this.write(empty)\n  }\n\n  start(rawStream, opts = {}) {\n    if (rawStream) {\n      this.rawStream = rawStream\n      this._rawStream = rawStream\n      if (typeof this.rawStream.setContentSize === 'function') {\n        this._utp = rawStream\n      }\n    } else {\n      this.rawStream = new Bridge(this)\n      this._rawStream = this.rawStream.reverse\n    }\n\n    this.rawStream.on('error', this._onrawerror.bind(this))\n    this.rawStream.on('close', this._onrawclose.bind(this))\n\n    this._startHandshake(opts.handshake, opts.keyPair || null)\n    this._continueOpen(null)\n\n    if (this.destroying) return\n\n    if (opts.data) this._onrawdata(opts.data)\n    if (opts.ended) this._onrawend()\n\n    if (this.keepAlive > 0 && this._keepAliveTimer === null) {\n      this.setKeepAlive(this.keepAlive)\n    }\n\n    if (this.timeout > 0 && this._timeoutTimer === null) {\n      this.setTimeout(this.timeout)\n    }\n  }\n\n  async flush() {\n    if ((await this.opened) === false) return false\n    if ((await Writable.drained(this)) === false) return false\n    if (this.destroying) return false\n\n    if (this.rawStream !== null && this.rawStream.flush) {\n      return await this.rawStream.flush()\n    }\n\n    return true\n  }\n\n  _continueOpen(err) {\n    if (err) this.destroy(err)\n    if (this._startDone === null) return\n    const done = this._startDone\n    this._startDone = null\n    this._open(done)\n  }\n\n  _onkeypairpromise(p) {\n    const self = this\n    const cont = this._continueOpen.bind(this)\n\n    p.then(onkeypair, cont)\n\n    function onkeypair(kp) {\n      self._onkeypair(kp)\n      cont(null)\n    }\n  }\n\n  _onkeypair(keyPair) {\n    const pattern = this._handshakePattern || 'XX'\n    const remotePublicKey = this.remotePublicKey\n\n    this._handshake = new Handshake(this.isInitiator, keyPair, remotePublicKey, pattern)\n    this.publicKey = this._handshake.keyPair.publicKey\n  }\n\n  _startHandshake(handshake, keyPair) {\n    if (handshake) {\n      const { tx, rx, hash, publicKey, remotePublicKey } = handshake\n      this._setupSecretStream(tx, rx, hash, publicKey, remotePublicKey)\n      return\n    }\n\n    if (!keyPair) keyPair = Handshake.keyPair()\n\n    if (typeof keyPair.then === 'function') {\n      this._onkeypairpromise(keyPair)\n    } else {\n      this._onkeypair(keyPair)\n    }\n  }\n\n  _onrawerror(err) {\n    this.destroy(err)\n  }\n\n  _onrawclose() {\n    if (this._ended !== 0) this.destroy()\n  }\n\n  _onrawdata(data) {\n    let offset = 0\n\n    if (this._timeoutTimer !== null) {\n      this._timeoutTimer.refresh()\n    }\n\n    do {\n      switch (this._state) {\n        case 0: {\n          while (this._tmp !== 0x1000000 && offset < data.byteLength) {\n            const v = data[offset++]\n            this._len += this._tmp * v\n            this._tmp *= 256\n          }\n\n          if (this._tmp === 0x1000000) {\n            this._tmp = 0\n            this._state = 1\n            const unprocessed = data.byteLength - offset\n            if (unprocessed < this._len && this._utp !== null)\n              this._utp.setContentSize(this._len - unprocessed)\n          }\n\n          break\n        }\n\n        case 1: {\n          const missing = this._len - this._tmp\n          const end = missing + offset\n\n          if (this._message === null && end <= data.byteLength) {\n            this._message = data.subarray(offset, end)\n            offset += missing\n            this._incoming()\n            break\n          }\n\n          const unprocessed = data.byteLength - offset\n\n          if (this._message === null) {\n            this._message = b4a.allocUnsafe(this._len)\n          }\n\n          b4a.copy(data, this._message, this._tmp, offset)\n          this._tmp += unprocessed\n\n          if (end <= data.byteLength) {\n            offset += missing\n            this._incoming()\n          } else {\n            offset += unprocessed\n          }\n\n          break\n        }\n      }\n    } while (offset < data.byteLength && !this.destroying)\n  }\n\n  _onrawend() {\n    this._ended--\n    this.push(null)\n  }\n\n  _onrawdrain() {\n    const drain = this._drainDone\n    if (drain === null) return\n    this._drainDone = null\n    drain()\n  }\n\n  _read(cb) {\n    this.rawStream.resume()\n    cb(null)\n  }\n\n  _incoming() {\n    const message = this._message\n\n    this._state = 0\n    this._len = 0\n    this._tmp = 1\n    this._message = null\n\n    if (this._setup === true) {\n      if (this._handshake) {\n        this._onhandshakert(this._handshake.recv(message))\n      } else {\n        if (message.byteLength !== IDHEADERBYTES) {\n          this.destroy(new Error('Invalid header message received'))\n          return\n        }\n\n        const remoteId = message.subarray(0, 32)\n        const expectedId = streamId(this.handshakeHash, !this.isInitiator)\n        const header = message.subarray(32)\n\n        if (!b4a.equals(expectedId, remoteId)) {\n          this.destroy(new Error('Invalid header received'))\n          return\n        }\n\n        this._decrypt.init(header)\n        this._setup = false // setup is now done\n      }\n      return\n    }\n\n    if (message.byteLength < ABYTES) {\n      this.destroy(new Error('Invalid message received'))\n      return\n    }\n\n    this.rawBytesRead += message.byteLength\n\n    const plain = message.subarray(1, message.byteLength - ABYTES + 1)\n\n    try {\n      this._decrypt.next(message, plain)\n    } catch (err) {\n      this.destroy(err)\n      return\n    }\n\n    // If keep alive is selective, eat the empty buffers (ie assume the other side has it enabled also)\n    if (plain.byteLength === 0 && this.keepAlive !== 0) return\n\n    if (this.push(plain) === false) {\n      this.rawStream.pause()\n    }\n  }\n\n  _onhandshakert(h) {\n    if (this._handshakeDone === null) return\n\n    if (h !== null) {\n      if (h.data) this._rawStream.write(h.data)\n      if (!h.tx) return\n    }\n\n    const done = this._handshakeDone\n    const publicKey = this._handshake.keyPair.publicKey\n\n    this._handshakeDone = null\n    this._handshake = null\n\n    if (h === null) return done(new Error('Noise handshake failed'))\n\n    this._setupSecretStream(h.tx, h.rx, h.hash, publicKey, h.remotePublicKey)\n    this._resolveOpened(true)\n    done(null)\n  }\n\n  _setupSecretStream(tx, rx, handshakeHash, publicKey, remotePublicKey) {\n    const buf = b4a.allocUnsafeSlow(3 + IDHEADERBYTES)\n    writeUint24le(IDHEADERBYTES, buf)\n\n    this._encrypt = new Push(unslab(tx.subarray(0, KEYBYTES)), undefined, buf.subarray(3 + 32))\n    this._decrypt = new Pull(unslab(rx.subarray(0, KEYBYTES)))\n\n    this.publicKey = publicKey\n    this.remotePublicKey = remotePublicKey\n    this.handshakeHash = handshakeHash\n\n    const id = buf.subarray(3, 3 + 32)\n    streamId(handshakeHash, this.isInitiator, id)\n\n    // initialize secretbox state for unordered messages\n    this._setupSecretSend(handshakeHash)\n\n    this.emit('handshake')\n    // if rawStream is a bridge, also emit it there\n    if (this.rawStream !== this._rawStream) this.rawStream.emit('handshake')\n\n    if (this.destroying) return\n\n    this._rawStream.write(buf)\n  }\n\n  _setupSecretSend(handshakeHash) {\n    this._sendState = b4a.allocUnsafeSlow(32 + 32 + 8 + 8)\n    const encrypt = this._sendState.subarray(0, 32) // secrets\n    const decrypt = this._sendState.subarray(32, 64)\n    const counter = this._sendState.subarray(64, 72) // nonce\n    const initial = this._sendState.subarray(72)\n\n    const inputs = this.isInitiator\n      ? [\n          [NS_INITIATOR, NS_SEND],\n          [NS_RESPONDER, NS_SEND]\n        ]\n      : [\n          [NS_RESPONDER, NS_SEND],\n          [NS_INITIATOR, NS_SEND]\n        ]\n\n    sodium.crypto_generichash_batch(encrypt, inputs[0], handshakeHash)\n    sodium.crypto_generichash_batch(decrypt, inputs[1], handshakeHash)\n\n    sodium.randombytes_buf(initial)\n    counter.set(initial)\n  }\n\n  _open(cb) {\n    // no autostart or no handshake yet\n    if (this._rawStream === null || (this._handshake === null && this._encrypt === null)) {\n      this._startDone = cb\n      return\n    }\n\n    this._rawStream.on('data', this._onrawdata.bind(this))\n    this._rawStream.on('end', this._onrawend.bind(this))\n    this._rawStream.on('drain', this._onrawdrain.bind(this))\n\n    if (this.enableSend) this._rawStream.on('message', this._onmessage.bind(this))\n\n    if (this._encrypt !== null) {\n      this._resolveOpened(true)\n      return cb(null)\n    }\n\n    this._handshakeDone = cb\n\n    if (this.isInitiator) this._onhandshakert(this._handshake.send())\n  }\n\n  _predestroy() {\n    if (this.rawStream) {\n      const error = getStreamError(this)\n      this.rawStream.destroy(error)\n    }\n\n    if (this._startDone !== null) {\n      const done = this._startDone\n      this._startDone = null\n      done(new Error('Stream destroyed'))\n    }\n\n    if (this._handshakeDone !== null) {\n      const done = this._handshakeDone\n      this._handshakeDone = null\n      done(new Error('Stream destroyed'))\n    }\n\n    if (this._drainDone !== null) {\n      const done = this._drainDone\n      this._drainDone = null\n      done(new Error('Stream destroyed'))\n    }\n  }\n\n  _write(data, cb) {\n    let wrapped = this._outgoingWrapped\n\n    if (data !== this._outgoingPlain) {\n      wrapped = b4a.allocUnsafe(data.byteLength + 3 + ABYTES)\n      wrapped.set(data, 4)\n    } else {\n      this._outgoingWrapped = this._outgoingPlain = null\n    }\n\n    if (wrapped.byteLength - 3 > MAX_ATOMIC_WRITE) {\n      return cb(\n        new Error(\n          'Message is too large for an atomic write. Max size is ' + MAX_ATOMIC_WRITE + ' bytes.'\n        )\n      )\n    }\n    this.rawBytesWritten += wrapped.byteLength\n\n    writeUint24le(wrapped.byteLength - 3, wrapped)\n    // offset 4 so we can do it in-place\n    this._encrypt.next(wrapped.subarray(4, 4 + data.byteLength), wrapped.subarray(3))\n\n    if (this._keepAliveTimer !== null) this._keepAliveTimer.refresh()\n\n    if (this._rawStream.write(wrapped) === false) {\n      this._drainDone = cb\n    } else {\n      cb(null)\n    }\n  }\n\n  _final(cb) {\n    this._clearKeepAlive()\n    this._ended--\n    this._rawStream.end()\n    cb(null)\n  }\n\n  _resolveOpened(val) {\n    if (this._openedDone === null) return\n    const opened = this._openedDone\n    this._openedDone = null\n    opened(val)\n    if (!val) return\n    this.connected = true\n    this.emit('connect')\n  }\n\n  _clearTimeout() {\n    if (this._timeoutTimer === null) return\n    this._timeoutTimer.destroy()\n    this._timeoutTimer = null\n    this.timeout = 0\n  }\n\n  _clearKeepAlive() {\n    if (this._keepAliveTimer === null) return\n    this._keepAliveTimer.destroy()\n    this._keepAliveTimer = null\n    this.keepAlive = 0\n  }\n\n  _destroy(cb) {\n    this._clearKeepAlive()\n    this._clearTimeout()\n    this._resolveOpened(false)\n    cb(null)\n  }\n\n  _boxMessage(buffer) {\n    const MB = sodium.crypto_secretbox_MACBYTES // 16\n    const NB = sodium.crypto_secretbox_NONCEBYTES // 24\n\n    const counter = this._sendState.subarray(64, 72)\n    sodium.sodium_increment(counter)\n    if (b4a.equals(counter, this._sendState.subarray(72))) {\n      this.destroy(new Error('udp send nonce exchausted'))\n      return\n    }\n\n    const secret = this._sendState.subarray(0, 32)\n    const envelope = b4a.allocUnsafe(8 + MB + buffer.byteLength)\n    const nonce = envelope.subarray(0, NB)\n    const ciphertext = envelope.subarray(8)\n\n    b4a.fill(nonce, 0) // pad suffix\n    nonce.set(counter)\n\n    sodium.crypto_secretbox_easy(ciphertext, buffer, nonce, secret)\n    return envelope\n  }\n\n  send(buffer) {\n    if (!this._sendState) return\n    if (!this.rawStream?.send) return // udx-stream expected\n\n    const message = this._boxMessage(buffer)\n    return this.rawStream.send(message)\n  }\n\n  trySend(buffer) {\n    if (!this._sendState) return\n    if (!this.rawStream?.trySend) return // udx-stream expected\n\n    const message = this._boxMessage(buffer)\n    this.rawStream.trySend(message)\n  }\n\n  _onmessage(buffer) {\n    if (!this._sendState) return // messages before handshake are dropped\n\n    const MB = sodium.crypto_secretbox_MACBYTES // 16\n    const NB = sodium.crypto_secretbox_NONCEBYTES // 24\n\n    if (buffer.byteLength < NB) return // Invalid message\n\n    const nonce = b4a.allocUnsafe(NB)\n    b4a.fill(nonce, 0)\n    nonce.set(buffer.subarray(0, 8))\n\n    const secret = this._sendState.subarray(32, 64)\n    const ciphertext = buffer.subarray(8)\n    const plain = buffer.subarray(8, buffer.byteLength - MB)\n\n    if (ciphertext.byteLength < MB) return // invalid message\n\n    const success = sodium.crypto_secretbox_open_easy(plain, ciphertext, nonce, secret)\n\n    if (success) this.emit('message', plain)\n  }\n\n  alloc(len) {\n    const buf = b4a.allocUnsafe(len + 3 + ABYTES)\n    this._outgoingWrapped = buf\n    this._outgoingPlain = buf.subarray(4, buf.byteLength - ABYTES + 1)\n    return this._outgoingPlain\n  }\n\n  toJSON() {\n    return {\n      isInitiator: this.isInitiator,\n      publicKey: this.publicKey && b4a.toString(this.publicKey, 'hex'),\n      remotePublicKey: this.remotePublicKey && b4a.toString(this.remotePublicKey, 'hex'),\n      connected: this.connected,\n      destroying: this.destroying,\n      destroyed: this.destroyed,\n      rawStream: this.rawStream && this.rawStream.toJSON ? this.rawStream.toJSON() : null\n    }\n  }\n}\n\nfunction writeUint24le(n, buf) {\n  buf[0] = n & 255\n  buf[1] = (n >>> 8) & 255\n  buf[2] = (n >>> 16) & 255\n}\n\nfunction streamId(handshakeHash, isInitiator, out = b4a.allocUnsafe(32)) {\n  sodium.crypto_generichash(out, isInitiator ? NS_INITIATOR : NS_RESPONDER, handshakeHash)\n  return out\n}\n\nfunction toBuffer(data) {\n  return typeof data === 'string' ? b4a.from(data) : data\n}\n\nfunction destroyTimeout() {\n  this.destroy(new Error('Stream timed out'))\n}\n\nfunction sendKeepAlive() {\n  const empty = this.alloc(0)\n  this.write(empty)\n}\nconst { Duplex, Writable } = require('streamx')\n\nclass ReversePassThrough extends Duplex {\n  constructor(s) {\n    super()\n    this._stream = s\n    this._ondrain = null\n  }\n\n  _write(data, cb) {\n    if (this._stream.push(data) === false) {\n      this._stream._ondrain = cb\n    } else {\n      cb(null)\n    }\n  }\n\n  _final(cb) {\n    this._stream.push(null)\n    cb(null)\n  }\n\n  _read(cb) {\n    const ondrain = this._ondrain\n    this._ondrain = null\n    if (ondrain) ondrain()\n    cb(null)\n  }\n}\n\nmodule.exports = class Bridge extends Duplex {\n  constructor(noiseStream) {\n    super()\n\n    this.noiseStream = noiseStream\n\n    this._ondrain = null\n    this.reverse = new ReversePassThrough(this)\n  }\n\n  get publicKey() {\n    return this.noiseStream.publicKey\n  }\n\n  get remotePublicKey() {\n    return this.noiseStream.remotePublicKey\n  }\n\n  get handshakeHash() {\n    return this.noiseStream.handshakeHash\n  }\n\n  flush() {\n    return Writable.drained(this)\n  }\n\n  _read(cb) {\n    const ondrain = this._ondrain\n    this._ondrain = null\n    if (ondrain) ondrain()\n    cb(null)\n  }\n\n  _write(data, cb) {\n    if (this.reverse.push(data) === false) {\n      this.reverse._ondrain = cb\n    } else {\n      cb(null)\n    }\n  }\n\n  _final(cb) {\n    this.reverse.push(null)\n    cb(null)\n  }\n}\nconst sodium = require('sodium-universal')\nconst curve = require('noise-curve-ed')\nconst Noise = require('noise-handshake')\nconst b4a = require('b4a')\n\nconst EMPTY = b4a.alloc(0)\n\nmodule.exports = class Handshake {\n  constructor(isInitiator, keyPair, remotePublicKey, pattern) {\n    this.isInitiator = isInitiator\n    this.keyPair = keyPair\n    this.noise = new Noise(pattern, isInitiator, keyPair, { curve })\n    this.noise.initialise(EMPTY, remotePublicKey)\n    this.destroyed = false\n  }\n\n  static keyPair(seed) {\n    const publicKey = b4a.alloc(32)\n    const secretKey = b4a.alloc(64)\n    if (seed) sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed)\n    else sodium.crypto_sign_keypair(publicKey, secretKey)\n    return { publicKey, secretKey }\n  }\n\n  recv(data) {\n    try {\n      this.noise.recv(data)\n      if (this.noise.complete) return this._return(null)\n      return this.send()\n    } catch {\n      this.destroy()\n      return null\n    }\n  }\n\n  // note that the data returned here is framed so we don't have to do an extra copy\n  // when sending it...\n  send() {\n    try {\n      const data = this.noise.send()\n      const wrap = b4a.allocUnsafe(data.byteLength + 3)\n\n      writeUint24le(data.byteLength, wrap)\n      wrap.set(data, 3)\n\n      return this._return(wrap)\n    } catch {\n      this.destroy()\n      return null\n    }\n  }\n\n  destroy() {\n    if (this.destroyed) return\n    this.destroyed = true\n  }\n\n  _return(data) {\n    const tx = this.noise.complete ? b4a.toBuffer(this.noise.tx) : null\n    const rx = this.noise.complete ? b4a.toBuffer(this.noise.rx) : null\n    const hash = this.noise.complete ? b4a.toBuffer(this.noise.hash) : null\n    const remotePublicKey = this.noise.complete ? b4a.toBuffer(this.noise.rs) : null\n\n    return {\n      data,\n      remotePublicKey,\n      hash,\n      tx,\n      rx\n    }\n  }\n}\n\nfunction writeUint24le(n, buf) {\n  buf[0] = n & 255\n  buf[1] = (n >>> 8) & 255\n  buf[2] = (n >>> 16) & 255\n}\n{\n  \"name\": \"@hyperswarm/secret-stream\",\n  \"version\": \"6.9.1\",\n  \"description\": \"Secret stream backed by Noise and libsodium's secretstream\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"lib/**.js\"\n  ],\n  \"dependencies\": {\n    \"b4a\": \"^1.1.0\",\n    \"hypercore-crypto\": \"^3.3.1\",\n    \"noise-curve-ed\": \"^2.0.1\",\n    \"noise-handshake\": \"^4.0.0\",\n    \"sodium-secretstream\": \"^1.1.0\",\n    \"sodium-universal\": \"^5.0.0\",\n    \"streamx\": \"^2.14.0\",\n    \"timeout-refresh\": \"^2.0.0\",\n    \"unslab\": \"^1.3.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.0\",\n    \"prettier\": \"^3.6.2\",\n    \"prettier-config-holepunch\": \"^2.0.0\",\n    \"udx-native\": \"^1.13.2\"\n  },\n  \"scripts\": {\n    \"format\": \"prettier --write .\",\n    \"lint\": \"prettier --check .\",\n    \"test\": \"brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/holepunchto/hyperswarm-secret-stream.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/hyperswarm-secret-stream/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/hyperswarm-secret-stream\"\n}\nconst Cache = require('xache')\n\nmodule.exports = class AdaptiveTimeout {\n  constructor(opts = {}) {\n    this._cache = new Cache({\n      maxSize: opts.maxSize || 65536,\n      maxAge: opts.maxAge || 10 * 60 * 1000 // 10 minutes\n    })\n    this._fallback = opts.fallback || AdaptiveTimeout.TimeoutExponential\n    this._min = opts.min ?? 300\n    this._max = opts.max || 4000\n    this._jitter = opts.jitter ?? 256\n  }\n\n  // Default - aggressive ramp\n  static TimeoutAggressive = [500, 750, 1000, 1500, 2000]\n\n  // Linear - steady increase\n  static TimeoutLinear = [500, 1000, 1500, 2000, 2500]\n\n  // Exponential - slow start, rapid backoff\n  static TimeoutExponential = [250, 500, 1000, 2000, 4000]\n\n  // Gentle - conservative, patient\n  static TimeoutGentle = [1000, 1250, 1500, 1750, 2000]\n\n  // Fast - rapid fire retries\n  static TimeoutFast = [200, 400, 600, 800, 1000]\n\n  // U-shape - long, short, long\n  static TimeoutUShape = [1500, 750, 500, 750, 1500]\n\n  // Inverse U - short, long, short\n  static TimeoutInverseU = [500, 1000, 1500, 1000, 500]\n\n  // Sawtooth - alternating fast/slow\n  static TimeoutSawtooth = [500, 1500, 500, 1500, 500]\n\n  // Plateau - quick ramp then steady\n  static TimeoutPlateau = [500, 1000, 2000, 2000, 2000]\n\n  // Logarithmic - diminishing increases\n  static TimeoutLogarithmic = [500, 1000, 1300, 1500, 1600]\n\n  getValue(key) {\n    return this._cache.get(key)\n  }\n\n  put(key, value) {\n    let p = this._cache.get(key)\n\n    if (!p) {\n      p = { avg: value, variance: value >> 1 }\n    } else {\n      // blend 75% old + 25% new deviation\n      p.variance += (Math.abs(p.avg - value) - p.variance) >> 2\n      // blend 87.5% old + 12.5% new sample\n      p.avg += (value - p.avg) >> 3\n    }\n\n    this._cache.set(key, p)\n\n    return p\n  }\n\n  get(key, attempt = 1) {\n    const p = this._cache.get(key)\n    const jitter = (Math.random() * this._jitter) | 0\n\n    if (p) {\n      // known - use adaptive with linear backoff\n      const base = p.avg + (p.variance << 1)\n      const backoff = base * attempt\n      return Math.min(Math.max(backoff + jitter, this._min), this._max)\n    } else {\n      // unknown - use aggressive fallback\n      const base = this._fallback[Math.min(attempt - 1, this._fallback.length - 1)]\n      return base + jitter\n    }\n  }\n\n  has(key) {\n    return this._cache.has(key)\n  }\n\n  delete(key) {\n    return this._cache.delete(key)\n  }\n\n  clear() {\n    this._cache.clear()\n  }\n}\n{\n  \"name\": \"adaptive-timeout\",\n  \"version\": \"1.0.1\",\n  \"description\": \"adaptive-timeout\",\n  \"main\": \"index.js\",\n  \"exports\": {\n    \"./package\": \"./package.json\",\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"default\": \"./index.js\"\n    }\n  },\n  \"files\": [\n    \"package.json\",\n    \"index.js\",\n    \"index.d.ts\"\n  ],\n  \"devDependencies\": {\n    \"brittle\": \"^3.19.0\",\n    \"lunte\": \"^1.2.0\",\n    \"prettier\": \"^3.6.2\",\n    \"prettier-config-holepunch\": \"^2.0.0\"\n  },\n  \"scripts\": {\n    \"format\": \"prettier . --write\",\n    \"test\": \"prettier . --check && lunte && brittle-bare test/index.js\",\n    \"lint\": \"lunte\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/holepunchto/adaptive-timeout.git\"\n  },\n  \"author\": \"Holepunch Inc\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/adaptive-timeout/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/adaptive-timeout\",\n  \"dependencies\": {\n    \"xache\": \"^1.2.1\"\n  }\n}\nfunction isBuffer(value) {\n  return Buffer.isBuffer(value) || value instanceof Uint8Array\n}\n\nfunction isEncoding(encoding) {\n  return Buffer.isEncoding(encoding)\n}\n\nfunction alloc(size, fill, encoding) {\n  return Buffer.alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe(size) {\n  return Buffer.allocUnsafe(size)\n}\n\nfunction allocUnsafeSlow(size) {\n  return Buffer.allocUnsafeSlow(size)\n}\n\nfunction byteLength(string, encoding) {\n  return Buffer.byteLength(string, encoding)\n}\n\nfunction compare(a, b) {\n  return Buffer.compare(a, b)\n}\n\nfunction concat(buffers, totalLength) {\n  return Buffer.concat(buffers, totalLength)\n}\n\nfunction copy(source, target, targetStart, start, end) {\n  return toBuffer(source).copy(target, targetStart, start, end)\n}\n\nfunction equals(a, b) {\n  return toBuffer(a).equals(b)\n}\n\nfunction fill(buffer, value, offset, end, encoding) {\n  return toBuffer(buffer).fill(value, offset, end, encoding)\n}\n\nfunction from(value, encodingOrOffset, length) {\n  return Buffer.from(value, encodingOrOffset, length)\n}\n\nfunction includes(buffer, value, byteOffset, encoding) {\n  return toBuffer(buffer).includes(value, byteOffset, encoding)\n}\n\nfunction indexOf(buffer, value, byfeOffset, encoding) {\n  return toBuffer(buffer).indexOf(value, byfeOffset, encoding)\n}\n\nfunction lastIndexOf(buffer, value, byteOffset, encoding) {\n  return toBuffer(buffer).lastIndexOf(value, byteOffset, encoding)\n}\n\nfunction swap16(buffer) {\n  return toBuffer(buffer).swap16()\n}\n\nfunction swap32(buffer) {\n  return toBuffer(buffer).swap32()\n}\n\nfunction swap64(buffer) {\n  return toBuffer(buffer).swap64()\n}\n\nfunction toBuffer(buffer) {\n  if (Buffer.isBuffer(buffer)) return buffer\n  return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n}\n\nfunction toString(buffer, encoding, start, end) {\n  return toBuffer(buffer).toString(encoding, start, end)\n}\n\nfunction write(buffer, string, offset, length, encoding) {\n  return toBuffer(buffer).write(string, offset, length, encoding)\n}\n\nfunction readDoubleBE(buffer, offset) {\n  return toBuffer(buffer).readDoubleBE(offset)\n}\n\nfunction readDoubleLE(buffer, offset) {\n  return toBuffer(buffer).readDoubleLE(offset)\n}\n\nfunction readFloatBE(buffer, offset) {\n  return toBuffer(buffer).readFloatBE(offset)\n}\n\nfunction readFloatLE(buffer, offset) {\n  return toBuffer(buffer).readFloatLE(offset)\n}\n\nfunction readInt32BE(buffer, offset) {\n  return toBuffer(buffer).readInt32BE(offset)\n}\n\nfunction readInt32LE(buffer, offset) {\n  return toBuffer(buffer).readInt32LE(offset)\n}\n\nfunction readUInt32BE(buffer, offset) {\n  return toBuffer(buffer).readUInt32BE(offset)\n}\n\nfunction readUInt32LE(buffer, offset) {\n  return toBuffer(buffer).readUInt32LE(offset)\n}\n\nfunction writeDoubleBE(buffer, value, offset) {\n  return toBuffer(buffer).writeDoubleBE(value, offset)\n}\n\nfunction writeDoubleLE(buffer, value, offset) {\n  return toBuffer(buffer).writeDoubleLE(value, offset)\n}\n\nfunction writeFloatBE(buffer, value, offset) {\n  return toBuffer(buffer).writeFloatBE(value, offset)\n}\n\nfunction writeFloatLE(buffer, value, offset) {\n  return toBuffer(buffer).writeFloatLE(value, offset)\n}\n\nfunction writeInt32BE(buffer, value, offset) {\n  return toBuffer(buffer).writeInt32BE(value, offset)\n}\n\nfunction writeInt32LE(buffer, value, offset) {\n  return toBuffer(buffer).writeInt32LE(value, offset)\n}\n\nfunction writeUInt32BE(buffer, value, offset) {\n  return toBuffer(buffer).writeUInt32BE(value, offset)\n}\n\nfunction writeUInt32LE(buffer, value, offset) {\n  return toBuffer(buffer).writeUInt32LE(value, offset)\n}\n\nmodule.exports = {\n  isBuffer,\n  isEncoding,\n  alloc,\n  allocUnsafe,\n  allocUnsafeSlow,\n  byteLength,\n  compare,\n  concat,\n  copy,\n  equals,\n  fill,\n  from,\n  includes,\n  indexOf,\n  lastIndexOf,\n  swap16,\n  swap32,\n  swap64,\n  toBuffer,\n  toString,\n  write,\n  readDoubleBE,\n  readDoubleLE,\n  readFloatBE,\n  readFloatLE,\n  readInt32BE,\n  readInt32LE,\n  readUInt32BE,\n  readUInt32LE,\n  writeDoubleBE,\n  writeDoubleLE,\n  writeFloatBE,\n  writeFloatLE,\n  writeInt32BE,\n  writeInt32LE,\n  writeUInt32BE,\n  writeUInt32LE\n}\n{\n  \"name\": \"b4a\",\n  \"version\": \"1.7.3\",\n  \"description\": \"Bridging the gap between buffers and typed arrays\",\n  \"exports\": {\n    \"./package\": \"./package.json\",\n    \".\": {\n      \"react-native\": \"./react-native.js\",\n      \"browser\": \"./browser.js\",\n      \"default\": \"./index.js\"\n    }\n  },\n  \"files\": [\n    \"browser.js\",\n    \"index.js\",\n    \"react-native.js\",\n    \"lib\"\n  ],\n  \"scripts\": {\n    \"test\": \"npm run lint && npm run test:bare && npm run test:node\",\n    \"test:bare\": \"bare test.mjs\",\n    \"test:node\": \"node test.mjs\",\n    \"lint\": \"prettier . --check\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/b4a.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/b4a/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/b4a#readme\",\n  \"devDependencies\": {\n    \"brittle\": \"^3.5.2\",\n    \"nanobench\": \"^3.0.0\",\n    \"prettier\": \"^3.6.2\",\n    \"prettier-config-holepunch\": \"^1.0.0\"\n  },\n  \"peerDependencies\": {\n    \"react-native-b4a\": \"*\"\n  },\n  \"peerDependenciesMeta\": {\n    \"react-native-b4a\": {\n      \"optional\": true\n    }\n  }\n}\nconst errors = require('./lib/errors')\n\nclass EventListener {\n  constructor() {\n    this.list = []\n    this.count = 0\n  }\n\n  append(ctx, name, fn, once) {\n    this.count++\n    ctx.emit('newListener', name, fn) // Emit BEFORE adding\n    this.list.push([fn, once])\n  }\n\n  prepend(ctx, name, fn, once) {\n    this.count++\n    ctx.emit('newListener', name, fn) // Emit BEFORE adding\n    this.list.unshift([fn, once])\n  }\n\n  remove(ctx, name, fn) {\n    for (let i = 0, n = this.list.length; i < n; i++) {\n      const l = this.list[i]\n\n      if (l[0] === fn) {\n        this.list.splice(i, 1)\n\n        if (this.count === 1) delete ctx._events[name]\n\n        ctx.emit('removeListener', name, fn) // Emit AFTER removing\n\n        this.count--\n        return\n      }\n    }\n  }\n\n  removeAll(ctx, name) {\n    const list = [...this.list]\n    this.list = []\n\n    if (this.count === list.length) delete ctx._events[name]\n\n    for (let i = list.length - 1; i >= 0; i--) {\n      ctx.emit('removeListener', name, list[i][0]) // Emit AFTER removing\n    }\n\n    this.count -= list.length\n  }\n\n  emit(ctx, name, ...args) {\n    const list = [...this.list]\n\n    for (let i = 0, n = list.length; i < n; i++) {\n      const l = list[i]\n\n      if (l[1] === true) this.remove(ctx, name, l[0])\n\n      Reflect.apply(l[0], ctx, args)\n    }\n\n    return list.length > 0\n  }\n}\n\nfunction appendListener(ctx, name, fn, once) {\n  if (ctx._events === undefined) ctx._events = Object.create(null)\n  const e = ctx._events[name] || (ctx._events[name] = new EventListener())\n  e.append(ctx, name, fn, once)\n  return ctx\n}\n\nfunction prependListener(ctx, name, fn, once) {\n  if (ctx._events === undefined) ctx._events = Object.create(null)\n  const e = ctx._events[name] || (ctx._events[name] = new EventListener())\n  e.prepend(ctx, name, fn, once)\n  return ctx\n}\n\nfunction removeListener(ctx, name, fn) {\n  if (ctx._events === undefined) return ctx\n  const e = ctx._events[name]\n  if (e !== undefined) e.remove(ctx, name, fn)\n  return ctx\n}\n\nfunction throwUnhandledError(...args) {\n  let err\n\n  if (args.length > 0) err = args[0]\n\n  if (err instanceof Error === false) err = errors.UNHANDLED_ERROR(err)\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(err, exports.prototype.emit)\n  }\n\n  queueMicrotask(() => {\n    throw err\n  })\n}\n\nmodule.exports = exports = class EventEmitter {\n  constructor() {\n    this._events = Object.create(null)\n  }\n\n  addListener(name, fn) {\n    return appendListener(this, name, fn, false)\n  }\n\n  addOnceListener(name, fn) {\n    return appendListener(this, name, fn, true)\n  }\n\n  prependListener(name, fn) {\n    return prependListener(this, name, fn, false)\n  }\n\n  prependOnceListener(name, fn) {\n    return prependListener(this, name, fn, true)\n  }\n\n  removeListener(name, fn) {\n    return removeListener(this, name, fn)\n  }\n\n  on(name, fn) {\n    return appendListener(this, name, fn, false)\n  }\n\n  once(name, fn) {\n    return appendListener(this, name, fn, true)\n  }\n\n  off(name, fn) {\n    return removeListener(this, name, fn)\n  }\n\n  emit(name, ...args) {\n    if (name === 'error' && this._events !== undefined && this._events.error === undefined) {\n      throwUnhandledError(...args)\n    }\n\n    if (this._events === undefined) return false\n    const e = this._events[name]\n    return e === undefined ? false : e.emit(this, name, ...args)\n  }\n\n  listeners(name) {\n    if (this._events === undefined) return []\n    const e = this._events[name]\n    return e === undefined ? [] : [...e.list]\n  }\n\n  listenerCount(name) {\n    if (this._events === undefined) return 0\n    const e = this._events[name]\n    return e === undefined ? 0 : e.list.length\n  }\n\n  getMaxListeners() {\n    return EventEmitter.defaultMaxListeners\n  }\n\n  setMaxListeners(n) {}\n\n  removeAllListeners(name) {\n    if (arguments.length === 0) {\n      for (const key of Reflect.ownKeys(this._events)) {\n        if (key === 'removeListener') continue\n        this.removeAllListeners(key)\n      }\n      this.removeAllListeners('removeListener')\n    } else {\n      const e = this._events[name]\n      if (e !== undefined) e.removeAll(this, name)\n    }\n    return this\n  }\n}\n\nexports.EventEmitter = exports\n\nexports.errors = errors\n\nexports.defaultMaxListeners = 10\n\nexports.on = function on(emitter, name, opts = {}) {\n  const { signal } = opts\n\n  if (signal && signal.aborted) {\n    throw errors.OPERATION_ABORTED(signal.reason)\n  }\n\n  let error = null\n  let done = false\n\n  const events = []\n  const promises = []\n\n  if (name !== 'error') emitter.on('error', onerror)\n\n  if (signal) signal.addEventListener('abort', onabort)\n\n  emitter.on(name, onevent)\n\n  return {\n    next() {\n      if (events.length) {\n        return Promise.resolve({ value: events.shift(), done: false })\n      }\n\n      if (error) {\n        const err = error\n\n        error = null\n\n        return Promise.reject(err)\n      }\n\n      if (done) return onclose()\n\n      return new Promise((resolve, reject) => promises.push({ resolve, reject }))\n    },\n\n    return() {\n      return onclose()\n    },\n\n    throw(err) {\n      return onerror(err)\n    },\n\n    [Symbol.asyncIterator]() {\n      return this\n    }\n  }\n\n  function onevent(...args) {\n    if (promises.length) {\n      promises.shift().resolve({ value: args, done: false })\n    } else {\n      events.push(args)\n    }\n  }\n\n  function onerror(err) {\n    emitter.off(name, onevent).off('error', onerror)\n\n    if (promises.length) {\n      promises.shift().reject(err)\n    } else {\n      error = err\n    }\n\n    return Promise.resolve({ done: true })\n  }\n\n  function onabort() {\n    signal.removeEventListener('abort', onabort)\n\n    onerror(errors.OPERATION_ABORTED(signal.reason))\n  }\n\n  function onclose() {\n    emitter.off(name, onevent)\n\n    if (name !== 'error') emitter.off('error', onerror)\n\n    if (signal) signal.removeEventListener('abort', onabort)\n\n    done = true\n\n    if (promises.length) promises.shift().resolve({ done: true })\n\n    return Promise.resolve({ done: true })\n  }\n}\n\nexports.once = function once(emitter, name, opts = {}) {\n  const { signal } = opts\n\n  if (signal && signal.aborted) {\n    return Promise.reject(errors.OPERATION_ABORTED(signal.reason))\n  }\n\n  return new Promise((resolve, reject) => {\n    if (name !== 'error') emitter.on('error', onerror)\n\n    if (signal) signal.addEventListener('abort', onabort)\n\n    emitter.once(name, onevent)\n\n    function onevent(...args) {\n      if (name !== 'error') emitter.off('error', onerror)\n\n      if (signal) signal.removeEventListener('abort', onabort)\n\n      resolve(args)\n    }\n\n    function onerror(err) {\n      emitter.off(name, onevent)\n\n      if (name !== 'error') emitter.off('error', onerror)\n\n      reject(err)\n    }\n\n    function onabort() {\n      signal.removeEventListener('abort', onabort)\n\n      onerror(errors.OPERATION_ABORTED(signal.reason))\n    }\n  })\n}\n\nexports.forward = function forward(from, to, names, opts = {}) {\n  if (typeof names === 'string') names = [names]\n\n  const { emit = to.emit.bind(to) } = opts\n\n  const listeners = names.map(\n    (name) =>\n      function onevent(...args) {\n        emit(name, ...args)\n      }\n  )\n\n  to.on('newListener', (name) => {\n    const i = names.indexOf(name)\n\n    if (i !== -1 && to.listenerCount(name) === 0) {\n      from.on(name, listeners[i])\n    }\n  }).on('removeListener', (name) => {\n    const i = names.indexOf(name)\n\n    if (i !== -1 && to.listenerCount(name) === 0) {\n      from.off(name, listeners[i])\n    }\n  })\n}\n\nexports.listenerCount = function listenerCount(emitter, name) {\n  return emitter.listenerCount(name)\n}\n\nexports.getMaxListeners = function getMaxListeners(emitter) {\n  if (typeof emitter.getMaxListeners === 'function') {\n    return emitter.getMaxListeners()\n  }\n\n  return exports.defaultMaxListeners\n}\n\nexports.setMaxListeners = function setMaxListeners(n, ...emitters) {\n  if (emitters.length === 0) exports.defaultMaxListeners = n\n  else {\n    for (const emitter of emitters) {\n      if (typeof emitter.setMaxListeners === 'function') {\n        emitter.setMaxListeners(n)\n      }\n    }\n  }\n}\nmodule.exports = class EventEmitterError extends Error {\n  constructor(msg, code, fn = EventEmitterError, opts) {\n    super(`${code}: ${msg}`, opts)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'EventEmitterError'\n  }\n\n  static OPERATION_ABORTED(cause, msg = 'Operation aborted') {\n    return new EventEmitterError(msg, 'OPERATION_ABORTED', EventEmitterError.OPERATION_ABORTED, {\n      cause\n    })\n  }\n\n  static UNHANDLED_ERROR(cause, msg = 'Unhandled error') {\n    return new EventEmitterError(msg, 'UNHANDLED_ERROR', EventEmitterError.UNHANDLED_ERROR, {\n      cause\n    })\n  }\n}\n{\n  \"name\": \"bare-events\",\n  \"version\": \"2.8.2\",\n  \"description\": \"Event emitters for JavaScript\",\n  \"exports\": {\n    \"./package\": \"./package.json\",\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"default\": \"./index.js\"\n    },\n    \"./global\": {\n      \"types\": \"./global.d.ts\",\n      \"default\": \"./global.js\"\n    },\n    \"./web\": {\n      \"types\": \"./web.d.ts\",\n      \"default\": \"./web.js\"\n    },\n    \"./errors\": \"./lib/errors.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"index.d.ts\",\n    \"global.js\",\n    \"global.d.ts\",\n    \"web.js\",\n    \"web.d.ts\",\n    \"lib\"\n  ],\n  \"scripts\": {\n    \"test\": \"npm run lint && npm run test:bare && npm run test:node\",\n    \"test:bare\": \"bare test.js\",\n    \"test:node\": \"node test.js\",\n    \"lint\": \"prettier . --check\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bare-events.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bare-events/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bare-events#readme\",\n  \"devDependencies\": {\n    \"bare-abort-controller\": \"^1.0.0\",\n    \"brittle\": \"^3.3.2\",\n    \"prettier\": \"^3.4.2\",\n    \"prettier-config-holepunch\": \"^2.0.0\",\n    \"uncaughts\": \"^1.1.1\"\n  },\n  \"peerDependencies\": {\n    \"bare-abort-controller\": \"*\"\n  },\n  \"peerDependenciesMeta\": {\n    \"bare-abort-controller\": {\n      \"optional\": true\n    }\n  }\n}\nconst b4a = require('b4a')\n\nfunction byteLength (size) {\n  return Math.ceil(size / 8)\n}\n\nfunction get (buffer, bit) {\n  const n = buffer.BYTES_PER_ELEMENT * 8\n\n  const offset = bit & (n - 1)\n  const i = (bit - offset) / n\n\n  return (buffer[i] & (1 << offset)) !== 0\n}\n\nfunction set (buffer, bit, value = true) {\n  const n = buffer.BYTES_PER_ELEMENT * 8\n\n  const offset = bit & (n - 1)\n  const i = (bit - offset) / n\n  const mask = 1 << offset\n\n  if (value) {\n    if ((buffer[i] & mask) !== 0) return false\n  } else {\n    if ((buffer[i] & mask) === 0) return false\n  }\n\n  buffer[i] ^= mask\n  return true\n}\n\nfunction setRange (buffer, start, end, value = true) {\n  const n = buffer.BYTES_PER_ELEMENT * 8\n\n  let remaining = end - start\n  let offset = start & (n - 1)\n  let i = (start - offset) / n\n\n  let changed = false\n\n  while (remaining > 0) {\n    const mask = (2 ** Math.min(remaining, n - offset) - 1) << offset\n\n    if (value) {\n      if ((buffer[i] & mask) !== mask) {\n        buffer[i] |= mask\n        changed = true\n      }\n    } else {\n      if ((buffer[i] & mask) !== 0) {\n        buffer[i] &= ~mask\n        changed = true\n      }\n    }\n\n    remaining -= n - offset\n    offset = 0\n    i++\n  }\n\n  return changed\n}\n\nfunction fill (buffer, value, start = 0, end = buffer.byteLength * 8) {\n  const n = buffer.BYTES_PER_ELEMENT * 8\n  let i, j\n\n  {\n    const offset = start & (n - 1)\n    i = (start - offset) / n\n\n    if (offset !== 0) {\n      const mask = (2 ** Math.min(n - offset, end - start) - 1) << offset\n\n      if (value) buffer[i] |= mask\n      else buffer[i] &= ~mask\n\n      i++\n    }\n  }\n\n  {\n    const offset = end & (n - 1)\n    j = (end - offset) / n\n\n    if (offset !== 0 && j >= i) {\n      const mask = (2 ** offset) - 1\n\n      if (value) buffer[j] |= mask\n      else buffer[j] &= ~mask\n    }\n  }\n\n  return buffer.fill(value ? (2 ** n) - 1 : 0, i, j)\n}\n\nfunction toggle (buffer, bit) {\n  const n = buffer.BYTES_PER_ELEMENT * 8\n\n  const offset = bit & (n - 1)\n  const i = (bit - offset) / n\n  const mask = 1 << offset\n\n  buffer[i] ^= mask\n  return (buffer[i] & mask) !== 0\n}\n\nfunction remove (buffer, bit) {\n  return set(buffer, bit, false)\n}\n\nfunction removeRange (buffer, start, end) {\n  return setRange(buffer, start, end, false)\n}\n\nfunction indexOf (buffer, value, position = 0) {\n  for (let i = position, n = buffer.byteLength * 8; i < n; i++) {\n    if (get(buffer, i) === value) return i\n  }\n\n  return -1\n}\n\nfunction lastIndexOf (buffer, value, position = buffer.byteLength * 8 - 1) {\n  for (let i = position; i >= 0; i--) {\n    if (get(buffer, i) === value) return i\n  }\n\n  return -1\n}\n\nfunction of (...bits) {\n  return from(bits)\n}\n\nfunction from (bits) {\n  const buffer = b4a.alloc(byteLength(bits.length))\n  for (let i = 0; i < bits.length; i++) set(buffer, i, bits[i])\n  return buffer\n}\n\nfunction * iterator (buffer) {\n  for (let i = 0, n = buffer.byteLength * 8; i < n; i++) yield get(buffer, i)\n}\n\nmodule.exports = {\n  byteLength,\n  get,\n  set,\n  setRange,\n  fill,\n  toggle,\n  remove,\n  removeRange,\n  indexOf,\n  lastIndexOf,\n  of,\n  from,\n  iterator\n}\n{\n  \"name\": \"bits-to-bytes\",\n  \"version\": \"1.3.0\",\n  \"description\": \"Functions for doing bit manipulation of typed arrays\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && brittle test.mjs\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/bits-to-bytes.git\"\n  },\n  \"author\": \"Kasper Isager Dalsgar <kasper@funktionel.co>\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/bits-to-bytes/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/bits-to-bytes#readme\",\n  \"dependencies\": {\n    \"b4a\": \"^1.5.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^2.3.1\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nconst EventEmitter = require('events')\nconst Protomux = require('protomux')\nconst { Readable } = require('streamx')\nconst sodium = require('sodium-universal')\nconst b4a = require('b4a')\nconst c = require('compact-encoding')\nconst bitfield = require('compact-encoding-bitfield')\nconst bits = require('bits-to-bytes')\nconst errors = require('./lib/errors')\n\nexports.Server = class BlindRelayServer extends EventEmitter {\n  constructor (opts = {}) {\n    super()\n\n    const {\n      createStream\n    } = opts\n\n    this._createStream = createStream\n    this._pairing = new Map()\n    this._sessions = new Set()\n  }\n\n  get sessions () {\n    return this._sessions[Symbol.iterator]()\n  }\n\n  accept (stream, opts) {\n    const session = new BlindRelaySession(this, stream, opts)\n\n    this._sessions.add(session)\n\n    return session\n  }\n\n  async close () {\n    const ending = []\n\n    for (const session of this._sessions) {\n      ending.push(session.end())\n    }\n\n    await Promise.all(ending)\n\n    this._pairing.clear()\n  }\n}\n\nclass BlindRelaySession extends EventEmitter {\n  constructor (server, stream, opts = {}) {\n    super()\n\n    const {\n      id,\n      handshake,\n      handshakeEncoding\n    } = opts\n\n    this._server = server\n    this._mux = Protomux.from(stream)\n\n    this._channel = this._mux.createChannel({\n      protocol: 'blind-relay',\n      id,\n      handshake: handshake ? handshakeEncoding || c.raw : null,\n      onopen: this._onopen.bind(this),\n      onclose: this._onclose.bind(this),\n      ondestroy: this._ondestroy.bind(this)\n    })\n\n    this._pair = this._channel.addMessage({\n      encoding: m.pair,\n      onmessage: this._onpair.bind(this)\n    })\n\n    this._unpair = this._channel.addMessage({\n      encoding: m.unpair,\n      onmessage: this._onunpair.bind(this)\n    })\n\n    this._ending = null\n    this._destroyed = false\n    this._error = null\n    this._pairing = new Set()\n    this._streams = new Map()\n\n    this._onerror = (err) => this.emit('error', err)\n\n    this._channel.open(handshake)\n  }\n\n  get closed () {\n    return this._channel.closed\n  }\n\n  get mux () {\n    return this._mux\n  }\n\n  get stream () {\n    return this._mux.stream\n  }\n\n  _onopen () {\n    this.emit('open')\n  }\n\n  _onclose () {\n    this._ending = Promise.resolve()\n\n    const err = this._error || errors.CHANNEL_CLOSED()\n\n    for (const token of this._pairing) {\n      this._server._pairing.delete(token.toString('hex'))\n    }\n\n    for (const stream of this._streams.values()) {\n      stream\n        .off('error', this._onerror)\n        .on('error', noop)\n        .destroy(err)\n    }\n\n    this._pairing.clear()\n    this._streams.clear()\n\n    this._server._sessions.delete(this)\n\n    this.emit('close')\n  }\n\n  _ondestroy () {\n    this._destroyed = true\n    this.emit('destroy')\n  }\n\n  _onpair ({ isInitiator, token, id: remoteId }) {\n    const keyString = token.toString('hex')\n\n    let pair = this._server._pairing.get(keyString)\n\n    if (pair === undefined) {\n      pair = new BlindRelayPair(token)\n      this._server._pairing.set(keyString, pair)\n    } else if (pair.links[+isInitiator]) return\n\n    this._pairing.add(keyString)\n\n    pair.links[+isInitiator] = new BlindRelayLink(this, isInitiator, remoteId)\n\n    if (!pair.paired) return\n\n    this._server._pairing.delete(keyString)\n\n    // 1st pass: Create the raw streams needed for each end of the link.\n    for (const link of pair.links) {\n      link.createStream()\n    }\n\n    // 2nd pass: Connect the raw streams and set up handlers.\n    for (const { isInitiator, session, stream } of pair.links) {\n      const remote = pair.remote(isInitiator)\n\n      stream\n        .on('error', session._onerror)\n        .on('close', () => session._streams.delete(keyString))\n        .relayTo(remote.stream)\n\n      session._pairing.delete(keyString)\n      session._streams.set(keyString, stream)\n    }\n\n    // 3rd pass: Let either end of the link know the streams were set up.\n    for (const { isInitiator, session, remoteId, stream } of pair.links) {\n      session._pair.send({\n        isInitiator,\n        token,\n        id: stream.id,\n        seq: 0\n      })\n\n      session._endMaybe()\n\n      session.emit('pair', isInitiator, token, stream, remoteId)\n    }\n  }\n\n  _onunpair ({ token }) {\n    const keyString = token.toString('hex')\n\n    const pair = this._server._pairing.get(keyString)\n\n    if (pair) {\n      for (const link of pair.links) {\n        if (link) link.session._pairing.delete(keyString)\n      }\n\n      return this._server._pairing.delete(keyString)\n    }\n\n    const stream = this._streams.get(keyString)\n\n    if (stream) {\n      stream\n        .off('error', this._onerror)\n        .on('error', noop)\n        .destroy(errors.PAIRING_CANCELLED())\n\n      this._streams.delete(keyString)\n    }\n  }\n\n  cork () {\n    this._channel.cork()\n  }\n\n  uncork () {\n    this._channel.uncork()\n  }\n\n  async end () {\n    if (this._ending) return this._ending\n\n    this._ending = EventEmitter.once(this, 'close')\n    this._endMaybe()\n\n    return this._ending\n  }\n\n  _endMaybe () {\n    if (this._ending && this._pairing.size === 0) {\n      this._channel.close()\n    }\n  }\n\n  destroy (err) {\n    if (this._destroyed) return\n    this._destroyed = true\n\n    this._error = err || errors.CHANNEL_DESTROYED()\n    this._channel.close()\n  }\n}\n\nclass BlindRelayPair {\n  constructor (token) {\n    this.token = token\n    this.links = [null, null]\n  }\n\n  get paired () {\n    return this.links[0] !== null && this.links[1] !== null\n  }\n\n  remote (isInitiator) {\n    return this.links[isInitiator ? 0 : 1]\n  }\n}\n\nclass BlindRelayLink {\n  constructor (session, isInitiator, remoteId) {\n    this.session = session\n    this.isInitiator = isInitiator\n    this.remoteId = remoteId\n    this.stream = null\n  }\n\n  createStream () {\n    if (this.stream) return\n\n    this.stream = this.session._server._createStream({\n      firewall: this._onfirewall.bind(this)\n    })\n  }\n\n  _onfirewall (socket, port, host) {\n    this.stream.connect(socket, this.remoteId, port, host)\n\n    return false\n  }\n}\n\nexports.Client = class BlindRelayClient extends EventEmitter {\n  static _clients = new WeakMap()\n\n  static from (stream, opts) {\n    let client = this._clients.get(stream)\n    if (client) return client\n    client = new this(stream, opts)\n    this._clients.set(stream, client)\n    return client\n  }\n\n  constructor (stream, opts = {}) {\n    super()\n\n    const {\n      id,\n      handshake,\n      handshakeEncoding\n    } = opts\n\n    this._mux = Protomux.from(stream)\n\n    this._channel = this._mux.createChannel({\n      protocol: 'blind-relay',\n      id,\n      handshake: handshake ? handshakeEncoding || c.raw : null,\n      onopen: this._onopen.bind(this),\n      onclose: this._onclose.bind(this),\n      ondestroy: this._ondestroy.bind(this)\n    })\n\n    this._pair = this._channel.addMessage({\n      encoding: m.pair,\n      onmessage: this._onpair.bind(this)\n    })\n\n    this._unpair = this._channel.addMessage({\n      encoding: m.unpair\n    })\n\n    this._ending = false\n    this._destroyed = false\n    this._error = null\n    this._requests = new Map()\n\n    this._channel.open(handshake)\n  }\n\n  get closed () {\n    return this._channel.closed\n  }\n\n  get mux () {\n    return this._mux\n  }\n\n  get stream () {\n    return this._mux.stream\n  }\n\n  get requests () {\n    return this._requests.values()\n  }\n\n  _onopen () {\n    this.emit('open')\n  }\n\n  _onclose () {\n    this._ending = Promise.resolve()\n\n    const err = this._error || errors.CHANNEL_CLOSED()\n\n    for (const request of this._requests.values()) {\n      request.destroy(err)\n    }\n\n    this._requests.clear()\n\n    this.constructor._clients.delete(this.stream)\n\n    this.emit('close')\n  }\n\n  _ondestroy () {\n    this._destroyed = true\n    this.emit('destroy')\n  }\n\n  _onpair ({ isInitiator, token, id: remoteId }) {\n    const request = this._requests.get(token.toString('hex'))\n\n    if (request === undefined || request.isInitiator !== isInitiator) return\n\n    request.push(remoteId)\n    request.push(null)\n\n    this.emit('pair', request.isInitiator, request.token, request.stream, remoteId)\n  }\n\n  pair (isInitiator, token, stream) {\n    if (this._destroyed) throw errors.CHANNEL_DESTROYED()\n\n    const keyString = token.toString('hex')\n\n    if (this._requests.has(keyString)) throw errors.ALREADY_PAIRING()\n\n    const request = new BlindRelayRequest(this, isInitiator, token, stream)\n\n    this._requests.set(keyString, request)\n\n    return request\n  }\n\n  unpair (token) {\n    if (this._destroyed) throw errors.CHANNEL_DESTROYED()\n\n    const request = this._requests.get(token.toString('hex'))\n\n    if (request) request.destroy(errors.PAIRING_CANCELLED())\n\n    this._unpair.send({ token })\n  }\n\n  cork () {\n    this._channel.cork()\n  }\n\n  uncork () {\n    this._channel.uncork()\n  }\n\n  async end () {\n    if (this._ending) return this._ending\n\n    this._ending = EventEmitter.once(this, 'close')\n    this._endMaybe()\n\n    return this._ending\n  }\n\n  _endMaybe () {\n    if (this._ending && this._requests.size === 0) {\n      this._channel.close()\n    }\n  }\n\n  destroy (err) {\n    if (this._destroyed) return\n    this._destroyed = true\n\n    this._error = err || errors.CHANNEL_DESTROYED()\n    this._channel.close()\n  }\n}\n\nclass BlindRelayRequest extends Readable {\n  constructor (client, isInitiator, token, stream) {\n    super()\n\n    this.client = client\n    this.isInitiator = isInitiator\n    this.token = token\n    this.stream = stream\n  }\n\n  _open (cb) {\n    if (this.client._destroyed) return cb(errors.CHANNEL_DESTROYED())\n\n    this.client._pair.send({\n      isInitiator: this.isInitiator,\n      token: this.token,\n      id: this.stream.id,\n      seq: 0\n    })\n\n    cb(null)\n  }\n\n  _destroy (cb) {\n    this.client._requests.delete(this.token.toString('hex'))\n\n    cb(null)\n\n    this.client._endMaybe()\n  }\n}\n\nexports.token = function token (buf = b4a.allocUnsafe(32)) {\n  sodium.randombytes_buf(buf)\n  return buf\n}\n\nfunction noop () {}\n\nconst m = exports.messages = {}\n\nconst flags = bitfield(7)\n\nm.pair = {\n  preencode (state, m) {\n    flags.preencode(state)\n    c.fixed32.preencode(state, m.token)\n    c.uint.preencode(state, m.id)\n    c.uint.preencode(state, m.seq)\n  },\n  encode (state, m) {\n    flags.encode(state, bits.of(m.isInitiator))\n    c.fixed32.encode(state, m.token)\n    c.uint.encode(state, m.id)\n    c.uint.encode(state, m.seq)\n  },\n  decode (state) {\n    const [isInitiator] = bits.iterator(flags.decode(state))\n\n    return {\n      isInitiator,\n      token: c.fixed32.decode(state),\n      id: c.uint.decode(state),\n      seq: c.uint.decode(state)\n    }\n  }\n}\n\nm.unpair = {\n  preencode (state, m) {\n    flags.preencode(state)\n    c.fixed32.preencode(state, m.token)\n  },\n  encode (state, m) {\n    flags.encode(state, bits.of())\n    c.fixed32.encode(state, m.token)\n  },\n  decode (state) {\n    flags.decode(state)\n\n    return {\n      token: c.fixed32.decode(state)\n    }\n  }\n}\nmodule.exports = class BlindRelayError extends Error {\n  constructor (msg, code, fn = BlindRelayError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name () {\n    return 'BlindRelayError'\n  }\n\n  static DUPLICATE_CHANNEL (msg = 'Duplicate channel') {\n    return new BlindRelayError(msg, 'DUPLICATE_CHANNEL', BlindRelayError.DUPLICATE_CHANNEL)\n  }\n\n  static CHANNEL_CLOSED (msg = 'Channel closed') {\n    return new BlindRelayError(msg, 'CHANNEL_CLOSED', BlindRelayError.CHANNEL_CLOSED)\n  }\n\n  static CHANNEL_DESTROYED (msg = 'Channel destroyed') {\n    return new BlindRelayError(msg, 'CHANNEL_DESTROYED', BlindRelayError.CHANNEL_DESTROYED)\n  }\n\n  static ALREADY_PAIRING (msg = 'Already pairing') {\n    return new BlindRelayError(msg, 'ALREADY_PAIRING', BlindRelayError.ALREADY_PAIRING)\n  }\n\n  static PAIRING_CANCELLED (msg = 'Pairing cancelled') {\n    return new BlindRelayError(msg, 'PAIRING_CANCELLED', BlindRelayError.PAIRING_CANCELLED)\n  }\n}\n{\n  \"name\": \"blind-relay\",\n  \"version\": \"1.4.0\",\n  \"description\": \"Blind relay for UDX over Protomux channels\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"lib\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && brittle test.mjs\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/blind-relay.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/blind-relay/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/blind-relay#readme\",\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"dependencies\": {\n    \"b4a\": \"^1.6.4\",\n    \"bare-events\": \"^2.2.0\",\n    \"bits-to-bytes\": \"^1.3.0\",\n    \"compact-encoding\": \"^2.12.0\",\n    \"compact-encoding-bitfield\": \"^1.0.0\",\n    \"protomux\": \"^3.5.1\",\n    \"sodium-universal\": \"^5.0.0\",\n    \"streamx\": \"^2.15.1\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.2.1\",\n    \"hyperdht\": \"^6.6.1\",\n    \"standard\": \"^17.0.0\",\n    \"udx-native\": \"^1.6.1\"\n  }\n}\n// https://ipinfo.io/bogon\n\nconst b4a = require('b4a')\nconst c = require('compact-encoding')\nconst net = require('compact-encoding-net')\n\nmodule.exports = exports = function isBogon (ip) {\n  return isBogonIP(ensureBuffer(ip))\n}\n\nexports.isBogon = exports\n\nexports.isPrivate = function isPrivate (ip) {\n  return isPrivateIP(ensureBuffer(ip))\n}\n\nexports.isReserved = function isReserved (ip) {\n  return isReservedIP(ensureBuffer(ip))\n}\n\nfunction isBogonIP (ip) {\n  return isPrivateIP(ip) || isReservedIP(ip)\n}\n\nfunction isPrivateIP (ip) {\n  return ip.byteLength === 4 ? isPrivateIPv4(ip) : false // IPv6 has no private IPs\n}\n\nfunction isPrivateIPv4 (ip) {\n  return (\n    // 10.0.0.0/8  Private-use networks\n    (ip[0] === 10) ||\n    // 100.64.0.0/10 Carrier-grade NAT\n    (ip[0] === 100 && ip[1] >= 64 && ip[1] <= 127) ||\n    // 127.0.0.0/8 Loopback + Name collision occurrence (127.0.53.53)\n    (ip[0] === 127) ||\n    // 169.254.0.0/16  Link local\n    (ip[0] === 169 && ip[1] === 254) ||\n    // 172.16.0.0/12 Private-use networks\n    (ip[0] === 172 && ip[1] >= 16 && ip[1] <= 31) ||\n    // 192.168.0.0/16  Private-use networks\n    (ip[0] === 192 && ip[1] === 168)\n  )\n}\n\nfunction isReservedIP (ip) {\n  return ip.byteLength === 4 ? isReservedIPv4(ip) : isReservedIPv6(ip)\n}\n\nfunction isReservedIPv4 (ip) {\n  return (\n    // 0.0.0.0/8 \"This\" network\n    (ip[0] === 0) ||\n    // 192.0.0.0/24  IETF protocol assignments\n    (ip[0] === 192 && ip[1] === 0 && ip[2] === 0) ||\n    // 192.0.2.0/24  TEST-NET-1\n    (ip[0] === 192 && ip[1] === 0 && ip[2] === 2) ||\n    // 198.18.0.0/15 Network interconnect device benchmark testing\n    (ip[0] === 198 && ip[1] >= 18 && ip[1] <= 19) ||\n    // 198.51.100.0/24 TEST-NET-2\n    (ip[0] === 198 && ip[1] === 51 && ip[2] === 100) ||\n    // 203.0.113.0/24  TEST-NET-3\n    (ip[0] === 203 && ip[1] === 0 && ip[2] === 113) ||\n    // 224.0.0.0/4 Multicast\n    (ip[0] >= 224 && ip[0] <= 239) ||\n    // 240.0.0.0/4 Reserved for future use\n    (ip[0] >= 240) ||\n    // 255.255.255.255/32\n    (ip[0] === 255 && ip[1] === 255 && ip[2] === 255 && ip[3] === 255)\n  )\n}\n\nfunction isReservedIPv6 (ip) {\n  return (\n    // ::/128 Node-scope unicast unspecified address\n    // ::1/128 Node-scope unicast loopback address\n    (\n      ip[0] === 0 && ip[1] === 0 && ip[2] === 0 && ip[3] === 0 && ip[4] === 0 &&\n      ip[5] === 0 && ip[6] === 0 && ip[7] === 0 && ip[8] === 0 && ip[9] === 0 &&\n      ip[10] === 0 && ip[11] === 0 && ip[12] === 0 && ip[13] === 0 && ip[14] === 0 &&\n      ip[15] <= 1\n    ) ||\n    // ::ffff:0:0/96 IPv4-mapped addresses\n    // ::/96 IPv4-compatible addresses\n    (\n      ip[0] === 0 && ip[1] === 0 && ip[2] === 0 && ip[3] === 0 && ip[4] === 0 &&\n      ip[5] === 0 && ip[6] === 0 && ip[7] === 0 && ip[8] === 0 && ip[9] === 0 &&\n      (ip[10] === 0 || ip[10] === 0xff) &&\n      (ip[11] === 0 || ip[11] === 0xff)\n    ) ||\n    // 100::/64 Remotely triggered black hole addresses\n    (ip[0] === 0x01 && ip[1] === 0 && ip[2] === 0 && ip[3] === 0 && ip[4] === 0 && ip[5] === 0 && ip[6] === 0 && ip[7] === 0) ||\n    // 2001:10::/28 Overlay routable cryptographic hash identifiers (ORCHID)\n    (ip[0] === 0x20 && ip[1] === 0x01 && ip[2] === 0 && ip[3] >= 0x10 && ip[3] <= 0x1f) ||\n    // 2001:20::/28 Overlay routable cryptographic hash identifiers version 2 (ORCHIDv2)\n    (ip[0] === 0x20 && ip[1] === 0x01 && ip[2] === 0 && ip[3] >= 0x20 && ip[3] <= 0x2f) ||\n    // 2001:db8::/32 Documentation prefix\n    (ip[0] === 0x20 && ip[1] === 0x01 && ip[2] === 0x0d && ip[3] === 0xb8) ||\n    // fc00::/7 Unique local addresses (ULA)\n    (ip[0] >= 0xfc && ip[0] <= 0xfd) ||\n    // fe80::/10 Link-local unicast\n    (ip[0] === 0xfe && ip[1] >= 0x80 && ip[1] <= 0xbf) ||\n    // ff00::/8 Multicast\n    (ip[0] === 0xff)\n  )\n}\n\nconst state = c.state(0, 0, b4a.allocUnsafe(1 /* family */ + 16))\n\nfunction ensureBuffer (ip) {\n  if (b4a.isBuffer(ip)) return ip\n\n  net.ip.preencode(state, ip)\n  net.ip.encode(state, ip)\n\n  const buffer = state.buffer.subarray(1 /* family */, state.end)\n\n  state.start = 0\n  state.end = 0\n\n  return buffer\n}\n{\n  \"name\": \"bogon\",\n  \"version\": \"1.2.0\",\n  \"description\": \"Check if an IP is a bogon\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test.mjs\"\n  },\n  \"dependencies\": {\n    \"compact-encoding\": \"^2.11.0\",\n    \"compact-encoding-net\": \"^1.2.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.0.4\",\n    \"nanobench\": \"^2.1.1\",\n    \"standard\": \"^17.0.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/bogon.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/bogon/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/bogon\"\n}\nconst c = require('compact-encoding')\n\nmodule.exports = function bitfield (length) {\n  if (length > 64) throw new RangeError('Bitfield cannot be larger than 64 bits')\n\n  let byteLength\n  if (length < 8) byteLength = 1\n  else if (length <= 16) byteLength = 2\n  else if (length <= 32) byteLength = 4\n  else byteLength = 8\n\n  return {\n    preencode (state) {\n      state.end++ // Length byte, used for data when byteLength === 1\n\n      if (byteLength === 1) ;\n      else if (byteLength === 2) c.uint16.preencode(state)\n      else if (byteLength === 4) c.uint32.preencode(state)\n      else c.uint64.preencode(state)\n    },\n\n    encode (state, b) {\n      if (byteLength === 1) ;\n      else if (byteLength === 2) c.uint8.encode(state, 0xfd)\n      else if (byteLength === 4) c.uint8.encode(state, 0xfe)\n      else c.uint8.encode(state, 0xff)\n\n      if (typeof b === 'number') {\n        if (byteLength === 1) c.uint8.encode(state, b)\n        else if (byteLength === 2) c.uint16.encode(state, b)\n        else if (byteLength === 4) c.uint32.encode(state, b)\n        else c.uint64.encode(state, b)\n      } else {\n        state.buffer.set(b, state.start)\n\n        if (b.byteLength < byteLength) {\n          // Zero-fill the rest of the byte length.\n          state.buffer.fill(\n            0,\n            state.start + b.byteLength,\n            state.start + byteLength\n          )\n        }\n\n        state.start += byteLength\n      }\n    },\n\n    decode (state) {\n      const byte = state.buffer[state.start]\n\n      let byteLength\n      if (byte <= 0xfc) byteLength = 1\n      else if (byte === 0xfd) byteLength = 2\n      else if (byte === 0xfe) byteLength = 4\n      else byteLength = 8\n\n      if (byteLength > 1) state.start++ // Skip the length byte\n\n      if (state.end - state.start < byteLength) throw new Error('Out of bounds')\n\n      const b = state.buffer.subarray(state.start, (state.start += byteLength))\n\n      return length <= 8 ? b.subarray(0, 1) : b\n    }\n  }\n}\n{\n  \"name\": \"compact-encoding-bitfield\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Compact codec for bitfields\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && brittle test.mjs\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/compact-encoding/compact-encoding-bitfield.git\"\n  },\n  \"author\": \"Kasper Isager Dalsgar <kasper@funktionel.co>\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/compact-encoding/compact-encoding-bitfield/issues\"\n  },\n  \"homepage\": \"https://github.com/compact-encoding/compact-encoding-bitfield#readme\",\n  \"dependencies\": {\n    \"compact-encoding\": \"^2.4.1\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^1.3.5\",\n    \"standard\": \"^16.0.3\"\n  },\n  \"standard\": {\n    \"ignore\": [\n      \"__snapshots__/**\"\n    ]\n  }\n}\nconst c = require('compact-encoding')\n\nconst port = c.uint16\n\nconst address = (host, family) => {\n  return {\n    preencode (state, m) {\n      host.preencode(state, m.host)\n      port.preencode(state, m.port)\n    },\n    encode (state, m) {\n      host.encode(state, m.host)\n      port.encode(state, m.port)\n    },\n    decode (state) {\n      return {\n        host: host.decode(state),\n        family,\n        port: port.decode(state)\n      }\n    }\n  }\n}\n\nconst ipv4 = {\n  preencode (state) {\n    state.end += 4\n  },\n  encode (state, string) {\n    const start = state.start\n    const end = start + 4\n\n    let i = 0\n\n    while (i < string.length) {\n      let n = 0\n      let c\n\n      while (i < string.length && (c = string.charCodeAt(i++)) !== /* . */ 0x2e) {\n        n = n * 10 + (c - /* 0 */ 0x30)\n      }\n\n      state.buffer[state.start++] = n\n    }\n\n    state.start = end\n  },\n  decode (state) {\n    if (state.end - state.start < 4) throw new Error('Out of bounds')\n    return (\n      state.buffer[state.start++] + '.' +\n      state.buffer[state.start++] + '.' +\n      state.buffer[state.start++] + '.' +\n      state.buffer[state.start++]\n    )\n  }\n}\n\nconst ipv4Address = address(ipv4, 4)\n\nconst ipv6 = {\n  preencode (state) {\n    state.end += 16\n  },\n  encode (state, string) {\n    const start = state.start\n    const end = start + 16\n\n    let i = 0\n    let split = null\n\n    while (i < string.length) {\n      let n = 0\n      let c\n\n      while (i < string.length && (c = string.charCodeAt(i++)) !== /* : */ 0x3a) {\n        if (c >= 0x30 && c <= 0x39) n = n * 0x10 + (c - /* 0 */ 0x30)\n        else if (c >= 0x41 && c <= 0x46) n = n * 0x10 + (c - /* A */ 0x41 + 10)\n        else if (c >= 0x61 && c <= 0x66) n = n * 0x10 + (c - /* a */ 0x61 + 10)\n      }\n\n      state.buffer[state.start++] = n >>> 8\n      state.buffer[state.start++] = n\n\n      if (i < string.length && string.charCodeAt(i) === /* : */ 0x3a) {\n        i++\n        split = state.start\n      }\n    }\n\n    if (split !== null) {\n      const offset = end - state.start\n      state.buffer\n        .copyWithin(split + offset, split)\n        .fill(0, split, split + offset)\n    }\n\n    state.start = end\n  },\n  decode (state) {\n    if (state.end - state.start < 16) throw new Error('Out of bounds')\n    return (\n      (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ':' +\n      (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ':' +\n      (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ':' +\n      (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ':' +\n      (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ':' +\n      (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ':' +\n      (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16) + ':' +\n      (state.buffer[state.start++] * 256 + state.buffer[state.start++]).toString(16)\n    )\n  }\n}\n\nconst ipv6Address = address(ipv6, 6)\n\nconst ip = {\n  preencode (state, string) {\n    const family = string.includes(':') ? 6 : 4\n    c.uint8.preencode(state, family)\n    if (family === 4) ipv4.preencode(state)\n    else ipv6.preencode(state)\n  },\n  encode (state, string) {\n    const family = string.includes(':') ? 6 : 4\n    c.uint8.encode(state, family)\n    if (family === 4) ipv4.encode(state, string)\n    else ipv6.encode(state, string)\n  },\n  decode (state) {\n    const family = c.uint8.decode(state)\n    if (family === 4) return ipv4.decode(state)\n    else return ipv6.decode(state)\n  }\n}\n\nconst ipAddress = {\n  preencode (state, m) {\n    ip.preencode(state, m.host)\n    port.preencode(state, m.port)\n  },\n  encode (state, m) {\n    ip.encode(state, m.host)\n    port.encode(state, m.port)\n  },\n  decode (state) {\n    const family = c.uint8.decode(state)\n    return {\n      host: family === 4 ? ipv4.decode(state) : ipv6.decode(state),\n      family,\n      port: port.decode(state)\n    }\n  }\n}\n\nmodule.exports = {\n  port,\n  ipv4,\n  ipv4Address,\n  ipv6,\n  ipv6Address,\n  ip,\n  ipAddress\n}\n{\n  \"name\": \"compact-encoding-net\",\n  \"version\": \"1.2.0\",\n  \"description\": \"Compact codecs for net types\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test.mjs\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/compact-encoding/compact-encoding-net.git\"\n  },\n  \"author\": \"Kasper Isager Dalsgar <kasper@funktionel.co>\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/compact-encoding/compact-encoding-net/issues\"\n  },\n  \"homepage\": \"https://github.com/compact-encoding/compact-encoding-net#readme\",\n  \"dependencies\": {\n    \"compact-encoding\": \"^2.4.1\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^1.3.5\",\n    \"nanobench\": \"^2.1.1\",\n    \"standard\": \"^16.0.3\"\n  }\n}\nconst LE = (exports.LE =\n  new Uint8Array(new Uint16Array([0xff]).buffer)[0] === 0xff)\n\nexports.BE = !LE\nconst b4a = require('b4a')\n\nconst { BE } = require('./endian')\n\nexports.state = function (start = 0, end = 0, buffer = null) {\n  return { start, end, buffer }\n}\n\nconst raw = (exports.raw = require('./raw'))\n\nconst uint = (exports.uint = {\n  preencode(state, n) {\n    state.end += n <= 0xfc ? 1 : n <= 0xffff ? 3 : n <= 0xffffffff ? 5 : 9\n  },\n  encode(state, n) {\n    if (n <= 0xfc) uint8.encode(state, n)\n    else if (n <= 0xffff) {\n      state.buffer[state.start++] = 0xfd\n      uint16.encode(state, n)\n    } else if (n <= 0xffffffff) {\n      state.buffer[state.start++] = 0xfe\n      uint32.encode(state, n)\n    } else {\n      state.buffer[state.start++] = 0xff\n      uint64.encode(state, n)\n    }\n  },\n  decode(state) {\n    const a = uint8.decode(state)\n    if (a <= 0xfc) return a\n    if (a === 0xfd) return uint16.decode(state)\n    if (a === 0xfe) return uint32.decode(state)\n    return uint64.decode(state)\n  }\n})\n\nconst uint8 = (exports.uint8 = {\n  preencode(state, n) {\n    state.end += 1\n  },\n  encode(state, n) {\n    validateUint(n)\n    state.buffer[state.start++] = n\n  },\n  decode(state) {\n    if (state.start >= state.end) throw new Error('Out of bounds')\n    return state.buffer[state.start++]\n  }\n})\n\nconst uint16 = (exports.uint16 = {\n  preencode(state, n) {\n    state.end += 2\n  },\n  encode(state, n) {\n    validateUint(n)\n    state.buffer[state.start++] = n\n    state.buffer[state.start++] = n >>> 8\n  },\n  decode(state) {\n    if (state.end - state.start < 2) throw new Error('Out of bounds')\n    return state.buffer[state.start++] + state.buffer[state.start++] * 0x100\n  }\n})\n\nconst uint24 = (exports.uint24 = {\n  preencode(state, n) {\n    state.end += 3\n  },\n  encode(state, n) {\n    validateUint(n)\n    state.buffer[state.start++] = n\n    state.buffer[state.start++] = n >>> 8\n    state.buffer[state.start++] = n >>> 16\n  },\n  decode(state) {\n    if (state.end - state.start < 3) throw new Error('Out of bounds')\n    return (\n      state.buffer[state.start++] +\n      state.buffer[state.start++] * 0x100 +\n      state.buffer[state.start++] * 0x10000\n    )\n  }\n})\n\nconst uint32 = (exports.uint32 = {\n  preencode(state, n) {\n    state.end += 4\n  },\n  encode(state, n) {\n    validateUint(n)\n    state.buffer[state.start++] = n\n    state.buffer[state.start++] = n >>> 8\n    state.buffer[state.start++] = n >>> 16\n    state.buffer[state.start++] = n >>> 24\n  },\n  decode(state) {\n    if (state.end - state.start < 4) throw new Error('Out of bounds')\n    return (\n      state.buffer[state.start++] +\n      state.buffer[state.start++] * 0x100 +\n      state.buffer[state.start++] * 0x10000 +\n      state.buffer[state.start++] * 0x1000000\n    )\n  }\n})\n\nconst uint40 = (exports.uint40 = {\n  preencode(state, n) {\n    state.end += 5\n  },\n  encode(state, n) {\n    validateUint(n)\n    const r = Math.floor(n / 0x100)\n    uint8.encode(state, n)\n    uint32.encode(state, r)\n  },\n  decode(state) {\n    if (state.end - state.start < 5) throw new Error('Out of bounds')\n    return uint8.decode(state) + 0x100 * uint32.decode(state)\n  }\n})\n\nconst uint48 = (exports.uint48 = {\n  preencode(state, n) {\n    state.end += 6\n  },\n  encode(state, n) {\n    validateUint(n)\n    const r = Math.floor(n / 0x10000)\n    uint16.encode(state, n)\n    uint32.encode(state, r)\n  },\n  decode(state) {\n    if (state.end - state.start < 6) throw new Error('Out of bounds')\n    return uint16.decode(state) + 0x10000 * uint32.decode(state)\n  }\n})\n\nconst uint56 = (exports.uint56 = {\n  preencode(state, n) {\n    state.end += 7\n  },\n  encode(state, n) {\n    validateUint(n)\n    const r = Math.floor(n / 0x1000000)\n    uint24.encode(state, n)\n    uint32.encode(state, r)\n  },\n  decode(state) {\n    if (state.end - state.start < 7) throw new Error('Out of bounds')\n    return uint24.decode(state) + 0x1000000 * uint32.decode(state)\n  }\n})\n\nconst uint64 = (exports.uint64 = {\n  preencode(state, n) {\n    state.end += 8\n  },\n  encode(state, n) {\n    validateUint(n)\n    const r = Math.floor(n / 0x100000000)\n    uint32.encode(state, n)\n    uint32.encode(state, r)\n  },\n  decode(state) {\n    if (state.end - state.start < 8) throw new Error('Out of bounds')\n    return uint32.decode(state) + 0x100000000 * uint32.decode(state)\n  }\n})\n\nconst int = (exports.int = zigZagInt(uint))\nexports.int8 = zigZagInt(uint8)\nexports.int16 = zigZagInt(uint16)\nexports.int24 = zigZagInt(uint24)\nexports.int32 = zigZagInt(uint32)\nexports.int40 = zigZagInt(uint40)\nexports.int48 = zigZagInt(uint48)\nexports.int56 = zigZagInt(uint56)\nexports.int64 = zigZagInt(uint64)\n\nconst biguint64 = (exports.biguint64 = {\n  preencode(state, n) {\n    state.end += 8\n  },\n  encode(state, n) {\n    const view = new DataView(\n      state.buffer.buffer,\n      state.start + state.buffer.byteOffset,\n      8\n    )\n    view.setBigUint64(0, n, true) // little endian\n    state.start += 8\n  },\n  decode(state) {\n    if (state.end - state.start < 8) throw new Error('Out of bounds')\n    const view = new DataView(\n      state.buffer.buffer,\n      state.start + state.buffer.byteOffset,\n      8\n    )\n    const n = view.getBigUint64(0, true) // little endian\n    state.start += 8\n    return n\n  }\n})\n\nexports.bigint64 = zigZagBigInt(biguint64)\n\nconst biguint = (exports.biguint = {\n  preencode(state, n) {\n    let len = 0\n    for (let m = n; m; m = m >> 64n) len++\n    uint.preencode(state, len)\n    state.end += 8 * len\n  },\n  encode(state, n) {\n    let len = 0\n    for (let m = n; m; m = m >> 64n) len++\n    uint.encode(state, len)\n    const view = new DataView(\n      state.buffer.buffer,\n      state.start + state.buffer.byteOffset,\n      8 * len\n    )\n    for (let m = n, i = 0; m; m = m >> 64n, i += 8) {\n      view.setBigUint64(i, BigInt.asUintN(64, m), true) // little endian\n    }\n    state.start += 8 * len\n  },\n  decode(state) {\n    const len = uint.decode(state)\n    if (state.end - state.start < 8 * len) throw new Error('Out of bounds')\n    const view = new DataView(\n      state.buffer.buffer,\n      state.start + state.buffer.byteOffset,\n      8 * len\n    )\n    let n = 0n\n    for (let i = len - 1; i >= 0; i--)\n      n = (n << 64n) + view.getBigUint64(i * 8, true) // little endian\n    state.start += 8 * len\n    return n\n  }\n})\n\nexports.bigint = zigZagBigInt(biguint)\n\nexports.lexint = require('./lexint')\n\nexports.float32 = {\n  preencode(state, n) {\n    state.end += 4\n  },\n  encode(state, n) {\n    const view = new DataView(\n      state.buffer.buffer,\n      state.start + state.buffer.byteOffset,\n      4\n    )\n    view.setFloat32(0, n, true) // little endian\n    state.start += 4\n  },\n  decode(state) {\n    if (state.end - state.start < 4) throw new Error('Out of bounds')\n    const view = new DataView(\n      state.buffer.buffer,\n      state.start + state.buffer.byteOffset,\n      4\n    )\n    const float = view.getFloat32(0, true) // little endian\n    state.start += 4\n    return float\n  }\n}\n\nexports.float64 = {\n  preencode(state, n) {\n    state.end += 8\n  },\n  encode(state, n) {\n    const view = new DataView(\n      state.buffer.buffer,\n      state.start + state.buffer.byteOffset,\n      8\n    )\n    view.setFloat64(0, n, true) // little endian\n    state.start += 8\n  },\n  decode(state) {\n    if (state.end - state.start < 8) throw new Error('Out of bounds')\n    const view = new DataView(\n      state.buffer.buffer,\n      state.start + state.buffer.byteOffset,\n      8\n    )\n    const float = view.getFloat64(0, true) // little endian\n    state.start += 8\n    return float\n  }\n}\n\nconst buffer = (exports.buffer = {\n  preencode(state, b) {\n    if (b) uint8array.preencode(state, b)\n    else state.end++\n  },\n  encode(state, b) {\n    if (b) uint8array.encode(state, b)\n    else state.buffer[state.start++] = 0\n  },\n  decode(state) {\n    const len = uint.decode(state)\n    if (len === 0) return null\n    if (state.end - state.start < len) throw new Error('Out of bounds')\n    return state.buffer.subarray(state.start, (state.start += len))\n  }\n})\n\nexports.binary = {\n  ...buffer,\n  preencode(state, b) {\n    if (typeof b === 'string') utf8.preencode(state, b)\n    else buffer.preencode(state, b)\n  },\n  encode(state, b) {\n    if (typeof b === 'string') utf8.encode(state, b)\n    else buffer.encode(state, b)\n  }\n}\n\nexports.arraybuffer = {\n  preencode(state, b) {\n    uint.preencode(state, b.byteLength)\n    state.end += b.byteLength\n  },\n  encode(state, b) {\n    uint.encode(state, b.byteLength)\n\n    const view = new Uint8Array(b)\n\n    state.buffer.set(view, state.start)\n    state.start += b.byteLength\n  },\n  decode(state) {\n    const len = uint.decode(state)\n\n    const b = new ArrayBuffer(len)\n    const view = new Uint8Array(b)\n\n    view.set(state.buffer.subarray(state.start, (state.start += len)))\n\n    return b\n  }\n}\n\nfunction typedarray(TypedArray, swap) {\n  const n = TypedArray.BYTES_PER_ELEMENT\n\n  return {\n    preencode(state, b) {\n      uint.preencode(state, b.length)\n      state.end += b.byteLength\n    },\n    encode(state, b) {\n      uint.encode(state, b.length)\n\n      const view = new Uint8Array(b.buffer, b.byteOffset, b.byteLength)\n\n      if (BE && swap) swap(view)\n\n      state.buffer.set(view, state.start)\n      state.start += b.byteLength\n    },\n    decode(state) {\n      const len = uint.decode(state)\n\n      let b = state.buffer.subarray(state.start, (state.start += len * n))\n      if (b.byteLength !== len * n) throw new Error('Out of bounds')\n      if (b.byteOffset % n !== 0) b = new Uint8Array(b)\n\n      if (BE && swap) swap(b)\n\n      return new TypedArray(b.buffer, b.byteOffset, b.byteLength / n)\n    }\n  }\n}\n\nconst uint8array = (exports.uint8array = typedarray(Uint8Array))\nexports.uint16array = typedarray(Uint16Array, b4a.swap16)\nexports.uint32array = typedarray(Uint32Array, b4a.swap32)\n\nexports.int8array = typedarray(Int8Array)\nexports.int16array = typedarray(Int16Array, b4a.swap16)\nexports.int32array = typedarray(Int32Array, b4a.swap32)\n\nexports.biguint64array = typedarray(BigUint64Array, b4a.swap64)\nexports.bigint64array = typedarray(BigInt64Array, b4a.swap64)\n\nexports.float32array = typedarray(Float32Array, b4a.swap32)\nexports.float64array = typedarray(Float64Array, b4a.swap64)\n\nfunction string(encoding) {\n  return {\n    preencode(state, s) {\n      const len = b4a.byteLength(s, encoding)\n      uint.preencode(state, len)\n      state.end += len\n    },\n    encode(state, s) {\n      const len = b4a.byteLength(s, encoding)\n      uint.encode(state, len)\n      b4a.write(state.buffer, s, state.start, encoding)\n      state.start += len\n    },\n    decode(state) {\n      const len = uint.decode(state)\n      if (state.end - state.start < len) throw new Error('Out of bounds')\n      return b4a.toString(\n        state.buffer,\n        encoding,\n        state.start,\n        (state.start += len)\n      )\n    },\n    fixed(n) {\n      return {\n        preencode(state) {\n          state.end += n\n        },\n        encode(state, s) {\n          b4a.write(state.buffer, s, state.start, n, encoding)\n          state.start += n\n        },\n        decode(state) {\n          if (state.end - state.start < n) throw new Error('Out of bounds')\n          return b4a.toString(\n            state.buffer,\n            encoding,\n            state.start,\n            (state.start += n)\n          )\n        }\n      }\n    }\n  }\n}\n\nconst utf8 = (exports.string = exports.utf8 = string('utf-8'))\nexports.ascii = string('ascii')\nexports.hex = string('hex')\nexports.base64 = string('base64')\nexports.ucs2 = exports.utf16le = string('utf16le')\n\nexports.bool = {\n  preencode(state, b) {\n    state.end++\n  },\n  encode(state, b) {\n    state.buffer[state.start++] = b ? 1 : 0\n  },\n  decode(state) {\n    if (state.start >= state.end) throw Error('Out of bounds')\n    return state.buffer[state.start++] === 1\n  }\n}\n\nconst fixed = (exports.fixed = function fixed(n) {\n  return {\n    preencode(state, s) {\n      if (s.byteLength !== n) throw new Error('Incorrect buffer size')\n      state.end += n\n    },\n    encode(state, s) {\n      state.buffer.set(s, state.start)\n      state.start += n\n    },\n    decode(state) {\n      if (state.end - state.start < n) throw new Error('Out of bounds')\n      return state.buffer.subarray(state.start, (state.start += n))\n    }\n  }\n})\n\nexports.fixed32 = fixed(32)\nexports.fixed64 = fixed(64)\n\nexports.array = function array(enc) {\n  return {\n    preencode(state, list) {\n      uint.preencode(state, list.length)\n      for (let i = 0; i < list.length; i++) enc.preencode(state, list[i])\n    },\n    encode(state, list) {\n      uint.encode(state, list.length)\n      for (let i = 0; i < list.length; i++) enc.encode(state, list[i])\n    },\n    decode(state) {\n      const len = uint.decode(state)\n      if (len > 0x100000) throw new Error('Array is too big')\n      const arr = new Array(len)\n      for (let i = 0; i < len; i++) arr[i] = enc.decode(state)\n      return arr\n    }\n  }\n}\n\nexports.frame = function frame(enc) {\n  const dummy = exports.state()\n\n  return {\n    preencode(state, m) {\n      const end = state.end\n      enc.preencode(state, m)\n      uint.preencode(state, state.end - end)\n    },\n    encode(state, m) {\n      dummy.end = 0\n      enc.preencode(dummy, m)\n      uint.encode(state, dummy.end)\n      enc.encode(state, m)\n    },\n    decode(state) {\n      const end = state.end\n      const len = uint.decode(state)\n      state.end = state.start + len\n      const m = enc.decode(state)\n      state.start = state.end\n      state.end = end\n      return m\n    }\n  }\n}\n\nexports.date = {\n  preencode(state, d) {\n    int.preencode(state, d.getTime())\n  },\n  encode(state, d) {\n    int.encode(state, d.getTime())\n  },\n  decode(state, d) {\n    return new Date(int.decode(state))\n  }\n}\n\nexports.json = {\n  preencode(state, v) {\n    utf8.preencode(state, JSON.stringify(v))\n  },\n  encode(state, v) {\n    utf8.encode(state, JSON.stringify(v))\n  },\n  decode(state) {\n    return JSON.parse(utf8.decode(state))\n  }\n}\n\nexports.ndjson = {\n  preencode(state, v) {\n    utf8.preencode(state, JSON.stringify(v) + '\\n')\n  },\n  encode(state, v) {\n    utf8.encode(state, JSON.stringify(v) + '\\n')\n  },\n  decode(state) {\n    return JSON.parse(utf8.decode(state))\n  }\n}\n\n// simple helper for when you want to just express nothing\nexports.none = {\n  preencode(state, n) {\n    // do nothing\n  },\n  encode(state, n) {\n    // do nothing\n  },\n  decode(state) {\n    return null\n  }\n}\n\n// \"any\" encoders here for helping just structure any object without schematising it\n\nconst anyArray = {\n  preencode(state, arr) {\n    uint.preencode(state, arr.length)\n    for (let i = 0; i < arr.length; i++) {\n      any.preencode(state, arr[i])\n    }\n  },\n  encode(state, arr) {\n    uint.encode(state, arr.length)\n    for (let i = 0; i < arr.length; i++) {\n      any.encode(state, arr[i])\n    }\n  },\n  decode(state) {\n    const arr = []\n    let len = uint.decode(state)\n    while (len-- > 0) {\n      arr.push(any.decode(state))\n    }\n    return arr\n  }\n}\n\nconst anyObject = {\n  preencode(state, o) {\n    const keys = Object.keys(o)\n    uint.preencode(state, keys.length)\n    for (const key of keys) {\n      utf8.preencode(state, key)\n      any.preencode(state, o[key])\n    }\n  },\n  encode(state, o) {\n    const keys = Object.keys(o)\n    uint.encode(state, keys.length)\n    for (const key of keys) {\n      utf8.encode(state, key)\n      any.encode(state, o[key])\n    }\n  },\n  decode(state) {\n    let len = uint.decode(state)\n    const o = {}\n    while (len-- > 0) {\n      const key = utf8.decode(state)\n      o[key] = any.decode(state)\n    }\n    return o\n  }\n}\n\nconst anyTypes = [\n  exports.none,\n  exports.bool,\n  exports.string,\n  exports.buffer,\n  exports.uint,\n  exports.int,\n  exports.float64,\n  anyArray,\n  anyObject,\n  exports.date\n]\n\nconst any = (exports.any = {\n  preencode(state, o) {\n    const t = getType(o)\n    uint.preencode(state, t)\n    anyTypes[t].preencode(state, o)\n  },\n  encode(state, o) {\n    const t = getType(o)\n    uint.encode(state, t)\n    anyTypes[t].encode(state, o)\n  },\n  decode(state) {\n    const t = uint.decode(state)\n    if (t >= anyTypes.length) throw new Error('Unknown type: ' + t)\n    return anyTypes[t].decode(state)\n  }\n})\n\nconst port = (exports.port = uint16)\n\nconst address = (host, family) => {\n  return {\n    preencode(state, m) {\n      host.preencode(state, m.host)\n      port.preencode(state, m.port)\n    },\n    encode(state, m) {\n      host.encode(state, m.host)\n      port.encode(state, m.port)\n    },\n    decode(state) {\n      return {\n        host: host.decode(state),\n        family,\n        port: port.decode(state)\n      }\n    }\n  }\n}\n\nconst ipv4 = (exports.ipv4 = {\n  preencode(state) {\n    state.end += 4\n  },\n  encode(state, string) {\n    const start = state.start\n    const end = start + 4\n\n    let i = 0\n\n    while (i < string.length) {\n      let n = 0\n      let c\n\n      while (\n        i < string.length &&\n        (c = string.charCodeAt(i++)) !== /* . */ 0x2e\n      ) {\n        n = n * 10 + (c - /* 0 */ 0x30)\n      }\n\n      state.buffer[state.start++] = n\n    }\n\n    state.start = end\n  },\n  decode(state) {\n    if (state.end - state.start < 4) throw new Error('Out of bounds')\n    return (\n      state.buffer[state.start++] +\n      '.' +\n      state.buffer[state.start++] +\n      '.' +\n      state.buffer[state.start++] +\n      '.' +\n      state.buffer[state.start++]\n    )\n  }\n})\n\nexports.ipv4Address = address(ipv4, 4)\n\nconst ipv6 = (exports.ipv6 = {\n  preencode(state) {\n    state.end += 16\n  },\n  encode(state, string) {\n    const start = state.start\n    const end = start + 16\n\n    let i = 0\n    let split = null\n\n    while (i < string.length) {\n      let n = 0\n      let c\n\n      while (\n        i < string.length &&\n        (c = string.charCodeAt(i++)) !== /* : */ 0x3a\n      ) {\n        if (c >= 0x30 && c <= 0x39) n = n * 0x10 + (c - /* 0 */ 0x30)\n        else if (c >= 0x41 && c <= 0x46) n = n * 0x10 + (c - /* A */ 0x41 + 10)\n        else if (c >= 0x61 && c <= 0x66) n = n * 0x10 + (c - /* a */ 0x61 + 10)\n      }\n\n      state.buffer[state.start++] = n >>> 8\n      state.buffer[state.start++] = n\n\n      if (i < string.length && string.charCodeAt(i) === /* : */ 0x3a) {\n        i++\n        split = state.start\n      }\n    }\n\n    if (split !== null) {\n      const offset = end - state.start\n      state.buffer\n        .copyWithin(split + offset, split)\n        .fill(0, split, split + offset)\n    }\n\n    state.start = end\n  },\n  decode(state) {\n    if (state.end - state.start < 16) throw new Error('Out of bounds')\n    return (\n      (\n        state.buffer[state.start++] * 256 +\n        state.buffer[state.start++]\n      ).toString(16) +\n      ':' +\n      (\n        state.buffer[state.start++] * 256 +\n        state.buffer[state.start++]\n      ).toString(16) +\n      ':' +\n      (\n        state.buffer[state.start++] * 256 +\n        state.buffer[state.start++]\n      ).toString(16) +\n      ':' +\n      (\n        state.buffer[state.start++] * 256 +\n        state.buffer[state.start++]\n      ).toString(16) +\n      ':' +\n      (\n        state.buffer[state.start++] * 256 +\n        state.buffer[state.start++]\n      ).toString(16) +\n      ':' +\n      (\n        state.buffer[state.start++] * 256 +\n        state.buffer[state.start++]\n      ).toString(16) +\n      ':' +\n      (\n        state.buffer[state.start++] * 256 +\n        state.buffer[state.start++]\n      ).toString(16) +\n      ':' +\n      (\n        state.buffer[state.start++] * 256 +\n        state.buffer[state.start++]\n      ).toString(16)\n    )\n  }\n})\n\nexports.ipv6Address = address(ipv6, 6)\n\nconst ip = (exports.ip = {\n  preencode(state, string) {\n    const family = string.includes(':') ? 6 : 4\n    uint8.preencode(state, family)\n    if (family === 4) ipv4.preencode(state)\n    else ipv6.preencode(state)\n  },\n  encode(state, string) {\n    const family = string.includes(':') ? 6 : 4\n    uint8.encode(state, family)\n    if (family === 4) ipv4.encode(state, string)\n    else ipv6.encode(state, string)\n  },\n  decode(state) {\n    const family = uint8.decode(state)\n    if (family === 4) return ipv4.decode(state)\n    else return ipv6.decode(state)\n  }\n})\n\nexports.ipAddress = {\n  preencode(state, m) {\n    ip.preencode(state, m.host)\n    port.preencode(state, m.port)\n  },\n  encode(state, m) {\n    ip.encode(state, m.host)\n    port.encode(state, m.port)\n  },\n  decode(state) {\n    const family = uint8.decode(state)\n    return {\n      host: family === 4 ? ipv4.decode(state) : ipv6.decode(state),\n      family,\n      port: port.decode(state)\n    }\n  }\n}\n\nfunction getType(o) {\n  if (o === null || o === undefined) return 0\n  if (typeof o === 'boolean') return 1\n  if (typeof o === 'string') return 2\n  if (b4a.isBuffer(o)) return 3\n  if (typeof o === 'number') {\n    if (Number.isInteger(o)) return o >= 0 ? 4 : 5\n    return 6\n  }\n  if (Array.isArray(o)) return 7\n  if (o instanceof Date) return 9\n  if (typeof o === 'object') return 8\n\n  throw new Error('Unsupported type for ' + o)\n}\n\nexports.from = function from(enc) {\n  if (typeof enc === 'string') return fromNamed(enc)\n  if (enc.preencode) return enc\n  if (enc.encodingLength) return fromAbstractEncoder(enc)\n  return fromCodec(enc)\n}\n\nfunction fromNamed(enc) {\n  switch (enc) {\n    case 'ascii':\n      return raw.ascii\n    case 'utf-8':\n    case 'utf8':\n      return raw.utf8\n    case 'hex':\n      return raw.hex\n    case 'base64':\n      return raw.base64\n    case 'utf16-le':\n    case 'utf16le':\n    case 'ucs-2':\n    case 'ucs2':\n      return raw.ucs2\n    case 'ndjson':\n      return raw.ndjson\n    case 'json':\n      return raw.json\n    case 'binary':\n    default:\n      return raw.binary\n  }\n}\n\nfunction fromCodec(enc) {\n  let tmpM = null\n  let tmpBuf = null\n\n  return {\n    preencode(state, m) {\n      tmpM = m\n      tmpBuf = enc.encode(m)\n      state.end += tmpBuf.byteLength\n    },\n    encode(state, m) {\n      raw.encode(state, m === tmpM ? tmpBuf : enc.encode(m))\n      tmpM = tmpBuf = null\n    },\n    decode(state) {\n      return enc.decode(raw.decode(state))\n    }\n  }\n}\n\nfunction fromAbstractEncoder(enc) {\n  return {\n    preencode(state, m) {\n      state.end += enc.encodingLength(m)\n    },\n    encode(state, m) {\n      enc.encode(m, state.buffer, state.start)\n      state.start += enc.encode.bytes\n    },\n    decode(state) {\n      const m = enc.decode(state.buffer, state.start, state.end)\n      state.start += enc.decode.bytes\n      return m\n    }\n  }\n}\n\nexports.encode = function encode(enc, m) {\n  const state = exports.state()\n  enc.preencode(state, m)\n  state.buffer = b4a.allocUnsafe(state.end)\n  enc.encode(state, m)\n  return state.buffer\n}\n\nexports.decode = function decode(enc, buffer) {\n  return enc.decode(exports.state(0, buffer.byteLength, buffer))\n}\n\nfunction zigZagInt(enc) {\n  return {\n    preencode(state, n) {\n      enc.preencode(state, zigZagEncodeInt(n))\n    },\n    encode(state, n) {\n      enc.encode(state, zigZagEncodeInt(n))\n    },\n    decode(state) {\n      return zigZagDecodeInt(enc.decode(state))\n    }\n  }\n}\n\nfunction zigZagDecodeInt(n) {\n  return n === 0 ? n : (n & 1) === 0 ? n / 2 : -(n + 1) / 2\n}\n\nfunction zigZagEncodeInt(n) {\n  // 0, -1, 1, -2, 2, ...\n  return n < 0 ? 2 * -n - 1 : n === 0 ? 0 : 2 * n\n}\n\nfunction zigZagBigInt(enc) {\n  return {\n    preencode(state, n) {\n      enc.preencode(state, zigZagEncodeBigInt(n))\n    },\n    encode(state, n) {\n      enc.encode(state, zigZagEncodeBigInt(n))\n    },\n    decode(state) {\n      return zigZagDecodeBigInt(enc.decode(state))\n    }\n  }\n}\n\nfunction zigZagDecodeBigInt(n) {\n  return n === 0n ? n : (n & 1n) === 0n ? n / 2n : -(n + 1n) / 2n\n}\n\nfunction zigZagEncodeBigInt(n) {\n  // 0, -1, 1, -2, 2, ...\n  return n < 0n ? 2n * -n - 1n : n === 0n ? 0n : 2n * n\n}\n\nfunction validateUint(n) {\n  if (n >= 0 === false /* Handles NaN as well */)\n    throw new Error('uint must be positive')\n}\nmodule.exports = {\n  preencode,\n  encode,\n  decode\n}\n\nfunction preencode(state, num) {\n  if (num < 251) {\n    state.end++\n  } else if (num < 256) {\n    state.end += 2\n  } else if (num < 0x10000) {\n    state.end += 3\n  } else if (num < 0x1000000) {\n    state.end += 4\n  } else if (num < 0x100000000) {\n    state.end += 5\n  } else {\n    state.end++\n    const exp = Math.floor(Math.log(num) / Math.log(2)) - 32\n    preencode(state, exp)\n    state.end += 6\n  }\n}\n\nfunction encode(state, num) {\n  const max = 251\n  const x = num - max\n\n  if (num < max) {\n    state.buffer[state.start++] = num\n  } else if (num < 256) {\n    state.buffer[state.start++] = max\n    state.buffer[state.start++] = x\n  } else if (num < 0x10000) {\n    state.buffer[state.start++] = max + 1\n    state.buffer[state.start++] = (x >> 8) & 0xff\n    state.buffer[state.start++] = x & 0xff\n  } else if (num < 0x1000000) {\n    state.buffer[state.start++] = max + 2\n    state.buffer[state.start++] = x >> 16\n    state.buffer[state.start++] = (x >> 8) & 0xff\n    state.buffer[state.start++] = x & 0xff\n  } else if (num < 0x100000000) {\n    state.buffer[state.start++] = max + 3\n    state.buffer[state.start++] = x >> 24\n    state.buffer[state.start++] = (x >> 16) & 0xff\n    state.buffer[state.start++] = (x >> 8) & 0xff\n    state.buffer[state.start++] = x & 0xff\n  } else {\n    // need to use Math here as bitwise ops are 32 bit\n    const exp = Math.floor(Math.log(x) / Math.log(2)) - 32\n    state.buffer[state.start++] = 0xff\n\n    encode(state, exp)\n    const rem = x / Math.pow(2, exp - 11)\n\n    for (let i = 5; i >= 0; i--) {\n      state.buffer[state.start++] = (rem / Math.pow(2, 8 * i)) & 0xff\n    }\n  }\n}\n\nfunction decode(state) {\n  const max = 251\n\n  if (state.end - state.start < 1) throw new Error('Out of bounds')\n\n  const flag = state.buffer[state.start++]\n\n  if (flag < max) return flag\n\n  if (state.end - state.start < flag - max + 1) {\n    throw new Error('Out of bounds.')\n  }\n\n  if (flag < 252) {\n    return state.buffer[state.start++] + max\n  }\n\n  if (flag < 253) {\n    return (\n      (state.buffer[state.start++] << 8) + state.buffer[state.start++] + max\n    )\n  }\n\n  if (flag < 254) {\n    return (\n      (state.buffer[state.start++] << 16) +\n      (state.buffer[state.start++] << 8) +\n      state.buffer[state.start++] +\n      max\n    )\n  }\n\n  // << 24 result may be interpreted as negative\n  if (flag < 255) {\n    return (\n      state.buffer[state.start++] * 0x1000000 +\n      (state.buffer[state.start++] << 16) +\n      (state.buffer[state.start++] << 8) +\n      state.buffer[state.start++] +\n      max\n    )\n  }\n\n  const exp = decode(state)\n\n  if (state.end - state.start < 6) throw new Error('Out of bounds')\n\n  let rem = 0\n  for (let i = 5; i >= 0; i--) {\n    rem += state.buffer[state.start++] * Math.pow(2, 8 * i)\n  }\n\n  return rem * Math.pow(2, exp - 11) + max\n}\n{\n  \"name\": \"compact-encoding\",\n  \"version\": \"2.18.0\",\n  \"description\": \"A series of compact encoding schemes for building small and fast parsers and serializers\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"b4a\": \"^1.3.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.0.0\",\n    \"prettier\": \"^3.6.2\",\n    \"prettier-config-holepunch\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"format\": \"prettier . --write\",\n    \"test\": \"prettier . --check && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/compact-encoding/compact-encoding.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/compact-encoding/compact-encoding/issues\"\n  },\n  \"homepage\": \"https://github.com/compact-encoding/compact-encoding\"\n}\nconst b4a = require('b4a')\n\nconst { BE } = require('./endian')\n\nexports = module.exports = {\n  preencode(state, b) {\n    state.end += b.byteLength\n  },\n  encode(state, b) {\n    state.buffer.set(b, state.start)\n    state.start += b.byteLength\n  },\n  decode(state) {\n    const b = state.buffer.subarray(state.start, state.end)\n    state.start = state.end\n    return b\n  }\n}\n\nconst buffer = (exports.buffer = {\n  preencode(state, b) {\n    if (b) uint8array.preencode(state, b)\n    else state.end++\n  },\n  encode(state, b) {\n    if (b) uint8array.encode(state, b)\n    else state.buffer[state.start++] = 0\n  },\n  decode(state) {\n    const b = state.buffer.subarray(state.start)\n    if (b.byteLength === 0) return null\n    state.start = state.end\n    return b\n  }\n})\n\nexports.binary = {\n  ...buffer,\n  preencode(state, b) {\n    if (typeof b === 'string') utf8.preencode(state, b)\n    else buffer.preencode(state, b)\n  },\n  encode(state, b) {\n    if (typeof b === 'string') utf8.encode(state, b)\n    else buffer.encode(state, b)\n  }\n}\n\nexports.arraybuffer = {\n  preencode(state, b) {\n    state.end += b.byteLength\n  },\n  encode(state, b) {\n    const view = new Uint8Array(b)\n\n    state.buffer.set(view, state.start)\n    state.start += b.byteLength\n  },\n  decode(state) {\n    const b = new ArrayBuffer(state.end - state.start)\n    const view = new Uint8Array(b)\n\n    view.set(state.buffer.subarray(state.start))\n\n    state.start = state.end\n\n    return b\n  }\n}\n\nfunction typedarray(TypedArray, swap) {\n  const n = TypedArray.BYTES_PER_ELEMENT\n\n  return {\n    preencode(state, b) {\n      state.end += b.byteLength\n    },\n    encode(state, b) {\n      const view = new Uint8Array(b.buffer, b.byteOffset, b.byteLength)\n\n      if (BE && swap) swap(view)\n\n      state.buffer.set(view, state.start)\n      state.start += b.byteLength\n    },\n    decode(state) {\n      let b = state.buffer.subarray(state.start)\n      if (b.byteOffset % n !== 0) b = new Uint8Array(b)\n\n      if (BE && swap) swap(b)\n\n      state.start = state.end\n\n      return new TypedArray(b.buffer, b.byteOffset, b.byteLength / n)\n    }\n  }\n}\n\nconst uint8array = (exports.uint8array = typedarray(Uint8Array))\nexports.uint16array = typedarray(Uint16Array, b4a.swap16)\nexports.uint32array = typedarray(Uint32Array, b4a.swap32)\n\nexports.int8array = typedarray(Int8Array)\nexports.int16array = typedarray(Int16Array, b4a.swap16)\nexports.int32array = typedarray(Int32Array, b4a.swap32)\n\nexports.biguint64array = typedarray(BigUint64Array, b4a.swap64)\nexports.bigint64array = typedarray(BigInt64Array, b4a.swap64)\n\nexports.float32array = typedarray(Float32Array, b4a.swap32)\nexports.float64array = typedarray(Float64Array, b4a.swap64)\n\nfunction string(encoding) {\n  return {\n    preencode(state, s) {\n      state.end += b4a.byteLength(s, encoding)\n    },\n    encode(state, s) {\n      state.start += b4a.write(state.buffer, s, state.start, encoding)\n    },\n    decode(state) {\n      const s = b4a.toString(state.buffer, encoding, state.start)\n      state.start = state.end\n      return s\n    }\n  }\n}\n\nconst utf8 = (exports.string = exports.utf8 = string('utf-8'))\nexports.ascii = string('ascii')\nexports.hex = string('hex')\nexports.base64 = string('base64')\nexports.ucs2 = exports.utf16le = string('utf16le')\n\nexports.array = function array(enc) {\n  return {\n    preencode(state, list) {\n      for (const value of list) enc.preencode(state, value)\n    },\n    encode(state, list) {\n      for (const value of list) enc.encode(state, value)\n    },\n    decode(state) {\n      const arr = []\n      while (state.start < state.end) arr.push(enc.decode(state))\n      return arr\n    }\n  }\n}\n\nexports.json = {\n  preencode(state, v) {\n    utf8.preencode(state, JSON.stringify(v))\n  },\n  encode(state, v) {\n    utf8.encode(state, JSON.stringify(v))\n  },\n  decode(state) {\n    return JSON.parse(utf8.decode(state))\n  }\n}\n\nexports.ndjson = {\n  preencode(state, v) {\n    utf8.preencode(state, JSON.stringify(v) + '\\n')\n  },\n  encode(state, v) {\n    utf8.encode(state, JSON.stringify(v) + '\\n')\n  },\n  decode(state) {\n    return JSON.parse(utf8.decode(state))\n  }\n}\nconst { EventEmitter } = require('events')\nconst Table = require('kademlia-routing-table')\nconst TOS = require('time-ordered-set')\nconst UDX = require('udx-native')\nconst sodium = require('sodium-universal')\nconst c = require('compact-encoding')\nconst NatSampler = require('nat-sampler')\nconst b4a = require('b4a')\nconst NetworkHealth = require('./lib/health')\nconst IO = require('./lib/io')\nconst Query = require('./lib/query')\nconst Session = require('./lib/session')\nconst peer = require('./lib/peer')\nconst { UNKNOWN_COMMAND, INVALID_TOKEN } = require('./lib/errors')\nconst { PING, PING_NAT, FIND_NODE, DOWN_HINT, DELAYED_PING } = require('./lib/commands')\n\nconst TMP = b4a.allocUnsafe(32)\nconst TICK_INTERVAL = 5000\nconst SLEEPING_INTERVAL = 3 * TICK_INTERVAL\nconst STABLE_TICKS = 240 // if nothing major bad happens in ~20mins we can consider this node stable (if nat is friendly)\nconst MORE_STABLE_TICKS = 3 * STABLE_TICKS\nconst REFRESH_TICKS = 60 // refresh every ~5min when idle\nconst RECENT_NODE = 12 // we've heard from a node less than 1min ago\nconst OLD_NODE = 360 // if an node has been around more than 30 min we consider it old\n\nconst DEFAULTS = {\n  concurrency: 10,\n  maxWindow: IO.DEFAULT_MAX_WINDOW,\n  maxHealthWindow: NetworkHealth.DEFAULT_MAX_HEALTH_WINDOW,\n  maxPingDelay: 10_000\n}\n\nclass DHT extends EventEmitter {\n  constructor(opts = {}) {\n    super()\n\n    this.bootstrapNodes = opts.bootstrap === false ? [] : (opts.bootstrap || []).map(parseNode)\n    this.table = new Table(randomBytes(32))\n    this.nodes = new TOS()\n    this.udx = opts.udx || new UDX()\n    this.io = new IO(this.table, this.udx, {\n      ...opts,\n      onrequest: this._onrequest.bind(this),\n      onresponse: this._onresponse.bind(this),\n      ontimeout: this._ontimeout.bind(this)\n    })\n    this.health = new NetworkHealth(this, opts)\n\n    this.concurrency = opts.concurrency || DEFAULTS.concurrency\n    this.maxPingDelay = opts.maxPingDelay || DEFAULTS.maxPingDelay\n    this.bootstrapped = false\n    this.ephemeral = true\n    this.firewalled = this.io.firewalled\n    this.adaptive = typeof opts.ephemeral !== 'boolean' && opts.adaptive !== false\n    this.destroyed = false\n    this.suspended = false\n    this.online = true\n    this.degraded = false\n    this.stats = {\n      queries: { active: 0, total: 0 },\n      requests: this.io.stats.requests,\n      commands: {\n        ping: this.io.stats.commands[PING],\n        pingNat: this.io.stats.commands[PING_NAT],\n        findNode: this.io.stats.commands[FIND_NODE],\n        downHint: this.io.stats.commands[DOWN_HINT]\n      }\n    }\n\n    this._nat = new NatSampler()\n    this._quickFirewall = opts.quickFirewall !== false\n    this._forcePersistent = opts.ephemeral === false\n    this._repinging = 0\n    this._checks = 0\n    this._tick = randomOffset(100) // make sure to random offset all the network ticks\n    this._refreshTicks = randomOffset(REFRESH_TICKS)\n    this._stableTicks = this.adaptive ? STABLE_TICKS : 0\n    this._tickInterval = setInterval(this._ontick.bind(this), TICK_INTERVAL)\n    this._lastTick = Date.now()\n    this._lastHost = null\n    this._filterNode = opts.filterNode || opts.addNode || null // opts.addNode is deprecating, use opts.filterNode instead\n    this._onrow = (row) => row.on('full', (node) => this._onfullrow(node, row))\n    this._nonePersistentSamples = []\n    this._bootstrapping = this._bootstrap()\n    this._bootstrapping.catch(noop)\n    this._sendDownHints = opts.sendDownHints !== false\n    this._downHintsRateLimit =\n      opts.downHintsRateLimit !== undefined ? opts.downHintsRateLimit : 10 * 5\n    this._downHintsSentPerTick = 0\n    this._pendingTimers = new Set()\n\n    this.table.on('row', this._onrow)\n\n    this.io.networkInterfaces.on('change', (interfaces) => this._onnetworkchange(interfaces))\n\n    if (opts.nodes) {\n      for (let i = opts.nodes.length - 1; i >= 0; i--) {\n        this.addNode(opts.nodes[i])\n      }\n    }\n  }\n\n  static DEFAULTS = DEFAULTS\n\n  static bootstrapper(port, host, opts) {\n    if (!port) throw new Error('Port is required')\n    if (!host) throw new Error('Host is required')\n    if (host === '0.0.0.0' || host === '::') throw new Error('Invalid host')\n    if (!UDX.isIPv4(host)) throw new Error('Host must be a IPv4 address')\n\n    const dht = new this({\n      port,\n      ephemeral: false,\n      firewalled: false,\n      anyPort: false,\n      bootstrap: [],\n      ...opts\n    })\n    dht._nat.add(host, port)\n    return dht\n  }\n\n  get id() {\n    return this.ephemeral ? null : this.table.id\n  }\n\n  get host() {\n    return this._nat.host\n  }\n\n  get port() {\n    return this._nat.port\n  }\n\n  get randomized() {\n    return this._nat.host !== null && this._nat.port === 0\n  }\n\n  get socket() {\n    return this.firewalled ? this.io.clientSocket : this.io.serverSocket\n  }\n\n  get config() {\n    return {\n      concurrency: this.concurrency,\n      maxWindow: this.io.congestion._maxWindow,\n      randomPunchInterval: this._randomPunchInterval,\n      connectionKeepAlive: this.connectionKeepAlive,\n      sendDownHints: this._sendDownHints,\n      downHintsRateLimit: this._downHintsRateLimit\n    }\n  }\n\n  onmessage(socket, buf, rinfo) {\n    if (buf.byteLength > 1) this.io.onmessage(socket, buf, rinfo)\n  }\n\n  bind() {\n    return this.io.bind()\n  }\n\n  async suspend({ log = noop } = {}) {\n    log('Suspending waiting for io bind...')\n    await this.io.bind()\n    log('Done, continuing')\n    if (this.suspended || this.destroyed) return\n    this.suspended = true\n    clearInterval(this._tickInterval)\n    log('Done, suspending io')\n    await this.io.suspend({ log })\n    log('Done, dht suspended')\n    this.emit('suspend')\n  }\n\n  async resume({ log = noop } = {}) {\n    if (!this.suspended || this.destroyed) return\n    this.suspended = false\n    this._tickInterval = setInterval(this._ontick.bind(this), TICK_INTERVAL)\n    this._onwakeup()\n    log('Resuming io')\n    await this.io.resume()\n    this.health.reset()\n    log('Done, dht resumed')\n    this.io.networkInterfaces.on('change', (interfaces) => this._onnetworkchange(interfaces))\n    this.refresh()\n    this.emit('resume')\n  }\n\n  address() {\n    const socket = this.socket\n    return socket ? socket.address() : null\n  }\n\n  localAddress() {\n    if (!this.io.serverSocket) return null\n\n    return {\n      host: localIP(this.udx),\n      port: this.io.serverSocket.address().port\n    }\n  }\n\n  remoteAddress() {\n    if (!this.host) return null\n    if (!this.port) return null\n    if (this.firewalled) return null\n    if (!this.io.serverSocket) return null\n\n    const port = this.io.serverSocket.address().port\n    if (port !== this.port) return null\n\n    return {\n      host: this.host,\n      port\n    }\n  }\n\n  addNode({ host, port }) {\n    this._addNode({\n      id: peer.id(host, port),\n      port,\n      host,\n      token: null,\n      to: null,\n      sampled: 0,\n      added: this._tick,\n      pinged: 0,\n      seen: 0,\n      downHints: 0,\n      prev: null,\n      next: null\n    })\n  }\n\n  toArray(opts) {\n    const limit = opts && opts.limit\n    if (limit === 0) return []\n    return this.nodes.toArray({ limit, reverse: true }).map(({ host, port }) => ({ host, port }))\n  }\n\n  async fullyBootstrapped() {\n    return this._bootstrapping\n  }\n\n  ready() {\n    // Deprecating, use fullyBootstrapped instead (removed on next major)\n    return this.fullyBootstrapped()\n  }\n\n  findNode(target, opts) {\n    if (this.destroyed) throw new Error('Node destroyed')\n    this._refreshTicks = REFRESH_TICKS\n    return new Query(this, target, true, FIND_NODE, null, opts)\n  }\n\n  query({ target, command, value }, opts) {\n    if (this.destroyed) throw new Error('Node destroyed')\n    this._refreshTicks = REFRESH_TICKS\n    return new Query(this, target, false, command, value || null, opts)\n  }\n\n  ping({ host, port }, opts) {\n    let value = null\n\n    if (opts && opts.size && opts.size > 0) value = b4a.alloc(opts.size)\n\n    const req = this.io.createRequest(\n      { id: null, host, port },\n      null,\n      true,\n      PING,\n      null,\n      value,\n      (opts && opts.session) || null,\n      opts && opts.ttl\n    )\n    return this._requestToPromise(req, opts)\n  }\n\n  delayedPing({ host, port }, delayMs, opts) {\n    if (delayMs > this.maxPingDelay) {\n      throw new Error(`Delay exceeds max delay: ${this.maxPingDelay}ms`)\n    }\n\n    const value = b4a.allocUnsafe(4)\n    c.uint32.encode({ start: 0, end: 4, buffer: value }, delayMs)\n\n    const req = this.io.createRequest(\n      { id: null, host, port },\n      null,\n      true,\n      DELAYED_PING,\n      null,\n      value,\n      (opts && opts.session) || null,\n      opts && opts.ttl\n    )\n    // add 1 second to the timeout to account for network overhead\n    req.timeout = delayMs + 1_000\n    return this._requestToPromise(req, opts)\n  }\n\n  async rttStats() {\n    const stats = {\n      successes: 0,\n      errors: 0,\n      responses: {\n        avgRtt: 0,\n        errors: 0,\n        avgCloserNodes: 0\n      },\n      closestReplies: {\n        avgRtt: 0,\n        errors: 0,\n        avgCloserNodes: 0\n      }\n    }\n\n    if (this.nodes.latest) {\n      const q = this.findNode(this.nodes.latest.id)\n\n      let responseCount = 0\n      let closestCount = 0\n\n      for await (const msg of q) {\n        stats.responses.avgRtt += msg.rtt\n        stats.responses.errors += msg.error\n        stats.responses.avgCloserNodes += msg.closerNodes?.length || 0\n        responseCount++\n      }\n      stats.responses.avgRtt /= responseCount\n      stats.responses.avgCloserNodes /= responseCount\n\n      for await (const msg of q.closestReplies) {\n        stats.closestReplies.avgRtt += msg.rtt\n        stats.closestReplies.errors += msg.error\n        stats.closestReplies.avgCloserNodes += msg.closerNodes?.length || 0\n        closestCount++\n      }\n      stats.closestReplies.avgRtt /= closestCount\n      stats.closestReplies.avgCloserNodes /= closestCount\n\n      stats.successes = q.successes\n      stats.errors = q.errors\n    }\n\n    return stats\n  }\n\n  request({ token = null, command, target = null, value = null }, { host, port }, opts) {\n    const req = this.io.createRequest(\n      { id: null, host, port },\n      token,\n      false,\n      command,\n      target,\n      value,\n      (opts && opts.session) || null,\n      opts && opts.ttl\n    )\n    return this._requestToPromise(req, opts)\n  }\n\n  session() {\n    return new Session(this)\n  }\n\n  _requestToPromise(req, opts) {\n    if (req === null) return Promise.reject(new Error('Node destroyed'))\n\n    if (opts && opts.socket) req.socket = opts.socket\n    if (opts && opts.retry === false) req.retries = 0\n\n    return new Promise((resolve, reject) => {\n      req.onresponse = resolve\n      req.onerror = reject\n      req.send()\n    })\n  }\n\n  async _bootstrap() {\n    const self = this\n\n    await Promise.resolve() // wait a tick, so apis can be used from the outside\n    await this.io.bind()\n\n    this.emit('listening')\n\n    // TODO: some papers describe more advanced ways of bootstrapping - we should prob look into that\n\n    let first = this.firewalled && this._quickFirewall && !this._forcePersistent\n    let testNat = false\n\n    const onlyFirewall = !this._forcePersistent\n\n    for (let i = 0; i < 2; i++) {\n      await this._backgroundQuery(this.table.id).on('data', ondata).finished()\n\n      if (this.bootstrapped || (!testNat && !this._forcePersistent)) break\n      if (!(await this._updateNetworkState(onlyFirewall))) break\n    }\n\n    if (this.bootstrapped) return\n    this.bootstrapped = true\n\n    this.emit('ready')\n\n    function ondata(data) {\n      // Simple QUICK nat heuristic.\n      // If we get ONE positive nat ping before the bootstrap query finishes\n      // then we always to a nat test, no matter if we are adaptive...\n      // This should be expanded in the future to try more than one node etc, not always hit the first etc\n      // If this fails, then nbd, as the onstable hook will pick it up later.\n\n      if (!first) return\n      first = false\n\n      const value = b4a.allocUnsafe(2)\n      c.uint16.encode({ start: 0, end: 2, buffer: value }, self.io.serverSocket.address().port)\n\n      self._request(\n        data.from,\n        false,\n        true,\n        PING_NAT,\n        null,\n        value,\n        null,\n        () => {\n          testNat = true\n        },\n        noop\n      )\n    }\n  }\n\n  refresh() {\n    const node = this.table.random()\n    this._backgroundQuery(node ? node.id : this.table.id).on('error', noop)\n  }\n\n  async destroy() {\n    const emitClose = !this.destroyed\n    this.destroyed = true\n    clearInterval(this._tickInterval)\n    for (const timer of this._pendingTimers) {\n      clearTimeout(timer)\n    }\n    await this.io.destroy()\n    if (emitClose) this.emit('close')\n  }\n\n  _request(to, force, internal, command, target, value, session, onresponse, onerror) {\n    if (internal && !this._sendDownHints && command === DOWN_HINT) return null\n    const req = this.io.createRequest(to, null, internal, command, target, value, session)\n    if (req === null) return null\n\n    req.onresponse = onresponse\n    req.onerror = onerror\n    req.send(force)\n\n    return req\n  }\n\n  _natAdd(host, port) {\n    const prevHost = this._nat.host\n    const prevPort = this._nat.port\n\n    this._nat.add(host, port)\n\n    if (prevHost === this._nat.host && prevPort === this._nat.port) return\n\n    this.emit('nat-update', this._nat.host, this._nat.port)\n  }\n\n  // we don't check that this is a bootstrap node but we limit the sample size to very few nodes, so fine\n  _sampleBootstrapMaybe(from, to) {\n    if (this._nonePersistentSamples.length >= Math.max(1, this.bootstrapNodes.length)) return\n    const id = from.host + ':' + from.port\n    if (this._nonePersistentSamples.indexOf(id) > -1) return\n    this._nonePersistentSamples.push(id)\n    this._natAdd(to.host, to.port)\n  }\n\n  _addNodeFromNetwork(sample, from, to) {\n    if (this._filterNode !== null && !this._filterNode(from)) {\n      return\n    }\n\n    if (from.id === null) {\n      this._sampleBootstrapMaybe(from, to)\n      return\n    }\n\n    const oldNode = this.table.get(from.id)\n\n    // refresh it, if we've seen this before\n    if (oldNode) {\n      if (sample && (oldNode.sampled === 0 || this._tick - oldNode.sampled >= OLD_NODE)) {\n        oldNode.to = to\n        oldNode.sampled = this._tick\n        this._natAdd(to.host, to.port)\n      }\n\n      oldNode.pinged = oldNode.seen = this._tick\n      this.nodes.add(oldNode)\n      return\n    }\n\n    this._addNode({\n      id: from.id,\n      port: from.port,\n      host: from.host,\n      to,\n      sampled: 0,\n      added: this._tick,\n      pinged: this._tick, // last time we interacted with them\n      seen: this._tick, // last time we heard from them\n      downHints: 0,\n      prev: null,\n      next: null\n    })\n  }\n\n  _addNode(node) {\n    if (this.nodes.has(node) || b4a.equals(node.id, this.table.id)) return\n\n    node.added = node.pinged = node.seen = this._tick\n\n    if (!this.table.add(node)) return\n    this.nodes.add(node)\n\n    if (node.to && node.sampled === 0) {\n      node.sampled = this._tick\n      this._natAdd(node.to.host, node.to.port)\n    }\n\n    this.emit('add-node', node)\n  }\n\n  _removeStaleNode(node, lastSeen) {\n    if (node.seen <= lastSeen) this._removeNode(node)\n  }\n\n  _removeNode(node) {\n    if (!this.nodes.has(node)) return\n\n    this.table.remove(node.id)\n    this.nodes.remove(node)\n\n    this.emit('remove-node', node)\n  }\n\n  _onwakeup() {\n    this._tick += 2 * OLD_NODE // bump the tick enough that everything appears old.\n    this._tick += 8 - (this._tick & 7) - 2 // triggers a series of pings in two ticks\n    this._stableTicks = MORE_STABLE_TICKS\n    this._refreshTicks = 1 // triggers a refresh next tick (allow network time to wake up also)\n    this._lastHost = null // clear network cache check\n\n    if (this.adaptive) {\n      // TODO: re-enable this as soon as we find out why this is over triggering in some edge cases\n      // this.firewalled = true\n      // this.io.firewalled = true\n\n      if (!this.ephemeral) {\n        this.ephemeral = true\n        this.io.ephemeral = true\n        this.emit('ephemeral')\n      }\n    }\n\n    this.emit('wakeup')\n  }\n\n  _onfullrow(newNode, row) {\n    if (!this.bootstrapped || this._repinging >= 3) return\n\n    let oldest = null\n    for (const node of row.nodes) {\n      if (node.pinged === this._tick) continue\n      if (\n        oldest === null ||\n        oldest.pinged > node.pinged ||\n        (oldest.pinged === node.pinged && oldest.added > node.added)\n      ) {\n        oldest = node\n      }\n    }\n\n    if (oldest === null) return\n    if (this._tick - oldest.pinged < RECENT_NODE && this._tick - oldest.added > OLD_NODE) return\n\n    this._repingAndSwap(newNode, oldest)\n  }\n\n  _onnetworkchange(interfaces) {\n    this.emit('network-change', interfaces)\n    this.emit('network-update')\n  }\n\n  _repingAndSwap(newNode, oldNode) {\n    const self = this\n    const lastSeen = oldNode.seen\n\n    oldNode.pinged = this._tick\n\n    this._repinging++\n    this._request(\n      { id: null, host: oldNode.host, port: oldNode.port },\n      false,\n      true,\n      PING,\n      null,\n      null,\n      null,\n      onsuccess,\n      onswap\n    )\n\n    function onsuccess(m) {\n      if (oldNode.seen <= lastSeen) return onswap()\n      self._repinging--\n    }\n\n    function onswap(e) {\n      self._repinging--\n      self._removeNode(oldNode)\n      self._addNode(newNode)\n    }\n  }\n\n  _onrequest(req, external) {\n    if (req.from.id !== null) {\n      this._addNodeFromNetwork(!external, req.from, req.to)\n    }\n\n    if (req.internal) {\n      switch (req.command) {\n        // standard keep alive call\n        case PING: {\n          req.sendReply(0, null, false, false)\n          return\n        }\n        case DELAYED_PING: {\n          this._ondelayedping(req)\n          return\n        }\n        // check if the other side can receive a message to their other socket\n        case PING_NAT: {\n          if (req.value === null || req.value.byteLength < 2) return\n          const port = c.uint16.decode({ start: 0, end: 2, buffer: req.value })\n          if (port === 0) return\n          req.from.port = port\n          req.sendReply(0, null, false, false)\n          return\n        }\n        // empty dht reply back\n        case FIND_NODE: {\n          if (!req.target) return\n          req.sendReply(0, null, false, true)\n          return\n        }\n        // \"this is node you sent me is down\" - let's try to ping it\n        case DOWN_HINT: {\n          if (req.value === null || req.value.byteLength < 6) return\n          if (this._checks < 10) {\n            sodium.crypto_generichash(TMP, req.value.subarray(0, 6))\n            const node = this.table.get(TMP)\n            if (node && (node.pinged < this._tick || node.downHints === 0)) {\n              node.downHints++\n              this._check(node)\n            }\n          }\n          req.sendReply(0, null, false, false)\n          return\n        }\n      }\n\n      req.sendReply(UNKNOWN_COMMAND, null, false, req.target !== null)\n      return\n    }\n\n    // ask the user to handle it or reply back with a bad command\n    if (this.onrequest(req) === false) {\n      req.sendReply(UNKNOWN_COMMAND, null, false, req.target !== null)\n    }\n  }\n\n  onrequest(req) {\n    return this.emit('request', req)\n  }\n\n  _ondelayedping(req) {\n    if (req.value === null || req.value.byteLength < 4) return\n    const delayMs = c.uint32.decode({ start: 0, end: 4, buffer: req.value })\n    if (delayMs > this.maxPingDelay) return\n    const timer = setTimeout(() => {\n      if (this.destroyed) return\n      this._pendingTimers.delete(timer)\n      req.sendReply(0, null, false, false)\n    }, delayMs)\n    this._pendingTimers.add(timer)\n  }\n\n  _onresponse(res, external) {\n    this._addNodeFromNetwork(!external, res.from, res.to)\n  }\n\n  _ontimeout(req) {\n    if (!req.to.id) return\n    const node = this.table.get(req.to.id)\n    if (node) this._removeNode(node)\n  }\n\n  _pingSome() {\n    let cnt = this.io.inflight.length > 2 ? 3 : 5\n    let oldest = this.nodes.oldest\n\n    // tiny dht, pinged the bootstrap again\n    if (!oldest) {\n      this.refresh()\n      return\n    }\n\n    // we've recently pinged the oldest one, so only trigger a couple of repings\n    if (this._tick - oldest.pinged < RECENT_NODE) {\n      cnt = 2\n    }\n\n    while (cnt--) {\n      if (!oldest || this._tick === oldest.pinged) continue\n      this._check(oldest)\n      oldest = oldest.next\n    }\n  }\n\n  _check(node) {\n    node.pinged = this._tick\n\n    const lastSeen = node.seen\n    const onresponse = () => {\n      this._checks--\n      this._removeStaleNode(node, lastSeen)\n    }\n    const onerror = () => {\n      this._checks--\n      this._removeNode(node)\n    }\n\n    this._checks++\n    this._request(\n      { id: null, host: node.host, port: node.port },\n      false,\n      true,\n      PING,\n      null,\n      null,\n      null,\n      onresponse,\n      onerror\n    )\n  }\n\n  _ontick() {\n    const time = Date.now()\n\n    if (time - this._lastTick > SLEEPING_INTERVAL && this.suspended === false) {\n      this._onwakeup()\n    } else {\n      this._tick++\n    }\n\n    this._lastTick = time\n\n    if (!this.bootstrapped || this.suspended) return\n\n    if (this.adaptive && this.ephemeral && --this._stableTicks <= 0) {\n      if (this._lastHost === this._nat.host) {\n        // do not recheck the same network...\n        this._stableTicks = MORE_STABLE_TICKS\n      } else {\n        this._updateNetworkState() // the promise returned here never fails so just ignore it\n      }\n    }\n\n    if ((this._tick & 7) === 0) {\n      this._pingSome()\n    }\n\n    if (\n      ((this._tick & 63) === 0 && this.nodes.length < this.table.k) ||\n      --this._refreshTicks <= 0\n    ) {\n      this.refresh()\n    }\n\n    this._downHintsSentPerTick = 0\n    this.health.update()\n  }\n\n  async _updateNetworkState(onlyFirewall = false) {\n    if (!this.ephemeral) return false\n    if (onlyFirewall && !this.firewalled) return false\n\n    const { host, port } = this._nat\n\n    if (!onlyFirewall) {\n      // remember what host we checked and reset the counter\n      this._stableTicks = MORE_STABLE_TICKS\n      this._lastHost = host\n    }\n\n    // check if we have a consistent host and port\n    if (host === null || port === 0) {\n      return false\n    }\n\n    const natSampler = this.firewalled ? new NatSampler() : this._nat\n\n    // ask remote nodes to ping us on our server socket to see if we have the port open\n    const firewalled = this.firewalled && (await this._checkIfFirewalled(natSampler))\n    if (firewalled) return false\n\n    this.firewalled = this.io.firewalled = false\n\n    // incase it's called in parallel for some reason, or if our nat status somehow changed\n    if (!this.ephemeral || host !== this._nat.host || port !== this._nat.port) return false\n    // if the firewall probe returned a different host / non consistent port, bail as well\n    if (natSampler.host !== host || natSampler.port === 0) return false\n\n    const id = peer.id(natSampler.host, natSampler.port)\n\n    if (!onlyFirewall) {\n      this.ephemeral = this.io.ephemeral = false\n    }\n\n    if (natSampler !== this._nat) {\n      const prevHost = this._nat.host\n      const prevPort = this._nat.port\n\n      this._nonePersistentSamples = []\n      this._nat = natSampler\n\n      if (prevHost !== this._nat.host || prevPort !== this._nat.port) {\n        this.emit('nat-update', this._nat.host, this._nat.port)\n      }\n    }\n\n    // TODO: we should make this a bit more defensive in terms of using more\n    // resources to make sure that the new routing table contains as many alive nodes\n    // as possible, vs blindly copying them over...\n\n    // all good! copy over the old routing table to the new one\n    if (!b4a.equals(this.table.id, id)) {\n      const nodes = this.table.toArray()\n\n      this.table = this.io.table = new Table(id)\n\n      for (const node of nodes) {\n        if (b4a.equals(node.id, id)) continue\n        if (!this.table.add(node)) this.nodes.remove(node)\n      }\n\n      this.table.on('row', this._onrow)\n\n      // we need to rebootstrap/refresh since we updated our id\n      if (this.bootstrapped) this.refresh()\n    }\n\n    if (!this.ephemeral) {\n      this.emit('persistent')\n    }\n\n    return true\n  }\n\n  async *_resolveBootstrapNodes() {\n    for (let { host, port } of this.bootstrapNodes) {\n      let doLookup = false\n\n      if (host.indexOf('@') === -1) {\n        doLookup = true\n      } else {\n        const [suggestedIP, fallbackHost] = host.split('@')\n        try {\n          await this.ping({ host: suggestedIP, port })\n          host = suggestedIP\n        } catch {\n          host = fallbackHost\n          doLookup = true\n        }\n      }\n\n      if (doLookup) {\n        try {\n          host = UDX.isIPv4(host) ? host : (await this.udx.lookup(host, { family: 4 })).host\n        } catch {\n          continue\n        }\n      }\n\n      yield {\n        id: peer.id(host, port),\n        host,\n        port\n      }\n    }\n  }\n\n  async _addBootstrapNodes(nodes) {\n    for await (const node of this._resolveBootstrapNodes()) {\n      nodes.push(node)\n    }\n  }\n\n  async _checkIfFirewalled(natSampler = new NatSampler()) {\n    const nodes = []\n    for (let node = this.nodes.latest; node && nodes.length < 5; node = node.prev) {\n      nodes.push(node)\n    }\n\n    if (nodes.length < 5) await this._addBootstrapNodes(nodes)\n    // if no nodes are available, including bootstrappers - bail\n    if (nodes.length === 0) return true\n\n    const hosts = new Set()\n    const value = b4a.allocUnsafe(2)\n\n    c.uint16.encode({ start: 0, end: 2, buffer: value }, this.io.serverSocket.address().port)\n\n    // double check they actually came on the server socket...\n    this.io.serverSocket.on('message', onmessage)\n\n    const pongs = await requestAll(this, true, PING_NAT, value, nodes)\n\n    let count = 0\n    for (const res of pongs) {\n      if (hosts.has(res.from.host)) {\n        count++\n        natSampler.add(res.to.host, res.to.port)\n      }\n    }\n\n    this.io.serverSocket.removeListener('message', onmessage)\n\n    // if we got no or very few replies, consider it a fluke\n    if (count < (nodes.length >= 5 ? 3 : 1)) return true\n\n    // check that the server socket has the same ip as the client socket\n    if (natSampler.host === null || this._nat.host !== natSampler.host) return true\n\n    // check that the local port of the server socket is the same as the remote port\n    // TODO: we might want a flag to opt out of this heuristic for specific remapped port servers\n    if (natSampler.port === 0 || natSampler.port !== this.io.serverSocket.address().port) {\n      return true\n    }\n\n    return false\n\n    function onmessage(_, { host }) {\n      hosts.add(host)\n    }\n  }\n\n  _backgroundQuery(target) {\n    this._refreshTicks = REFRESH_TICKS\n\n    const backgroundCon = Math.min(this.concurrency, Math.max(2, (this.concurrency / 8) | 0))\n    const q = new Query(this, target, true, FIND_NODE, null, {\n      concurrency: backgroundCon\n    })\n\n    q.on('data', () => {\n      // yield to other traffic\n      q.concurrency = this.io.inflight.length < 3 ? this.concurrency : backgroundCon\n    })\n\n    return q\n  }\n\n  // called by health\n  _online() {\n    if (this.online && !this.degraded) return\n    this.online = true\n    this.degraded = false\n    this.emit('network-update')\n  }\n\n  // called by health\n  _degraded() {\n    if (this.degraded) return\n    this.online = true\n    this.degraded = true\n    this.emit('network-update')\n  }\n\n  // called by health\n  _offline() {\n    if (!this.online) return\n    this.online = false\n    this.degraded = false\n    this.emit('network-update')\n  }\n}\n\nDHT.OK = 0\nDHT.ERROR_UNKNOWN_COMMAND = UNKNOWN_COMMAND\nDHT.ERROR_INVALID_TOKEN = INVALID_TOKEN\n\nmodule.exports = DHT\n\nfunction localIP(udx, family = 4) {\n  let host = null\n\n  for (const n of udx.networkInterfaces()) {\n    if (n.family !== family || n.internal) continue\n\n    // mac really likes en0, mb a better way but this shouldnt be bad anywhere so return now\n    if (n.name === 'en0') return n.host\n\n    // otherwise pick the first non internal host (let the loop continue in case we see en0)\n    if (host === null) host = n.host\n  }\n\n  return host || (family === 4 ? '127.0.0.1' : '::1')\n}\n\nfunction parseNode(s) {\n  if (typeof s === 'object') return s\n  if (typeof s === 'number') return { host: '127.0.0.1', port: s }\n  const [host, port] = s.split(':')\n  if (!port) throw new Error('Bootstrap node format is host:port')\n\n  return {\n    host,\n    port: Number(port)\n  }\n}\n\nfunction randomBytes(n) {\n  const b = b4a.alloc(n)\n  sodium.randombytes_buf(b)\n  return b\n}\n\nfunction randomOffset(n) {\n  return n - ((Math.random() * 0.5 * n) | 0)\n}\n\nfunction requestAll(dht, internal, command, value, nodes) {\n  let missing = nodes.length\n  const replies = []\n\n  return new Promise((resolve) => {\n    for (const node of nodes) {\n      const req = dht._request(\n        node,\n        false,\n        internal,\n        command,\n        null,\n        value,\n        null,\n        onsuccess,\n        onerror\n      )\n      if (!req) return resolve(replies)\n    }\n\n    function onsuccess(res) {\n      replies.push(res)\n      if (--missing === 0) resolve(replies)\n    }\n\n    function onerror() {\n      if (--missing === 0) resolve(replies)\n    }\n  })\n}\n\nfunction noop() {}\nexports.PING = 0\nexports.PING_NAT = 1\nexports.FIND_NODE = 2\nexports.DOWN_HINT = 3\nexports.DELAYED_PING = 4\nmodule.exports = class DHTError extends Error {\n  constructor(msg, code, fn = DHTError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'DHTError'\n  }\n\n  static UNKNOWN_COMMAND = 1\n  static INVALID_TOKEN = 2\n\n  static REQUEST_TIMEOUT(msg = 'Request timed out') {\n    return new DHTError(msg, 'REQUEST_TIMEOUT', DHTError.REQUEST_TIMEOUT)\n  }\n\n  static REQUEST_DESTROYED(msg = 'Request destroyed') {\n    return new DHTError(msg, 'REQUEST_DESTROYED', DHTError.REQUEST_DESTROYED)\n  }\n\n  static IO_SUSPENDED(msg = 'I/O suspended') {\n    return new DHTError(msg, 'IO_SUSPENDED', DHTError.IO_SUSPENDED)\n  }\n}\nconst MAX_HEALTH_WINDOW = 2\nconst RESPONSES_SANITY = 0\nconst TIMEOUTS_SANITY = 0\nconst TIMEOUTS_THRESHOLD = 0.5\n\nmodule.exports = class NetworkHealth {\n  static DEFAULT_MAX_HEALTH_WINDOW = MAX_HEALTH_WINDOW\n\n  constructor(dht, { maxHealthWindow = MAX_HEALTH_WINDOW } = {}) {\n    this._dht = dht\n    this._maxHealthWindow = maxHealthWindow\n    this._window = []\n    this._head = -1\n    this.online = true\n    this.degraded = false\n  }\n\n  get oldest() {\n    return this._window[this._tail]\n  }\n\n  get newest() {\n    return this._window[this._head]\n  }\n\n  get responses() {\n    if (!this.newest) return 0\n    return this.newest.responses - this.oldest.responses\n  }\n\n  get timeouts() {\n    if (!this.newest) return 0\n    return this.newest.timeouts - this.oldest.timeouts\n  }\n\n  get timeoutsRate() {\n    if (this.timeouts === 0) return 0\n    return this.timeouts / (this.responses + this.timeouts)\n  }\n\n  get stats() {\n    return {\n      online: this.online,\n      degraded: this.degraded,\n      responses: this.responses,\n      timeouts: this.timeouts,\n      timeoutsRate: this.timeoutsRate\n    }\n  }\n\n  get _tail() {\n    return (this._head + 1) % this._maxHealthWindow\n  }\n\n  get cold() {\n    return this._window.length < this._maxHealthWindow\n  }\n\n  reset() {\n    this._window = []\n    this._head = -1\n    this.online = true\n    this.degraded = false\n    this._dht._online()\n  }\n\n  update() {\n    this._head = this._tail\n    this._window[this._head] = {\n      responses: this._dht.stats.requests.responses,\n      timeouts: this._dht.stats.requests.timeouts\n    }\n\n    if (this.cold) return\n\n    const responses = this.responses\n    const timeouts = this.timeouts\n    const timeoutsRate = this.timeoutsRate\n\n    if (responses > 0) {\n      this.online = true\n    }\n\n    if (responses > RESPONSES_SANITY * this._window.length) {\n      this.degraded = timeoutsRate > TIMEOUTS_THRESHOLD\n    }\n\n    if (responses === 0 && timeouts > TIMEOUTS_SANITY * this._window.length) {\n      this.online = false\n      this.degraded = false\n    }\n\n    if (this.online && !this.degraded) this._dht._online()\n    else if (this.degraded) this._dht._degraded()\n    else this._dht._offline()\n  }\n}\nconst FIFO = require('fast-fifo')\nconst sodium = require('sodium-universal')\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\nconst AdaptiveTimeout = require('adaptive-timeout')\nconst peer = require('./peer')\nconst { INVALID_TOKEN, REQUEST_TIMEOUT, REQUEST_DESTROYED, IO_SUSPENDED } = require('./errors')\n\nconst VERSION = 0b11\nconst RESPONSE_ID = (0b0001 << 4) | VERSION\nconst REQUEST_ID = (0b0000 << 4) | VERSION\nconst EMPTY_ARRAY = []\nconst MAX_WINDOW = 80\n\nmodule.exports = class IO {\n  constructor(\n    table,\n    udx,\n    {\n      maxWindow = MAX_WINDOW,\n      port = 0,\n      host = '0.0.0.0',\n      anyPort = true,\n      firewalled = true,\n      onrequest,\n      onresponse = noop,\n      ontimeout = noop,\n      adaptiveTimeout\n    } = {}\n  ) {\n    this.table = table\n    this.udx = udx\n    this.inflight = []\n    this.clientSocket = null\n    this.serverSocket = null\n    this.firewalled = firewalled !== false\n    this.ephemeral = true\n    this.congestion = new CongestionWindow(maxWindow)\n    this.networkInterfaces = udx.watchNetworkInterfaces()\n    this.suspended = false\n\n    this.stats = {\n      requests: {\n        active: 0,\n        total: 0,\n        responses: 0,\n        timeouts: 0,\n        retries: 0\n      },\n      commands: [\n        { tx: 0, rx: 0 }, // tx = transmitted, rx = received\n        { tx: 0, rx: 0 },\n        { tx: 0, rx: 0 },\n        { tx: 0, rx: 0 }\n      ]\n    }\n\n    this.onrequest = onrequest\n    this.onresponse = onresponse\n    this.ontimeout = ontimeout\n\n    this._pending = new FIFO()\n    this._rotateSecrets = 10\n    this._tid = (Math.random() * 65536) | 0\n    this._secrets = null\n    this._drainInterval = null\n    this._destroying = null\n    this._binding = null\n\n    // port can be a number or a range [start, to]\n    this.portRange = port.length ? port : port === 0 ? [0, 0] : [port, port + 5]\n\n    this._host = host\n    this._anyPort = anyPort !== false\n    this._boundServerPort = 0\n    this._boundClientPort = 0\n\n    this._adt = adaptiveTimeout ? new AdaptiveTimeout(adaptiveTimeout) : null\n  }\n\n  static DEFAULT_MAX_WINDOW = MAX_WINDOW\n\n  onmessage(socket, buffer, { host, port }) {\n    if (buffer.byteLength < 2 || !(port > 0 && port < 65536) || this.suspended === true) return\n\n    const from = { id: null, host, port }\n    const state = { start: 1, end: buffer.byteLength, buffer }\n    const expectedSocket = this.firewalled ? this.clientSocket : this.serverSocket\n    const external = socket !== expectedSocket\n\n    if (buffer[0] === REQUEST_ID) {\n      const req = Request.decode(this, socket, from, state)\n      if (req === null) return\n      if (\n        req.token !== null &&\n        !b4a.equals(req.token, this.token(req.from, 1)) &&\n        !b4a.equals(req.token, this.token(req.from, 0))\n      ) {\n        req.error(INVALID_TOKEN, { token: true })\n        return\n      }\n      this.onrequest(req, external)\n      return\n    }\n\n    if (buffer[0] === RESPONSE_ID) {\n      const res = decodeReply(from, state)\n      if (res === null) return\n\n      for (let i = 0; i < this.inflight.length; i++) {\n        const req = this.inflight[i]\n        if (req.tid !== res.tid) continue\n\n        res.rtt = Date.now() - req._timestamp\n\n        if (this._adt && req.sent <= 2) {\n          this._adt.put(`${req.to.host}:${req.to.port}`, res.rtt)\n        }\n\n        if (i === this.inflight.length - 1) this.inflight.pop()\n        else this.inflight[i] = this.inflight.pop()\n\n        if (req.session) req.session._detach(req)\n\n        // TODO: Auto retry here if errors.INVALID_TOKEN is returned?\n\n        if (req._timeout) {\n          clearTimeout(req._timeout)\n          req._timeout = null\n        }\n\n        this.congestion.recv()\n\n        if (req.internal && req.command < this.stats.commands.length) {\n          this.stats.commands[req.command].rx++\n        }\n\n        this.stats.requests.active--\n        this.stats.requests.responses++\n\n        this.onresponse(res, external)\n        req.onresponse(res, req)\n        break\n      }\n    }\n  }\n\n  token(addr, i) {\n    if (this._secrets === null) {\n      const buf = b4a.alloc(64)\n      this._secrets = [buf.subarray(0, 32), buf.subarray(32, 64)]\n      sodium.randombytes_buf(this._secrets[0])\n      sodium.randombytes_buf(this._secrets[1])\n    }\n\n    const token = b4a.allocUnsafe(32)\n    sodium.crypto_generichash(token, b4a.from(addr.host), this._secrets[i])\n    return token\n  }\n\n  async destroy() {\n    if (this._destroying) return this._destroying\n    this._destroying = this._destroy()\n    return this._destroying\n  }\n\n  async _destroy() {\n    // simplifies timing to await the bind here also, although it might be unneeded\n    await this.bind()\n    await this._clear(false)\n  }\n\n  async _clear(suspended) {\n    if (this._drainInterval) {\n      clearInterval(this._drainInterval)\n      this._drainInterval = null\n    }\n\n    while (this.inflight.length) {\n      const req = this.inflight.pop()\n      if (req._timeout) clearTimeout(req._timeout)\n      req._timeout = null\n      req.destroyed = true\n\n      if (req.session) req.session._detach(req)\n\n      this.congestion.recv()\n      this.stats.requests.active--\n\n      req.onerror(suspended ? IO_SUSPENDED() : REQUEST_DESTROYED(), req)\n    }\n\n    await Promise.allSettled([this.serverSocket.close(), this.clientSocket.close()])\n\n    this.networkInterfaces.destroy()\n  }\n\n  async suspend() {\n    this.suspended = true\n    await this._clear(true)\n\n    this.congestion.clear()\n\n    if (this._drainInterval) {\n      clearInterval(this._drainInterval)\n      this._drainInterval = null\n    }\n  }\n\n  async _rebind(binding) {\n    if (binding) await binding\n    if (this._destroying) return this._destroying\n    await this._bindSockets()\n    this.networkInterfaces = this.udx.watchNetworkInterfaces()\n  }\n\n  resume() {\n    this.suspended = false\n    const binding = this._binding\n    this._binding = this._rebind(binding)\n    return this._binding\n  }\n\n  bind() {\n    if (this._binding) return this._binding\n    this._binding = this._bindSockets()\n    return this._binding\n  }\n\n  async _bindSockets() {\n    const serverSocket = this.udx.createSocket()\n\n    const candidatePorts = []\n\n    // Retrying previous port always has precedence\n    if (this._boundServerPort) candidatePorts.push(this._boundServerPort)\n\n    for (let i = this.portRange[0]; i < this.portRange[1]; i++) candidatePorts.push(i)\n\n    for (const port of candidatePorts) {\n      if (serverSocket.bound) break\n\n      try {\n        serverSocket.bind(port, this._host)\n      } catch (err) {\n        if (!this._anyPort) {\n          await serverSocket.close()\n          throw err\n        }\n      }\n    }\n\n    if (!serverSocket.bound) {\n      try {\n        serverSocket.bind(0, this._host)\n      } catch (err) {\n        await serverSocket.close()\n        throw err\n      }\n    }\n\n    const clientSocket = this.udx.createSocket()\n\n    try {\n      clientSocket.bind(this._boundClientPort || 0, this._host)\n    } catch {\n      try {\n        clientSocket.bind(0, this._host)\n      } catch (err) {\n        await serverSocket.close()\n        await clientSocket.close()\n        throw err\n      }\n    }\n\n    this._boundServerPort = serverSocket.address().port\n    this._boundClientPort = clientSocket.address().port\n\n    this.clientSocket = clientSocket\n    this.serverSocket = serverSocket\n\n    this.serverSocket.on('message', this.onmessage.bind(this, this.serverSocket))\n    this.clientSocket.on('message', this.onmessage.bind(this, this.clientSocket))\n\n    if (this._drainInterval === null) {\n      this._drainInterval = setInterval(this._drain.bind(this), 750)\n      if (this._drainInterval.unref) this._drainInterval.unref()\n    }\n\n    for (const req of this.inflight) {\n      if (!req.socket) req.socket = this.firewalled ? this.clientSocket : this.serverSocket\n      req.sent = 0\n      req.send(false)\n    }\n  }\n\n  _drain() {\n    if (this._secrets !== null && --this._rotateSecrets === 0) {\n      this._rotateSecrets = 10\n      const tmp = this._secrets[0]\n      this._secrets[0] = this._secrets[1]\n      this._secrets[1] = tmp\n      sodium.crypto_generichash(tmp, tmp)\n    }\n\n    this.congestion.drain()\n\n    while (!this.congestion.isFull()) {\n      const p = this._pending.shift()\n      if (p === undefined) return\n      p._sendNow()\n    }\n  }\n\n  createRequest(to, token, internal, command, target, value, session, ttl) {\n    if (this._destroying !== null) return null\n\n    if (this._tid === 65536) this._tid = 0\n\n    const tid = this._tid++\n    const socket = this.firewalled ? this.clientSocket : this.serverSocket\n\n    const req = new Request(\n      this,\n      socket,\n      tid,\n      null,\n      to,\n      token,\n      internal,\n      command,\n      target,\n      value,\n      session,\n      ttl || 0\n    )\n    this.inflight.push(req)\n    if (session) session._attach(req)\n\n    if (internal && command < this.stats.commands.length) {\n      this.stats.commands[command].tx++\n    }\n\n    this.stats.requests.active++\n    this.stats.requests.total++\n\n    return req\n  }\n}\n\nclass Request {\n  constructor(io, socket, tid, from, to, token, internal, command, target, value, session, ttl) {\n    this.socket = socket\n    this.tid = tid\n    this.from = from\n    this.to = to\n    this.token = token\n    this.command = command\n    this.target = target\n    this.value = value\n    this.internal = internal\n    this.session = session\n    this.ttl = ttl\n    this.index = -1\n    this.sent = 0\n    this.retries = 3\n    this.destroyed = false\n    this.timeout = 0\n\n    this.oncycle = noop\n    this.onerror = noop\n    this.onresponse = noop\n\n    this._buffer = null\n    this._io = io\n    this._timeout = null\n    this._timestamp = Date.now()\n  }\n\n  static decode(io, socket, from, state) {\n    try {\n      const flags = c.uint.decode(state)\n      const tid = c.uint16.decode(state)\n      const to = peer.ipv4.decode(state)\n      const id = flags & 1 ? c.fixed32.decode(state) : null\n      const token = flags & 2 ? c.fixed32.decode(state) : null\n      const internal = (flags & 4) !== 0\n      const command = c.uint.decode(state)\n      const target = flags & 8 ? c.fixed32.decode(state) : null\n      const value = flags & 16 ? c.buffer.decode(state) : null\n\n      if (id !== null) from.id = validateId(id, from)\n\n      return new Request(\n        io,\n        socket,\n        tid,\n        from,\n        to,\n        token,\n        internal,\n        command,\n        target,\n        value,\n        null,\n        0\n      )\n    } catch {\n      return null\n    }\n  }\n\n  reply(value, opts = {}) {\n    const socket = opts.socket || this.socket\n    const to = opts.to || this.from\n    this._sendReply(0, value || null, opts.token !== false, opts.closerNodes !== false, to, socket)\n  }\n\n  error(code, opts = {}) {\n    const socket = opts.socket || this.socket\n    const to = opts.to || this.from\n    this._sendReply(code, null, opts.token === true, opts.closerNodes !== false, to, socket)\n  }\n\n  relay(value, to, opts) {\n    const socket = (opts && opts.socket) || this.socket\n    const buffer = this._encodeRequest(null, value, to, socket)\n    socket.trySend(buffer, to.port, to.host, this.ttl)\n  }\n\n  send(force = false) {\n    if (this.destroyed) return\n\n    if (this.socket === null) return\n    if (this._buffer === null) {\n      this._buffer = this._encodeRequest(this.token, this.value, this.to, this.socket)\n    }\n\n    if (!force && this._io.congestion.isFull()) {\n      this._io._pending.push(this)\n      return\n    }\n\n    this._sendNow()\n  }\n\n  sendReply(error, value, token, hasCloserNodes) {\n    this._sendReply(error, value, token, hasCloserNodes, this.from, this.socket, null)\n  }\n\n  _sendNow() {\n    if (this.destroyed) return\n    this.sent++\n    this._io.congestion.send()\n    this.socket.trySend(this._buffer, this.to.port, this.to.host, this.ttl)\n    if (this._timeout) clearTimeout(this._timeout)\n    const value =\n      this.timeout || this._io._adt?.get(`${this.to.host}:${this.to.port}`, this.sent) || 1000\n    this._timeout = setTimeout(oncycle, value, this)\n  }\n\n  destroy(err) {\n    if (this.destroyed) return\n    this.destroyed = true\n\n    if (this._timeout) {\n      clearTimeout(this._timeout)\n      this._timeout = null\n    }\n\n    const i = this._io.inflight.indexOf(this)\n    if (i === -1) return\n\n    if (i === this._io.inflight.length - 1) this._io.inflight.pop()\n    else this._io.inflight[i] = this._io.inflight.pop()\n\n    if (this.session) this.session._detach(this)\n\n    this._io.stats.requests.active--\n    this._io.congestion.recv()\n\n    this.onerror(err || REQUEST_DESTROYED(), this)\n  }\n\n  _sendReply(error, value, token, hasCloserNodes, from, socket) {\n    if (socket === null || this.destroyed) return\n\n    const id = this._io.ephemeral === false && socket === this._io.serverSocket\n    const closerNodes =\n      this.target !== null && hasCloserNodes ? this._io.table.closest(this.target) : EMPTY_ARRAY\n    const state = { start: 0, end: 1 + 1 + 6 + 2, buffer: null } // (type | version) + flags + to + tid\n\n    if (id) state.end += 32\n    if (token) state.end += 32\n    if (closerNodes.length > 0) peer.ipv4Array.preencode(state, closerNodes)\n    if (error > 0) c.uint.preencode(state, error)\n    if (value) c.buffer.preencode(state, value)\n\n    state.buffer = b4a.allocUnsafe(state.end)\n    state.buffer[state.start++] = RESPONSE_ID\n    state.buffer[state.start++] =\n      (id ? 1 : 0) |\n      (token ? 2 : 0) |\n      (closerNodes.length > 0 ? 4 : 0) |\n      (error > 0 ? 8 : 0) |\n      (value ? 16 : 0)\n\n    c.uint16.encode(state, this.tid)\n    peer.ipv4.encode(state, from)\n\n    if (id) c.fixed32.encode(state, this._io.table.id)\n    if (token) c.fixed32.encode(state, this._io.token(from, 1))\n    if (closerNodes.length > 0) peer.ipv4Array.encode(state, closerNodes)\n    if (error > 0) c.uint.encode(state, error)\n    if (value) c.buffer.encode(state, value)\n\n    socket.trySend(state.buffer, from.port, from.host, this.ttl)\n  }\n\n  _encodeRequest(token, value, to, socket) {\n    const id = this._io.ephemeral === false && socket === this._io.serverSocket\n    const state = { start: 0, end: 1 + 1 + 6 + 2, buffer: null } // (type | version) + flags + to + tid\n\n    if (id) state.end += 32\n    if (token) state.end += 32\n\n    c.uint.preencode(state, this.command)\n\n    if (this.target) state.end += 32\n    if (value) c.buffer.preencode(state, value)\n\n    state.buffer = b4a.allocUnsafe(state.end)\n    state.buffer[state.start++] = REQUEST_ID\n    state.buffer[state.start++] =\n      (id ? 1 : 0) |\n      (token ? 2 : 0) |\n      (this.internal ? 4 : 0) |\n      (this.target ? 8 : 0) |\n      (value ? 16 : 0)\n\n    c.uint16.encode(state, this.tid)\n    peer.ipv4.encode(state, to)\n\n    if (id) c.fixed32.encode(state, this._io.table.id)\n    if (token) c.fixed32.encode(state, token)\n\n    c.uint.encode(state, this.command)\n\n    if (this.target) c.fixed32.encode(state, this.target)\n    if (value) c.buffer.encode(state, value)\n\n    return state.buffer\n  }\n}\n\nclass CongestionWindow {\n  constructor(maxWindow) {\n    this._i = 0\n    this._total = 0\n    this._window = [0, 0, 0, 0]\n    this._maxWindow = maxWindow\n  }\n\n  clear() {\n    this._i = 0\n    this._total = 0\n    this._window = [0, 0, 0, 0]\n  }\n\n  isFull() {\n    return this._total >= 2 * this._maxWindow || this._window[this._i] >= this._maxWindow\n  }\n\n  recv() {\n    if (this._window[this._i] > 0) {\n      this._window[this._i]--\n      this._total--\n    }\n  }\n\n  send() {\n    this._total++\n    this._window[this._i]++\n  }\n\n  drain() {\n    this._i = (this._i + 1) & 3\n    this._total -= this._window[this._i]\n    this._window[this._i] = 0 // clear oldest\n  }\n}\n\nfunction noop() {}\n\nfunction oncycle(req) {\n  req._timeout = null\n  req.oncycle(req)\n  if (req.sent > req.retries) {\n    req._io.stats.requests.timeouts++\n    req.destroy(REQUEST_TIMEOUT())\n    req._io.ontimeout(req)\n  } else {\n    req._io.stats.requests.retries++\n    req.send()\n  }\n}\n\nfunction decodeReply(from, state) {\n  try {\n    const flags = c.uint.decode(state)\n    const tid = c.uint16.decode(state)\n    const to = peer.ipv4.decode(state)\n    const id = flags & 1 ? c.fixed32.decode(state) : null\n    const token = flags & 2 ? c.fixed32.decode(state) : null\n    const closerNodes = flags & 4 ? peer.ipv4Array.decode(state) : null\n    const error = flags & 8 ? c.uint.decode(state) : 0\n    const value = flags & 16 ? c.buffer.decode(state) : null\n\n    if (id !== null) from.id = validateId(id, from)\n\n    return { tid, rtt: 0, from, to, token, closerNodes, error, value }\n  } catch {\n    return null\n  }\n}\n\nfunction validateId(id, from) {\n  const expected = peer.id(from.host, from.port)\n  return b4a.equals(expected, id) ? expected : null\n}\nconst sodium = require('sodium-universal')\nconst c = require('compact-encoding')\nconst net = require('compact-encoding-net')\nconst b4a = require('b4a')\n\nconst ipv4 = {\n  ...net.ipv4Address,\n  decode(state) {\n    const ip = net.ipv4Address.decode(state)\n    return {\n      id: null, // populated by the callee\n      host: ip.host,\n      port: ip.port\n    }\n  }\n}\n\nmodule.exports = { id, ipv4, ipv4Array: c.array(ipv4) }\n\nfunction id(host, port, out = b4a.allocUnsafeSlow(32)) {\n  const addr = out.subarray(0, 6)\n  ipv4.encode({ start: 0, end: 6, buffer: addr }, { host, port })\n  sodium.crypto_generichash(out, addr)\n  return out\n}\nconst { Readable, getStreamError } = require('streamx')\nconst b4a = require('b4a')\nconst peer = require('./peer')\nconst { DOWN_HINT } = require('./commands')\n\nconst DONE = []\nconst DOWN = []\n\nmodule.exports = class Query extends Readable {\n  constructor(dht, target, internal, command, value, opts = {}) {\n    super()\n\n    dht.stats.queries.total++\n    dht.stats.queries.active++\n\n    this.force = !!opts.force\n    this.dht = dht\n    this.k = this.dht.table.k\n    this.target = target\n    this.internal = internal\n    this.command = command\n    this.value = value\n    this.errors = 0\n    this.successes = 0\n    this.concurrency = opts.concurrency || this.dht.concurrency\n    this.inflight = 0\n    this.map = opts.map || defaultMap\n    this.retries =\n      opts.retries === 0 ? 0 : opts.retries || (this.internal && command === DOWN_HINT ? 3 : 5)\n    this.closestReplies = []\n\n    this._slow = 0\n    this._slowdown = false\n    this._seen = new Map()\n    this._pending = []\n    this._fromTable = false\n    this._commit = opts.commit === true ? autoCommit : opts.commit || null\n    this._commiting = false\n    this._session = opts.session || dht.session()\n    this._autoDestroySession = !opts.session\n    this._onlyClosestNodes = false\n\n    this._onvisitbound = this._onvisit.bind(this)\n    this._onerrorbound = this._onerror.bind(this)\n    this._oncyclebound = this._oncycle.bind(this)\n\n    const nodes = opts.nodes || opts.closestNodes\n    const replies = opts.replies || opts.closestReplies\n\n    // add them reverse as we pop below\n    if (nodes) {\n      for (let i = nodes.length - 1; i >= 0; i--) {\n        const node = nodes[i]\n        this._addPending(\n          {\n            id: node.id || peer.id(node.host, node.port),\n            host: node.host,\n            port: node.port\n          },\n          null\n        )\n      }\n    } else if (replies) {\n      for (let i = replies.length - 1; i >= 0; i--) {\n        this._addPending(replies[i].from, null)\n      }\n    }\n\n    if (opts.onlyClosestNodes) this._onlyClosestNodes = true\n  }\n\n  get closestNodes() {\n    const nodes = new Array(this.closestReplies.length)\n\n    for (let i = 0; i < nodes.length; i++) {\n      nodes[i] = this.closestReplies[i].from\n    }\n\n    return nodes\n  }\n\n  finished() {\n    return new Promise((resolve, reject) => {\n      if (this.destroyed) {\n        const error = getStreamError(this)\n        if (error) reject(error)\n        else resolve()\n        return\n      }\n\n      const self = this\n      let error = null\n\n      this.resume()\n      this.on('error', onerror)\n      this.on('close', onclose)\n\n      function onclose() {\n        self.removeListener('error', onerror)\n        self.removeListener('close', onclose)\n        if (error) reject(error)\n        else resolve()\n      }\n\n      function onerror(err) {\n        error = err\n      }\n    })\n  }\n\n  _addFromTable() {\n    if (this._pending.length >= this.k) return\n    this._fromTable = true\n\n    const closest = this.dht.table.closest(this.target, this.k - this._pending.length)\n\n    for (const node of closest) {\n      this._addPending({ id: node.id, host: node.host, port: node.port }, null)\n    }\n  }\n\n  async _open(cb) {\n    this._addFromTable()\n    if (this._pending.length >= this.k) return cb(null)\n\n    for await (const node of this.dht._resolveBootstrapNodes()) {\n      this._addPending(node, null)\n    }\n\n    cb(null)\n  }\n\n  _isCloser(id) {\n    return (\n      this.closestReplies.length < this.k ||\n      this._compare(id, this.closestReplies[this.closestReplies.length - 1].from.id) < 0\n    )\n  }\n\n  _addPending(node, ref) {\n    if (this._onlyClosestNodes) return false\n\n    const addr = node.host + ':' + node.port\n    const refs = this._seen.get(addr)\n    const isCloser = this._isCloser(node.id)\n\n    if (refs === DONE) {\n      return isCloser\n    }\n\n    if (refs === DOWN) {\n      if (ref) this._downHint(ref, node)\n      return isCloser\n    }\n\n    if (refs) {\n      if (ref !== null) refs.push(ref)\n      return isCloser\n    }\n\n    if (!isCloser) {\n      return false\n    }\n\n    this._seen.set(addr, ref === null ? [] : [ref])\n    this._pending.push(node)\n\n    return true\n  }\n\n  _read(cb) {\n    this._readMore()\n    cb(null)\n  }\n\n  _readMore() {\n    if (this.destroying || this._commiting) return\n\n    const concurrency = (this._slowdown ? 3 : this.concurrency) + this._slow\n\n    while (this.inflight < concurrency && this._pending.length > 0) {\n      const next = this._pending.pop()\n      if (next && next.id && !this._isCloser(next.id)) continue\n      this._visit(next)\n    }\n\n    // if reusing closest nodes, slow down after the first readMore tick to allow\n    // the closest node a chance to reply before going broad to question more\n    if (!this._fromTable && this.successes === 0 && this.errors === 0) {\n      this._slowdown = true\n    }\n\n    if (this._pending.length > 0) return\n\n    // if no inflight OR all the queries we are waiting on are marked as slow and we have a full result.\n    if (\n      this.inflight === 0 ||\n      (this._slow === this.inflight && this.closestReplies.length >= this.k)\n    ) {\n      // if more than 3/4 failed and we only used cached nodes, try again from the routing table\n      if (!this._fromTable && this.successes < this.k / 4) {\n        this._addFromTable()\n        this._readMore()\n        return\n      }\n\n      this._flush()\n    }\n  }\n\n  _flush() {\n    if (this._commiting) return\n    this._commiting = true\n\n    if (this._commit === null) {\n      this.push(null)\n      return\n    }\n\n    const p = []\n    for (const m of this.closestReplies) p.push(this._commit(m, this.dht, this))\n    this._endAfterCommit(p)\n  }\n\n  _endAfterCommit(ps) {\n    if (!ps.length) {\n      this.destroy(new Error('Too few nodes responded'))\n      return\n    }\n\n    const self = this\n\n    let pending = ps.length\n    let success = 0\n\n    for (const p of ps) p.then(ondone, onerror)\n\n    function ondone() {\n      success++\n      if (--pending === 0) self.push(null)\n    }\n\n    function onerror(err) {\n      if (--pending > 0) return\n      if (success) self.push(null)\n      else self.destroy(err)\n    }\n  }\n\n  _dec(req) {\n    if (req.oncycle === noop) {\n      this._slow--\n    } else {\n      req.oncycle = noop\n    }\n    this.inflight--\n  }\n\n  _onvisit(m, req) {\n    this._dec(req)\n\n    const addr = req.to.host + ':' + req.to.port\n    this._seen.set(addr, DONE)\n\n    if (this._commiting) return\n\n    if (m.error === 0) this.successes++\n    else this.errors++\n\n    if (m.error === 0 && m.from.id !== null && this._isCloser(m.from.id)) this._pushClosest(m)\n\n    if (m.closerNodes !== null) {\n      for (const node of m.closerNodes) {\n        node.id = peer.id(node.host, node.port)\n        if (this.dht._filterNode !== null && !this.dht._filterNode(node)) continue\n        if (b4a.equals(node.id, this.dht.table.id)) continue\n        // TODO: we could continue here instead of breaking to ensure that one of the nodes in the closer list\n        // is later marked as DOWN that we gossip that back\n        if (!this._addPending(node, m.from)) break\n      }\n    }\n\n    if (!this._fromTable && this.successes + this.errors >= this.concurrency) {\n      this._slowdown = false\n    }\n\n    if (m.error !== 0) {\n      this._readMore()\n      return\n    }\n\n    const data = this.map(m)\n    if (!data || this.push(data) !== false) {\n      this._readMore()\n    }\n  }\n\n  _onerror(err, req) {\n    const addr = req.to.host + ':' + req.to.port\n    const refs = this._seen.get(addr)\n\n    if (err.code === 'REQUEST_TIMEOUT') {\n      this._seen.set(addr, DOWN)\n      for (const node of refs) this._downHint(node, req.to)\n    }\n\n    this._dec(req)\n    this.errors++\n    this._readMore()\n  }\n\n  _oncycle(req) {\n    req.oncycle = noop\n    this._slow++\n    this._readMore()\n  }\n\n  _downHint(node, down) {\n    // Check rate limit\n    if (\n      this.dht._downHintsRateLimit !== -1 &&\n      this.dht._downHintsSentPerTick >= this.dht._downHintsRateLimit\n    ) {\n      return null\n    }\n\n    this.dht._downHintsSentPerTick++\n\n    const state = { start: 0, end: 6, buffer: b4a.allocUnsafe(6) }\n    peer.ipv4.encode(state, down)\n    this.dht._request(node, false, true, DOWN_HINT, null, state.buffer, this._session, noop, noop)\n  }\n\n  _pushClosest(m) {\n    this.closestReplies.push(m)\n    for (let i = this.closestReplies.length - 2; i >= 0; i--) {\n      const prev = this.closestReplies[i]\n      const cmp = this._compare(prev.from.id, m.from.id)\n      // if sorted, done!\n      if (cmp < 0) break\n      // if dup, splice it out (rare)\n      if (cmp === 0) {\n        this.closestReplies.splice(i + 1, 1)\n        break\n      }\n      // swap and continue down\n      this.closestReplies[i + 1] = prev\n      this.closestReplies[i] = m\n    }\n    if (this.closestReplies.length > this.k) this.closestReplies.pop()\n  }\n\n  _compare(a, b) {\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] === b[i]) continue\n      const t = this.target[i]\n      return (t ^ a[i]) - (t ^ b[i])\n    }\n    return 0\n  }\n\n  _visit(to) {\n    this.inflight++\n\n    const req = this.dht._request(\n      to,\n      this.force,\n      this.internal,\n      this.command,\n      this.target,\n      this.value,\n      this._session,\n      this._onvisitbound,\n      this._onerrorbound\n    )\n    if (req === null) {\n      this.destroy(new Error('Node was destroyed'))\n      return\n    }\n    req.retries = this.retries\n    req.oncycle = this._oncyclebound\n    if (this.force) req.retries = 0\n  }\n\n  _destroy(cb) {\n    this.dht.stats.queries.active--\n    if (this._autoDestroySession) this._session.destroy()\n    cb(null)\n  }\n}\n\nfunction autoCommit(reply, dht, query) {\n  if (!reply.token) return Promise.reject(new Error('No token received for closest node'))\n  return dht.request(\n    {\n      token: reply.token,\n      target: query.target,\n      command: query.command,\n      value: query.value\n    },\n    reply.from\n  )\n}\n\nfunction defaultMap(m) {\n  return m\n}\n\nfunction noop() {}\nmodule.exports = class Session {\n  constructor(dht) {\n    this.dht = dht\n    this.inflight = []\n  }\n\n  _attach(req) {\n    req.index = this.inflight.push(req) - 1\n  }\n\n  _detach(req) {\n    const i = req.index\n    if (i === -1) return\n    req.index = -1\n\n    if (i === this.inflight.length - 1) this.inflight.pop()\n    else {\n      const req = (this.inflight[i] = this.inflight.pop())\n      req.index = i\n    }\n  }\n\n  query({ target, command, value }, opts = {}) {\n    return this.dht.query({ target, command, value }, { ...opts, session: this })\n  }\n\n  request({ token, command, target, value }, { host, port }, opts = {}) {\n    return this.dht.request(\n      { token, command, target, value },\n      { host, port },\n      { ...opts, session: this }\n    )\n  }\n\n  ping({ host, port }, opts = {}) {\n    return this.dht.ping({ host, port }, { ...opts, session: this })\n  }\n\n  destroy(err) {\n    while (this.inflight.length) {\n      const req = this.inflight[0]\n      // prevent destroyed requests from contributing to congestion counts\n      this.dht.io.congestion.recv()\n      req.destroy(err)\n    }\n  }\n}\n{\n  \"name\": \"dht-rpc\",\n  \"version\": \"6.26.0\",\n  \"description\": \"Make RPC calls over a Kademlia based DHT\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"lib/*.js\"\n  ],\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"dependencies\": {\n    \"adaptive-timeout\": \"^1.0.1\",\n    \"b4a\": \"^1.6.1\",\n    \"bare-events\": \"^2.2.0\",\n    \"compact-encoding\": \"^2.11.0\",\n    \"compact-encoding-net\": \"^1.2.0\",\n    \"fast-fifo\": \"^1.1.0\",\n    \"kademlia-routing-table\": \"^1.0.1\",\n    \"nat-sampler\": \"^1.0.1\",\n    \"sodium-universal\": \"^5.0.0\",\n    \"streamx\": \"^2.13.2\",\n    \"time-ordered-set\": \"^2.0.0\",\n    \"udx-native\": \"^1.5.3\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.0.0\",\n    \"lunte\": \"^1.3.0\",\n    \"prettier\": \"^3.6.2\",\n    \"prettier-config-holepunch\": \"^2.0.0\",\n    \"test-suspend\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"format\": \"prettier --write .\",\n    \"test\": \"npm run test:node && npm run test:bare\",\n    \"test:bare\": \"brittle-bare --coverage test.js\",\n    \"lint\": \"prettier --check . && lunte\",\n    \"test:node\": \"brittle-node --coverage test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/dht-rpc.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/dht-rpc/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/dht-rpc\"\n}\nmodule.exports = require('bare-events')\n{\n  \"name\": \"events-universal\",\n  \"version\": \"1.0.1\",\n  \"description\": \"Universal wrapper for the Node.js events module\",\n  \"exports\": {\n    \"./package\": \"./package.json\",\n    \".\": {\n      \"bare\": \"./bare.js\",\n      \"react-native\": \"./react-native.js\",\n      \"default\": \"./default.js\"\n    }\n  },\n  \"files\": [\n    \"index.js\",\n    \"default.js\",\n    \"bare.js\",\n    \"react-native.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"prettier . --check\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/events-universal.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/events-universal/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/events-universal#readme\",\n  \"dependencies\": {\n    \"bare-events\": \"^2.7.0\"\n  },\n  \"devDependencies\": {\n    \"prettier\": \"^3.4.2\",\n    \"prettier-config-holepunch\": \"^1.0.0\"\n  }\n}\nmodule.exports = class FixedFIFO {\n  constructor (hwm) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two')\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  clear () {\n    this.top = this.btm = 0\n    this.next = null\n    this.buffer.fill(undefined)\n  }\n\n  push (data) {\n    if (this.buffer[this.top] !== undefined) return false\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n    return true\n  }\n\n  shift () {\n    const last = this.buffer[this.btm]\n    if (last === undefined) return undefined\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  peek () {\n    return this.buffer[this.btm]\n  }\n\n  isEmpty () {\n    return this.buffer[this.btm] === undefined\n  }\n}\nconst FixedFIFO = require('./fixed-size')\n\nmodule.exports = class FastFIFO {\n  constructor (hwm) {\n    this.hwm = hwm || 16\n    this.head = new FixedFIFO(this.hwm)\n    this.tail = this.head\n    this.length = 0\n  }\n\n  clear () {\n    this.head = this.tail\n    this.head.clear()\n    this.length = 0\n  }\n\n  push (val) {\n    this.length++\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift () {\n    if (this.length !== 0) this.length--\n    const val = this.tail.shift()\n    if (val === undefined && this.tail.next) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      return this.tail.shift()\n    }\n\n    return val\n  }\n\n  peek () {\n    const val = this.tail.peek()\n    if (val === undefined && this.tail.next) return this.tail.next.peek()\n    return val\n  }\n\n  isEmpty () {\n    return this.length === 0\n  }\n}\n{\n  \"name\": \"fast-fifo\",\n  \"version\": \"1.3.2\",\n  \"description\": \"A fast fifo implementation similar to the one powering nextTick in Node.js core\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"./index.js\",\n    \"./fixed-size.js\"\n  ],\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"standard\": \"^17.1.0\",\n    \"brittle\": \"^3.3.2\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/fast-fifo.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/fast-fifo/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/fast-fifo\"\n}\nconst sodium = require('sodium-universal')\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\n\n// https://en.wikipedia.org/wiki/Merkle_tree#Second_preimage_attack\nconst LEAF_TYPE = b4a.from([0])\nconst PARENT_TYPE = b4a.from([1])\nconst ROOT_TYPE = b4a.from([2])\n\nconst HYPERCORE = b4a.from('hypercore')\n\nexports.keyPair = function (seed) {\n  // key pairs might stay around for a while, so better not to use a default slab to avoid retaining it completely\n  const slab = b4a.allocUnsafeSlow(sodium.crypto_sign_PUBLICKEYBYTES + sodium.crypto_sign_SECRETKEYBYTES)\n  const publicKey = slab.subarray(0, sodium.crypto_sign_PUBLICKEYBYTES)\n  const secretKey = slab.subarray(sodium.crypto_sign_PUBLICKEYBYTES)\n\n  if (seed) sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed)\n  else sodium.crypto_sign_keypair(publicKey, secretKey)\n\n  return {\n    publicKey,\n    secretKey\n  }\n}\n\nexports.validateKeyPair = function (keyPair) {\n  const pk = b4a.allocUnsafe(sodium.crypto_sign_PUBLICKEYBYTES)\n  sodium.crypto_sign_ed25519_sk_to_pk(pk, keyPair.secretKey)\n  return b4a.equals(pk, keyPair.publicKey)\n}\n\nexports.sign = function (message, secretKey) {\n  // Dedicated slab for the signature, to avoid retaining unneeded mem and for security\n  const signature = b4a.allocUnsafeSlow(sodium.crypto_sign_BYTES)\n  sodium.crypto_sign_detached(signature, message, secretKey)\n  return signature\n}\n\nexports.verify = function (message, signature, publicKey) {\n  if (signature.byteLength !== sodium.crypto_sign_BYTES) return false\n  if (publicKey.byteLength !== sodium.crypto_sign_PUBLICKEYBYTES) return false\n  return sodium.crypto_sign_verify_detached(signature, message, publicKey)\n}\n\nexports.encrypt = function (message, publicKey) {\n  const ciphertext = b4a.alloc(message.byteLength + sodium.crypto_box_SEALBYTES)\n  sodium.crypto_box_seal(ciphertext, message, publicKey)\n  return ciphertext\n}\n\nexports.decrypt = function (ciphertext, keyPair) {\n  if (ciphertext.byteLength < sodium.crypto_box_SEALBYTES) return null\n\n  const plaintext = b4a.alloc(ciphertext.byteLength - sodium.crypto_box_SEALBYTES)\n\n  if (!sodium.crypto_box_seal_open(plaintext, ciphertext, keyPair.publicKey, keyPair.secretKey)) {\n    return null\n  }\n\n  return plaintext\n}\n\nexports.encryptionKeyPair = function (seed) {\n  const publicKey = b4a.alloc(sodium.crypto_box_PUBLICKEYBYTES)\n  const secretKey = b4a.alloc(sodium.crypto_box_SECRETKEYBYTES)\n\n  if (seed) {\n    sodium.crypto_box_seed_keypair(publicKey, secretKey, seed)\n  } else {\n    sodium.crypto_box_keypair(publicKey, secretKey)\n  }\n\n  return {\n    publicKey,\n    secretKey\n  }\n}\n\nexports.data = function (data) {\n  const out = b4a.allocUnsafe(32)\n\n  sodium.crypto_generichash_batch(out, [\n    LEAF_TYPE,\n    c.encode(c.uint64, data.byteLength),\n    data\n  ])\n\n  return out\n}\n\nexports.parent = function (a, b) {\n  if (a.index > b.index) {\n    const tmp = a\n    a = b\n    b = tmp\n  }\n\n  const out = b4a.allocUnsafe(32)\n\n  sodium.crypto_generichash_batch(out, [\n    PARENT_TYPE,\n    c.encode(c.uint64, a.size + b.size),\n    a.hash,\n    b.hash\n  ])\n\n  return out\n}\n\nexports.tree = function (roots, out) {\n  const buffers = new Array(3 * roots.length + 1)\n  let j = 0\n\n  buffers[j++] = ROOT_TYPE\n\n  for (let i = 0; i < roots.length; i++) {\n    const r = roots[i]\n    buffers[j++] = r.hash\n    buffers[j++] = c.encode(c.uint64, r.index)\n    buffers[j++] = c.encode(c.uint64, r.size)\n  }\n\n  if (!out) out = b4a.allocUnsafe(32)\n  sodium.crypto_generichash_batch(out, buffers)\n  return out\n}\n\nexports.hash = function (data, out) {\n  if (!out) out = b4a.allocUnsafe(32)\n  if (!Array.isArray(data)) data = [data]\n\n  sodium.crypto_generichash_batch(out, data)\n\n  return out\n}\n\nexports.randomBytes = function (n) {\n  const buf = b4a.allocUnsafe(n)\n  sodium.randombytes_buf(buf)\n  return buf\n}\n\nexports.discoveryKey = function (key) {\n  if (!key || key.byteLength !== 32) throw new Error('Must pass a 32 byte buffer')\n  // Discovery keys might stay around for a while, so better not to use slab memory (for better gc)\n  const digest = b4a.allocUnsafeSlow(32)\n  sodium.crypto_generichash(digest, HYPERCORE, key)\n  return digest\n}\n\nif (sodium.sodium_free) {\n  exports.free = function (secureBuf) {\n    if (secureBuf.secure) sodium.sodium_free(secureBuf)\n  }\n} else {\n  exports.free = function () {}\n}\n\nexports.namespace = function (name, count) {\n  const ids = typeof count === 'number' ? range(count) : count\n\n  // Namespaces are long-lived, so better to use a dedicated slab\n  const buf = b4a.allocUnsafeSlow(32 * ids.length)\n\n  const list = new Array(ids.length)\n\n  // ns is emhemeral, so default slab\n  const ns = b4a.allocUnsafe(33)\n  sodium.crypto_generichash(ns.subarray(0, 32), typeof name === 'string' ? b4a.from(name) : name)\n\n  for (let i = 0; i < list.length; i++) {\n    list[i] = buf.subarray(32 * i, 32 * i + 32)\n    ns[32] = ids[i]\n    sodium.crypto_generichash(list[i], ns)\n  }\n\n  return list\n}\n\nfunction range (count) {\n  const arr = new Array(count)\n  for (let i = 0; i < count; i++) arr[i] = i\n  return arr\n}\n{\n  \"name\": \"hypercore-crypto\",\n  \"version\": \"3.6.1\",\n  \"description\": \"The crypto primitives used in hypercore, extracted into a separate module\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"dependencies\": {\n    \"b4a\": \"^1.6.6\",\n    \"compact-encoding\": \"^2.15.0\",\n    \"sodium-universal\": \"^5.0.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.5.0\",\n    \"standard\": \"^17.1.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/hypercore-crypto.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/hypercore-crypto/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/hypercore-crypto\"\n}\nconst z32 = require('z32')\nconst b4a = require('b4a')\n\nmodule.exports = {\n  encode,\n  decode,\n  normalize,\n  isValid\n}\n\nfunction encode (key) {\n  if (!b4a.isBuffer(key)) throw new Error('Key must be a Buffer')\n  if (key.byteLength !== 32) throw new Error('Key must be 32-bytes long')\n  return z32.encode(key)\n}\n\nfunction decode (id) {\n  if (b4a.isBuffer(id)) {\n    if (id.byteLength !== 32) throw new Error('ID must be 32-bytes long')\n    return id\n  }\n  if (typeof id === 'string') {\n    if (id.startsWith('pear://')) id = id.slice(7).split('/')[0]\n    if (id.length === 52) return z32.decode(id)\n    if (id.length === 64) {\n      const buf = b4a.from(id, 'hex')\n      if (buf.byteLength === 32) return buf\n    }\n  }\n  throw new Error('Invalid Hypercore key')\n}\n\nfunction normalize (any) {\n  return encode(decode(any))\n}\n\nfunction isValid (any) {\n  try {\n    decode(any)\n    return true\n  } catch {\n    return false\n  }\n}\n{\n  \"name\": \"hypercore-id-encoding\",\n  \"version\": \"1.3.0\",\n  \"description\": \"Convert Hypercore keys to/from z-base32 or hex\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"files\": [\n    \"index.js\"\n  ],\n  \"dependencies\": {\n    \"b4a\": \"^1.5.3\",\n    \"z32\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.1.1\",\n    \"hypercore\": \"^10.0.0\",\n    \"random-access-memory\": \"^6.0.0\",\n    \"standard\": \"^17.1.0\"\n  },\n  \"license\": \"Apache-2.0\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/hypercore-id-encoding.git\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/hypercore-id-encoding/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/hypercore-id-encoding#readme\"\n}\nconst DHT = require('dht-rpc')\nconst sodium = require('sodium-universal')\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\nconst safetyCatch = require('safety-catch')\nconst m = require('./lib/messages')\nconst SocketPool = require('./lib/socket-pool')\nconst Persistent = require('./lib/persistent')\nconst Router = require('./lib/router')\nconst Cache = require('xache')\nconst Server = require('./lib/server')\nconst connect = require('./lib/connect')\nconst { FIREWALL, BOOTSTRAP_NODES, KNOWN_NODES, COMMANDS } = require('./lib/constants')\nconst { hash, createKeyPair } = require('./lib/crypto')\nconst { decode } = require('hypercore-id-encoding')\nconst RawStreamSet = require('./lib/raw-stream-set')\nconst ConnectionPool = require('./lib/connection-pool')\nconst { STREAM_NOT_CONNECTED } = require('./lib/errors')\n\nconst DEFAULTS = {\n  ...DHT.DEFAULTS,\n  connectionKeepAlive: 5000,\n  randomPunchInterval: 20000\n}\n\nclass HyperDHT extends DHT {\n  constructor(opts = {}) {\n    const port = opts.port || 49737\n    const bootstrap = opts.bootstrap || BOOTSTRAP_NODES\n    const nodes = opts.nodes || KNOWN_NODES\n\n    super({ ...opts, port, bootstrap, nodes, filterNode })\n\n    const { router, relayAddresses, persistent } = defaultCacheOpts(opts)\n\n    this.defaultKeyPair = opts.keyPair || createKeyPair(opts.seed)\n    this.listening = new Set()\n    this.connectionKeepAlive =\n      opts.connectionKeepAlive === false\n        ? 0\n        : opts.connectionKeepAlive || DEFAULTS.connectionKeepAlive\n\n    // stats is inherited from dht-rpc so fwd the ones from there\n    this.stats = {\n      punches: { consistent: 0, random: 0, open: 0 },\n      relaying: { attempts: 0, successes: 0, aborts: 0 },\n      ...this.stats\n    }\n    this.rawStreams = new RawStreamSet(this)\n\n    this._router = new Router(this, router)\n    this._socketPool = new SocketPool(this, opts.host || '0.0.0.0')\n    this._persistent = null\n    this._validatedLocalAddresses = new Map()\n    this._relayAddressesCache = new Cache(relayAddresses)\n\n    this._deferRandomPunch = !!opts.deferRandomPunch\n    this._lastRandomPunch = this._deferRandomPunch ? Date.now() : 0\n    this._connectable = true\n    this._randomPunchInterval = opts.randomPunchInterval || DEFAULTS.randomPunchInterval // min 20s between random punches...\n    this._randomPunches = 0\n    this._randomPunchLimit = 1 // set to one for extra safety for now\n\n    this.once('persistent', () => {\n      this._persistent = new Persistent(this, persistent)\n    })\n\n    this.on('network-change', () => {\n      for (const server of this.listening) server.refresh()\n    })\n\n    this.on('network-update', () => {\n      if (!this.online) return\n      for (const server of this.listening) server.notifyOnline()\n    })\n  }\n\n  static DEFAULTS = DEFAULTS\n\n  connect(remotePublicKey, opts) {\n    return connect(this, decode(remotePublicKey), opts)\n  }\n\n  createServer(opts, onconnection) {\n    if (typeof opts === 'function') return this.createServer({}, opts)\n    if (opts && opts.onconnection) onconnection = opts.onconnection\n    const s = new Server(this, opts)\n    if (onconnection) s.on('connection', onconnection)\n    return s\n  }\n\n  pool() {\n    return new ConnectionPool(this)\n  }\n\n  async resume({ log = noop } = {}) {\n    if (this._deferRandomPunch) this._lastRandomPunch = Date.now()\n    await super.resume({ log })\n    const resuming = []\n    for (const server of this.listening) resuming.push(server.resume())\n    log('Resuming hyperdht servers')\n    await Promise.allSettled(resuming)\n    log('Done, hyperdht fully resumed')\n  }\n\n  async suspend({ log = noop } = {}) {\n    this._connectable = false // just so nothing gets connected during suspension\n    const suspending = []\n    for (const server of this.listening) suspending.push(server.suspend())\n    log('Suspending all hyperdht servers')\n    await Promise.allSettled(suspending)\n    log('Done, clearing all raw streams')\n    await this.rawStreams.clear()\n    log('Done, suspending dht-rpc')\n    await super.suspend({ log })\n    log('Done, clearing raw streams again')\n    await this.rawStreams.clear()\n    log('Done, hyperdht fully suspended')\n    this._connectable = true\n  }\n\n  async destroy({ force = false } = {}) {\n    if (!force) {\n      const closing = []\n      for (const server of this.listening) closing.push(server.close())\n      await Promise.allSettled(closing)\n    }\n    this._router.destroy()\n    if (this._persistent) this._persistent.destroy()\n    await this.rawStreams.clear()\n    await this._socketPool.destroy()\n    await super.destroy()\n  }\n\n  async validateLocalAddresses(addresses) {\n    const list = []\n    const socks = []\n    const waiting = []\n\n    for (const addr of addresses) {\n      const { host } = addr\n\n      if (this._validatedLocalAddresses.has(host)) {\n        if (await this._validatedLocalAddresses.get(host)) {\n          list.push(addr)\n        }\n        continue\n      }\n\n      const sock = this.udx.createSocket()\n      try {\n        sock.bind(0, host)\n      } catch {\n        this._validatedLocalAddresses.set(host, Promise.resolve(false))\n        continue\n      }\n\n      socks.push(sock)\n\n      // semi terrible heuristic until we proper fix local connections by racing them to the remote...\n      const promise = new Promise((resolve) => {\n        sock.on('message', () => resolve(true))\n        setTimeout(() => resolve(false), 500)\n        sock.trySend(b4a.alloc(1), sock.address().port, addr.host)\n      })\n\n      this._validatedLocalAddresses.set(host, promise)\n      waiting.push(addr)\n    }\n\n    for (const addr of waiting) {\n      const { host } = addr\n      if (this._validatedLocalAddresses.has(host)) {\n        if (await this._validatedLocalAddresses.get(host)) {\n          list.push(addr)\n        }\n        continue\n      }\n    }\n\n    for (const sock of socks) await sock.close()\n\n    return list\n  }\n\n  findPeer(publicKey, opts = {}) {\n    const target = opts.hash === false ? publicKey : hash(publicKey)\n    opts = { ...opts, map: mapFindPeer }\n    return this.query({ target, command: COMMANDS.FIND_PEER, value: null }, opts)\n  }\n\n  lookup(target, opts = {}) {\n    opts = { ...opts, map: mapLookup }\n    return this.query({ target, command: COMMANDS.LOOKUP, value: null }, opts)\n  }\n\n  lookupAndUnannounce(target, keyPair, opts = {}) {\n    const unannounces = []\n    const dht = this\n    const userCommit = opts.commit || noop\n    const signUnannounce = opts.signUnannounce || Persistent.signUnannounce\n\n    if (this._persistent !== null) {\n      // unlink self\n      this._persistent.unannounce(target, keyPair.publicKey)\n    }\n\n    opts = { ...opts, map, commit }\n    return this.query({ target, command: COMMANDS.LOOKUP, value: null }, opts)\n\n    async function commit(reply, dht, query) {\n      await Promise.all(unannounces) // can never fail, caught below\n      return userCommit(reply, dht, query)\n    }\n\n    function map(reply) {\n      const data = mapLookup(reply)\n\n      if (!data || !data.token) return data\n\n      let found = data.peers.length >= 20\n      for (let i = 0; !found && i < data.peers.length; i++) {\n        found = b4a.equals(data.peers[i].publicKey, keyPair.publicKey)\n      }\n\n      if (!found) return data\n\n      if (!data.from.id) return data\n\n      unannounces.push(\n        dht\n          ._requestUnannounce(keyPair, dht, target, data.token, data.from, signUnannounce)\n          .catch(safetyCatch)\n      )\n\n      return data\n    }\n  }\n\n  unannounce(target, keyPair, opts = {}) {\n    return this.lookupAndUnannounce(target, keyPair, opts).finished()\n  }\n\n  announce(target, keyPair, relayAddresses, opts = {}) {\n    const signAnnounce = opts.signAnnounce || Persistent.signAnnounce\n    const bump = opts.bump || 0\n\n    opts = { ...opts, commit }\n\n    return opts.clear ? this.lookupAndUnannounce(target, keyPair, opts) : this.lookup(target, opts)\n\n    function commit(reply, dht) {\n      return dht._requestAnnounce(\n        keyPair,\n        dht,\n        target,\n        reply.token,\n        reply.from,\n        relayAddresses,\n        signAnnounce,\n        bump\n      )\n    }\n  }\n\n  async immutableGet(target, opts = {}) {\n    opts = { ...opts, map: mapImmutable }\n\n    const query = this.query({ target, command: COMMANDS.IMMUTABLE_GET, value: null }, opts)\n    const check = b4a.allocUnsafe(32)\n\n    for await (const node of query) {\n      const { value } = node\n      sodium.crypto_generichash(check, value)\n      if (b4a.equals(check, target)) return node\n    }\n\n    return null\n  }\n\n  async immutablePut(value, opts = {}) {\n    const target = b4a.allocUnsafe(32)\n    sodium.crypto_generichash(target, value)\n\n    opts = {\n      ...opts,\n      map: mapImmutable,\n      commit(reply, dht) {\n        return dht.request(\n          { token: reply.token, target, command: COMMANDS.IMMUTABLE_PUT, value },\n          reply.from\n        )\n      }\n    }\n\n    const query = this.query({ target, command: COMMANDS.IMMUTABLE_GET, value: null }, opts)\n    await query.finished()\n\n    return { hash: target, closestNodes: query.closestNodes }\n  }\n\n  async mutableGet(publicKey, opts = {}) {\n    let refresh = opts.refresh || null\n    let signed = null\n    let result = null\n\n    opts = { ...opts, map: mapMutable, commit: refresh ? commit : null }\n\n    const target = b4a.allocUnsafe(32)\n    sodium.crypto_generichash(target, publicKey)\n\n    const userSeq = opts.seq || 0\n    const query = this.query(\n      { target, command: COMMANDS.MUTABLE_GET, value: c.encode(c.uint, userSeq) },\n      opts\n    )\n    const latest = opts.latest !== false\n\n    for await (const node of query) {\n      if (result && node.seq <= result.seq) continue\n      if (\n        node.seq < userSeq ||\n        !Persistent.verifyMutable(node.signature, node.seq, node.value, publicKey)\n      )\n        continue\n      if (!latest) return node\n      if (!result || node.seq > result.seq) result = node\n    }\n\n    return result\n\n    function commit(reply, dht) {\n      if (!signed && result && refresh) {\n        if (refresh(result)) {\n          signed = c.encode(m.mutablePutRequest, {\n            publicKey,\n            seq: result.seq,\n            value: result.value,\n            signature: result.signature\n          })\n        } else {\n          refresh = null\n        }\n      }\n\n      return signed\n        ? dht.request(\n            { token: reply.token, target, command: COMMANDS.MUTABLE_PUT, value: signed },\n            reply.from\n          )\n        : Promise.resolve(null)\n    }\n  }\n\n  async mutablePut(keyPair, value, opts = {}) {\n    const signMutable = opts.signMutable || Persistent.signMutable\n\n    const target = b4a.allocUnsafe(32)\n    sodium.crypto_generichash(target, keyPair.publicKey)\n\n    const seq = opts.seq || 0\n    const signature = await signMutable(seq, value, keyPair)\n\n    const signed = c.encode(m.mutablePutRequest, {\n      publicKey: keyPair.publicKey,\n      seq,\n      value,\n      signature\n    })\n\n    opts = {\n      ...opts,\n      map: mapMutable,\n      commit(reply, dht) {\n        return dht.request(\n          { token: reply.token, target, command: COMMANDS.MUTABLE_PUT, value: signed },\n          reply.from\n        )\n      }\n    }\n\n    // use seq = 0, for the query part here, as we don't care about the actual values\n    const query = this.query(\n      { target, command: COMMANDS.MUTABLE_GET, value: c.encode(c.uint, 0) },\n      opts\n    )\n    await query.finished()\n\n    return { publicKey: keyPair.publicKey, closestNodes: query.closestNodes, seq, signature }\n  }\n\n  onrequest(req) {\n    switch (req.command) {\n      case COMMANDS.PEER_HANDSHAKE: {\n        this._router.onpeerhandshake(req)\n        return true\n      }\n      case COMMANDS.PEER_HOLEPUNCH: {\n        this._router.onpeerholepunch(req)\n        return true\n      }\n    }\n\n    if (this._persistent === null) return false\n\n    switch (req.command) {\n      case COMMANDS.FIND_PEER: {\n        this._persistent.onfindpeer(req)\n        return true\n      }\n      case COMMANDS.LOOKUP: {\n        this._persistent.onlookup(req)\n        return true\n      }\n      case COMMANDS.ANNOUNCE: {\n        this._persistent.onannounce(req)\n        return true\n      }\n      case COMMANDS.UNANNOUNCE: {\n        this._persistent.onunannounce(req)\n        return true\n      }\n      case COMMANDS.MUTABLE_PUT: {\n        this._persistent.onmutableput(req)\n        return true\n      }\n      case COMMANDS.MUTABLE_GET: {\n        this._persistent.onmutableget(req)\n        return true\n      }\n      case COMMANDS.IMMUTABLE_PUT: {\n        this._persistent.onimmutableput(req)\n        return true\n      }\n      case COMMANDS.IMMUTABLE_GET: {\n        this._persistent.onimmutableget(req)\n        return true\n      }\n    }\n\n    return false\n  }\n\n  static keyPair(seed) {\n    return createKeyPair(seed)\n  }\n\n  static hash(data) {\n    return hash(data)\n  }\n\n  static connectRawStream(encryptedStream, rawStream, remoteId) {\n    const stream = encryptedStream.rawStream\n\n    if (!stream.connected) throw STREAM_NOT_CONNECTED()\n\n    rawStream.connect(stream.socket, remoteId, stream.remotePort, stream.remoteHost)\n  }\n\n  createRawStream(opts) {\n    return this.rawStreams.add(opts)\n  }\n\n  async _requestAnnounce(keyPair, dht, target, token, from, relayAddresses, sign, bump) {\n    const ann = {\n      peer: {\n        publicKey: keyPair.publicKey,\n        relayAddresses: relayAddresses || []\n      },\n      refresh: null,\n      signature: null,\n      bump\n    }\n\n    ann.signature = await sign(target, token, from.id, ann, keyPair)\n\n    const value = c.encode(m.announce, ann)\n\n    return dht.request(\n      {\n        token,\n        target,\n        command: COMMANDS.ANNOUNCE,\n        value\n      },\n      from\n    )\n  }\n\n  async _requestUnannounce(keyPair, dht, target, token, from, sign) {\n    const unann = {\n      peer: {\n        publicKey: keyPair.publicKey,\n        relayAddresses: []\n      },\n      signature: null\n    }\n\n    unann.signature = await sign(target, token, from.id, unann, keyPair)\n\n    const value = c.encode(m.announce, unann)\n\n    return dht.request(\n      {\n        token,\n        target,\n        command: COMMANDS.UNANNOUNCE,\n        value\n      },\n      from\n    )\n  }\n}\n\nHyperDHT.BOOTSTRAP = BOOTSTRAP_NODES\nHyperDHT.FIREWALL = FIREWALL\n\nmodule.exports = HyperDHT\n\nfunction mapLookup(node) {\n  if (!node.value) return null\n\n  const l = c.decode(m.lookupRawReply, node.value)\n\n  try {\n    return {\n      token: node.token,\n      from: node.from,\n      to: node.to,\n      peers: l.peers,\n      bump: l.bump\n    }\n  } catch {\n    return null\n  }\n}\n\nfunction mapFindPeer(node) {\n  if (!node.value) return null\n\n  try {\n    return {\n      token: node.token,\n      from: node.from,\n      to: node.to,\n      peer: c.decode(m.peer, node.value)\n    }\n  } catch {\n    return null\n  }\n}\n\nfunction mapImmutable(node) {\n  if (!node.value) return null\n\n  return {\n    token: node.token,\n    from: node.from,\n    to: node.to,\n    value: node.value\n  }\n}\n\nfunction mapMutable(node) {\n  if (!node.value) return null\n\n  try {\n    const { seq, value, signature } = c.decode(m.mutableGetResponse, node.value)\n\n    return {\n      token: node.token,\n      from: node.from,\n      to: node.to,\n      seq,\n      value,\n      signature\n    }\n  } catch {\n    return null\n  }\n}\n\nfunction noop() {}\n\nfunction filterNode(node) {\n  // always skip these testnet nodes that got mixed in by accident, until they get updated\n  return (\n    !(node.port === 49738 && (node.host === '134.209.28.98' || node.host === '167.99.142.185')) &&\n    !(node.port === 9400 && node.host === '35.233.47.252') &&\n    !(node.host === '150.136.142.116')\n  )\n}\n\nconst defaultMaxSize = 65536\nconst defaultMaxAge = 20 * 60 * 1000 // 20 minutes\n\nfunction defaultCacheOpts(opts) {\n  const maxSize = opts.maxSize || defaultMaxSize\n  const maxAge = opts.maxAge || defaultMaxAge\n\n  return {\n    router: {\n      forwards: { maxSize, maxAge }\n    },\n    relayAddresses: { maxSize: Math.min(maxSize, 512), maxAge: 0 },\n    persistent: {\n      records: { maxSize, maxAge },\n      refreshes: { maxSize, maxAge },\n      mutables: {\n        maxSize: (maxSize / 2) | 0,\n        maxAge: opts.maxAge || 48 * 60 * 60 * 1000 // 48 hours\n      },\n      immutables: {\n        maxSize: (maxSize / 2) | 0,\n        maxAge: opts.maxAge || 48 * 60 * 60 * 1000 // 48 hours\n      },\n      bumps: { maxSize, maxAge }\n    }\n  }\n}\nconst safetyCatch = require('safety-catch')\nconst c = require('compact-encoding')\nconst Signal = require('signal-promise')\nconst { encodeUnslab } = require('./encode')\nconst Sleeper = require('./sleeper')\nconst m = require('./messages')\nconst Persistent = require('./persistent')\nconst { COMMANDS } = require('./constants')\n\nconst MIN_ACTIVE = 3\n\nmodule.exports = class Announcer {\n  constructor(dht, keyPair, target, opts = {}) {\n    this.dht = dht\n    this.keyPair = keyPair\n    this.target = target\n    this.relays = []\n    this.relayAddresses = []\n    this.stopped = false\n    this.suspended = false\n    this.record = encodeUnslab(m.peer, { publicKey: keyPair.publicKey, relayAddresses: [] })\n    this.online = new Signal()\n\n    this._refreshing = false\n    this._closestNodes = null\n    this._active = null\n    this._sleeper = new Sleeper()\n    this._resumed = new Signal()\n    this._signAnnounce = opts.signAnnounce || Persistent.signAnnounce\n    this._signUnannounce = opts.signUnannounce || Persistent.signUnannounce\n    this._updating = null\n    this._activeQuery = null\n    this._unannouncing = null\n\n    this._serverRelays = [new Map(), new Map(), new Map()]\n  }\n\n  isRelay(addr) {\n    const id = addr.host + ':' + addr.port\n    const [a, b, c] = this._serverRelays\n    return a.has(id) || b.has(id) || c.has(id)\n  }\n\n  async suspend({ log = noop } = {}) {\n    if (this.suspended) return\n    this.suspended = true\n\n    log('Suspending announcer')\n\n    // Suspend has its own sleep logic\n    // so we don't want to hang on this one\n    this.online.notify()\n\n    if (this._activeQuery) this._activeQuery.destroy()\n\n    this._sleeper.resume()\n    if (this._updating) await this._updating\n    log('Suspending announcer (post update)')\n\n    if (this.suspended === false || this.stopped) return\n\n    log('Suspending announcer (pre unannounce)')\n    await this._unannounceCurrent()\n    log('Suspending announcer (post unannounce)')\n  }\n\n  resume() {\n    if (!this.suspended) return\n    this.suspended = false\n\n    this.refresh()\n    this._sleeper.resume()\n    this._resumed.notify()\n  }\n\n  refresh() {\n    if (this.stopped) return\n    this._refreshing = true\n  }\n\n  async start() {\n    if (this.stopped) return\n    this._active = this._runUpdate()\n    await this._active\n    if (this.stopped) return\n    this._active = this._background()\n  }\n\n  async stop() {\n    this.stopped = true\n    this.online.notify() // Break out of the _background loop if we're offline\n    this._sleeper.resume()\n    this._resumed.notify()\n    await this._active\n    await this._unannounceCurrent()\n  }\n\n  async _unannounceCurrent() {\n    while (this._unannouncing !== null) await this._unannouncing\n    const un = (this._unannouncing = this._unannounceAll(this._serverRelays[2].values()))\n    await this._unannouncing\n    if (un === this._unannouncing) this._unannouncing = null\n  }\n\n  async _background() {\n    while (!this.dht.destroyed && !this.stopped) {\n      try {\n        this._refreshing = false\n\n        // ~5min +-\n        for (let i = 0; i < 100 && !this.stopped && !this._refreshing && !this.suspended; i++) {\n          const pings = []\n\n          for (const node of this._serverRelays[2].values()) {\n            pings.push(this.dht.ping(node))\n          }\n\n          const active = await resolved(pings)\n          if (active < Math.min(pings.length, MIN_ACTIVE)) {\n            this.refresh() // we lost too many relay nodes, retry all\n          }\n\n          if (this.stopped) return\n\n          if (!this.suspended && !this._refreshing) await this._sleeper.pause(3000)\n        }\n\n        while (!this.stopped && this.suspended) await this._resumed.wait()\n\n        if (!this.stopped) await this._runUpdate()\n\n        while (!this.dht.online && !this.stopped && !this.suspended) {\n          // Being offline can make _background repeat very quickly\n          // So wait until we're back online\n          await this.online.wait()\n        }\n      } catch (err) {\n        safetyCatch(err)\n      }\n    }\n  }\n\n  async _runUpdate() {\n    this._updating = this._update()\n    await this._updating\n    this._updating = null\n  }\n\n  async _update() {\n    while (this._unannouncing) await this._unannouncing\n\n    this._cycle()\n\n    const q = (this._activeQuery = this.dht.findPeer(this.target, {\n      hash: false,\n      nodes: this._closestNodes\n    }))\n\n    try {\n      await q.finished()\n    } catch {\n      // ignore failures...\n    }\n\n    this._activeQuery = null\n\n    if (this.stopped || this.suspended) return\n\n    const ann = []\n    const replies = pickBest(q.closestReplies)\n\n    const relays = []\n    const relayAddresses = []\n\n    if (!this.dht.firewalled) {\n      const addr = this.dht.remoteAddress()\n      if (addr) relayAddresses.push(addr)\n    }\n\n    for (const msg of replies) {\n      ann.push(this._commit(msg, relays, relayAddresses))\n    }\n\n    await Promise.allSettled(ann)\n    if (this.stopped || this.suspended) return\n\n    this._closestNodes = q.closestNodes\n    this.relays = relays\n    this.relayAddresses = relayAddresses\n\n    const removed = []\n    for (const [key, value] of this._serverRelays[1]) {\n      if (!this._serverRelays[2].has(key)) removed.push(value)\n    }\n\n    await this._unannounceAll(removed)\n  }\n\n  _unannounceAll(relays) {\n    const unann = []\n    for (const r of relays) unann.push(this._unannounce(r))\n    return Promise.allSettled(unann)\n  }\n\n  async _unannounce(to) {\n    const unann = {\n      peer: {\n        publicKey: this.keyPair.publicKey,\n        relayAddresses: []\n      },\n      refresh: null,\n      signature: null\n    }\n\n    const { from, token, value } = await this.dht.request(\n      {\n        token: null,\n        command: COMMANDS.FIND_PEER,\n        target: this.target,\n        value: null\n      },\n      to\n    )\n\n    if (!token || !from.id || !value) return\n\n    unann.signature = await this._signUnannounce(this.target, token, from.id, unann, this.keyPair)\n\n    await this.dht.request(\n      {\n        token,\n        command: COMMANDS.UNANNOUNCE,\n        target: this.target,\n        value: c.encode(m.announce, unann)\n      },\n      to\n    )\n  }\n\n  async _commit(msg, relays, relayAddresses) {\n    const ann = {\n      peer: {\n        publicKey: this.keyPair.publicKey,\n        relayAddresses: []\n      },\n      refresh: null,\n      signature: null\n    }\n\n    ann.signature = await this._signAnnounce(this.target, msg.token, msg.from.id, ann, this.keyPair)\n\n    const res = await this.dht.request(\n      {\n        token: msg.token,\n        command: COMMANDS.ANNOUNCE,\n        target: this.target,\n        value: c.encode(m.announce, ann)\n      },\n      msg.from\n    )\n\n    if (res.error !== 0) return\n\n    if (relayAddresses.length < 3) relayAddresses.push({ host: msg.from.host, port: msg.from.port })\n    relays.push({ relayAddress: msg.from, peerAddress: msg.to })\n\n    this._serverRelays[2].set(msg.from.host + ':' + msg.from.port, msg.from)\n  }\n\n  _cycle() {\n    const tmp = this._serverRelays[0]\n    this._serverRelays[0] = this._serverRelays[1]\n    this._serverRelays[1] = this._serverRelays[2]\n    this._serverRelays[2] = tmp\n    tmp.clear()\n  }\n}\n\nfunction resolved(ps) {\n  let replied = 0\n  let ticks = ps.length + 1\n\n  return new Promise((resolve) => {\n    for (const p of ps) p.then(push, tick)\n    tick()\n\n    function push(v) {\n      replied++\n      tick()\n    }\n\n    function tick() {\n      if (--ticks === 0) resolve(replied)\n    }\n  })\n}\n\nfunction pickBest(replies) {\n  // TODO: pick the ones closest to us RTT wise\n  return replies.slice(0, 3)\n}\n\nfunction noop() {}\nconst NoiseSecretStream = require('@hyperswarm/secret-stream')\nconst b4a = require('b4a')\nconst relay = require('blind-relay')\nconst { isReserved, isBogon } = require('bogon')\nconst safetyCatch = require('safety-catch')\nconst unslab = require('unslab')\nconst Semaphore = require('./semaphore')\nconst NoiseWrap = require('./noise-wrap')\nconst SecurePayload = require('./secure-payload')\nconst Holepuncher = require('./holepuncher')\nconst Sleeper = require('./sleeper')\nconst { FIREWALL, ERROR } = require('./constants')\nconst { unslabbedHash } = require('./crypto')\nconst {\n  CANNOT_HOLEPUNCH,\n  HANDSHAKE_INVALID,\n  HOLEPUNCH_ABORTED,\n  HOLEPUNCH_INVALID,\n  HOLEPUNCH_PROBE_TIMEOUT,\n  HOLEPUNCH_DOUBLE_RANDOMIZED_NATS,\n  PEER_CONNECTION_FAILED,\n  PEER_NOT_FOUND,\n  REMOTE_ABORTED,\n  REMOTE_NOT_HOLEPUNCHABLE,\n  REMOTE_NOT_HOLEPUNCHING,\n  SERVER_ERROR,\n  SERVER_INCOMPATIBLE,\n  RELAY_ABORTED,\n  SUSPENDED\n} = require('./errors')\n\nmodule.exports = function connect(dht, publicKey, opts = {}) {\n  const pool = opts.pool || null\n\n  if (pool && pool.has(publicKey)) return pool.get(publicKey)\n\n  publicKey = unslab(publicKey)\n\n  const keyPair = opts.keyPair || dht.defaultKeyPair\n  const relayThrough = selectRelay(opts.relayThrough || null)\n  const encryptedSocket = (opts.createSecretStream || defaultCreateSecretStream)(true, null, {\n    publicKey: keyPair.publicKey,\n    remotePublicKey: publicKey,\n    autoStart: false,\n    keepAlive: dht.connectionKeepAlive\n  })\n\n  // in case a socket is made during suspended state, destroy it immediately\n  if (dht.suspended || !dht._connectable) {\n    encryptedSocket.destroy(SUSPENDED())\n    return encryptedSocket\n  }\n\n  if (pool) pool._attachStream(encryptedSocket, false)\n\n  const id = b4a.toString(publicKey, 'hex')\n  const c = {\n    id,\n    dht,\n    session: dht.session(),\n    relayAddresses: opts.relayAddresses || [],\n    remoteRelayAddresses: [],\n    pool,\n    round: 0,\n    target: unslabbedHash(publicKey),\n    remotePublicKey: publicKey,\n    reusableSocket: !!opts.reusableSocket,\n    handshake: (opts.createHandshake || defaultCreateHandshake)(keyPair, publicKey),\n    request: null,\n    requesting: false,\n    lan: opts.localConnection !== false,\n    firewall: FIREWALL.UNKNOWN,\n    rawStream: dht.createRawStream({ framed: true, firewall }),\n    connect: null,\n    query: null,\n    puncher: null,\n    payload: null,\n    passiveConnectTimeout: null,\n    serverSocket: null,\n    serverAddress: null,\n    onsocket: null,\n    sleeper: new Sleeper(),\n    encryptedSocket,\n\n    // Relay state\n    relayTimeout: null,\n    relayThrough,\n    relayToken: relayThrough ? relay.token() : null,\n    relaySocket: null,\n    relayClient: null,\n    relayPaired: false,\n    relayKeepAlive: opts.relayKeepAlive || 5000\n  }\n\n  // If the raw stream receives an error signal pre connect (ie from the firewall hook), make sure\n  // to forward that to the encrypted socket for proper teardown\n  c.rawStream.on('error', autoDestroy)\n  c.rawStream.once('connect', () => {\n    c.rawStream.removeListener('error', autoDestroy)\n  })\n\n  encryptedSocket.on('close', function () {\n    if (c.passiveConnectTimeout) clearPassiveConnectTimeout(c)\n    if (c.query) c.query.destroy()\n    if (c.puncher) c.puncher.destroy()\n    if (c.rawStream) c.rawStream.destroy()\n    c.session.destroy()\n    c.sleeper.resume()\n  })\n\n  // Safe to run in the background - never throws\n  if (dht.suspended) encryptedSocket.destroy(SUSPENDED())\n  else connectAndHolepunch(c, opts)\n\n  return encryptedSocket\n\n  function autoDestroy(err) {\n    maybeDestroyEncryptedSocket(c, err)\n  }\n\n  function firewall(socket, port, host) {\n    // Check if the traffic originated from the socket on which we're expecting relay traffic. If so,\n    // we haven't hole punched yet and the other side is just sending us traffic through the relay.\n    if (c.relaySocket && isRelay(c.relaySocket, socket, port, host)) {\n      return false\n    }\n\n    if (c.onsocket) {\n      c.onsocket(socket, port, host)\n    } else {\n      c.serverSocket = socket\n      c.serverAddress = { port, host }\n    }\n    return false\n  }\n}\n\nfunction isDone(c) {\n  // we are destroying or the puncher is connected - done\n  if (c.encryptedSocket.destroying || !!(c.puncher && c.puncher.connected)) {\n    return true\n  }\n  // not destroying, but no raw stream - def not done\n  if (c.encryptedSocket.rawStream === null) {\n    return false\n  }\n  // we are relayed, but the puncher is not done yet\n  if (c.relaySocket && !!(c.puncher && !c.puncher.connected && !c.puncher.destroyed)) {\n    return false\n  }\n  // we are done\n  return true\n}\n\nasync function retryRoute(c, route) {\n  const ref = c.dht._socketPool.lookup(route.socket)\n\n  if (!ref) {\n    if (route.socket === c.dht.socket) {\n      await connectThroughNode(c, route.address, c.dht.socket)\n    }\n    return\n  }\n\n  ref.active()\n\n  try {\n    await connectThroughNode(c, route.address, route.socket)\n  } catch {\n    // if error, just ignore, and continue through the existing strat\n  }\n\n  ref.inactive()\n}\n\nasync function connectAndHolepunch(c, opts) {\n  const route = c.reusableSocket ? c.dht._socketPool.routes.get(c.remotePublicKey) : null\n\n  if (route) {\n    await retryRoute(c, route)\n    if (isDone(c)) return\n  }\n\n  await findAndConnect(c, opts)\n  if (isDone(c)) return\n\n  if (!c.connect) {\n    // TODO: just a quick fix for now, should retry prob\n    maybeDestroyEncryptedSocket(c, HANDSHAKE_INVALID())\n    return\n  }\n\n  await holepunch(c, opts)\n}\n\nfunction getFirstRemoteAddress(addrs, serverAddress) {\n  for (const addr of addrs) {\n    if (isBogon(addr.host)) continue\n    return addr\n  }\n\n  return serverAddress\n}\n\nasync function holepunch(c, opts) {\n  let { relayAddress, serverAddress, clientAddress, payload } = c.connect\n\n  const remoteHolepunchable = !!(payload.holepunch && payload.holepunch.relays.length)\n\n  const relayed = diffAddress(serverAddress, relayAddress)\n\n  if (payload.firewall === FIREWALL.OPEN || (relayed && !remoteHolepunchable)) {\n    const addr = getFirstRemoteAddress(payload.addresses4, serverAddress)\n    if (addr) {\n      const socket = c.dht.socket\n      c.dht.stats.punches.open++\n      c.onsocket(socket, addr.port, addr.host)\n      return\n    }\n    // TODO: check all addresses also obvs\n  }\n\n  const onabort = () => {\n    c.session.destroy()\n    maybeDestroyEncryptedSocket(c, HOLEPUNCH_ABORTED())\n  }\n\n  if (c.firewall === FIREWALL.OPEN) {\n    c.passiveConnectTimeout = setTimeout(onabort, 10000)\n    return\n  }\n\n  // TODO: would be better to just try local addrs in the background whilst continuing with other strategies...\n  if (c.lan && relayed && clientAddress.host === serverAddress.host) {\n    const serverAddresses = payload.addresses4.filter(onlyNonReserved)\n\n    if (serverAddresses.length > 0) {\n      const myAddresses = Holepuncher.localAddresses(c.dht.io.serverSocket)\n      const addr = Holepuncher.matchAddress(myAddresses, serverAddresses) || serverAddresses[0]\n\n      const socket = c.dht.io.serverSocket\n      try {\n        await c.dht.ping(addr)\n      } catch {\n        maybeDestroyEncryptedSocket(c, HOLEPUNCH_ABORTED())\n        return\n      }\n      c.onsocket(socket, addr.port, addr.host)\n      return\n    }\n  }\n\n  if (!remoteHolepunchable) {\n    maybeDestroyEncryptedSocket(c, CANNOT_HOLEPUNCH())\n    return\n  }\n\n  c.puncher = new Holepuncher(c.dht, c.session, true, payload.firewall)\n\n  c.puncher.onconnect = c.onsocket\n  c.puncher.onabort = onabort\n\n  const serverRelay = pickServerRelay(payload.holepunch.relays, relayAddress)\n\n  // Begin holepunching!\n\n  let probe\n  try {\n    probe = await probeRound(c, opts.fastOpen === false ? null : serverAddress, serverRelay, true)\n  } catch (err) {\n    destroyPuncher(c)\n    // TODO: we should retry here with some of the other relays, bail for now\n    maybeDestroyEncryptedSocket(c, err)\n    return\n  }\n\n  if (isDone(c) || !probe) return\n  const { token, peerAddress } = probe\n\n  // If the relay the server picked is the same as the relay the client picked,\n  // then we can use the peerAddress that round one indicates the server wants to use.\n  // This shaves off a roundtrip if the server chose to reroll its socket due to some NAT\n  // issue with the first one it picked (ie mobile nat inconsistencies...).\n  // If the relays were different, then the server would not have a UDP session open on this address\n  // to the client relay, which round2 uses.\n  if (\n    !diffAddress(serverRelay.relayAddress, relayAddress) &&\n    diffAddress(serverAddress, peerAddress)\n  ) {\n    serverAddress = peerAddress\n    await c.puncher.openSession(serverAddress)\n    if (isDone(c)) return\n  }\n\n  // TODO: still continue here if a local connection might work, but then do not holepunch...\n  if (\n    opts.holepunch &&\n    !opts.holepunch(\n      c.puncher.remoteFirewall,\n      c.puncher.nat.firewall,\n      c.puncher.remoteAddresses,\n      c.puncher.nat.addresses\n    )\n  ) {\n    await abort(c, serverRelay, HOLEPUNCH_ABORTED('Client aborted holepunch'))\n    return\n  }\n\n  try {\n    await roundPunch(c, serverAddress, token, relayAddress, serverRelay, false)\n  } catch (err) {\n    destroyPuncher(c)\n    // TODO: retry with another relay?\n    maybeDestroyEncryptedSocket(c, err)\n  }\n}\n\nasync function findAndConnect(c, opts) {\n  let attempts = 0\n  let closestNodes = opts.relayAddresses && opts.relayAddresses.length ? opts.relayAddresses : null\n\n  if (!closestNodes) {\n    const cachedRelayAddresses = c.dht._relayAddressesCache.get(c.id)\n    if (cachedRelayAddresses) closestNodes = cachedRelayAddresses\n  }\n\n  if (c.dht._persistent) {\n    // check if we know the route ourself...\n    const route = c.dht._router.get(c.target)\n    if (route && route.relay !== null) {\n      closestNodes = [{ host: route.relay.host, port: route.relay.port }]\n    }\n  }\n\n  // 2 is how many parallel connect attempts we want to do, we can make this configurable\n  const sem = new Semaphore(2)\n  const signal = sem.signal.bind(sem)\n  const tries = closestNodes !== null ? 2 : 1\n\n  try {\n    for (let i = 0; i < tries && !isDone(c) && !c.connect; i++) {\n      c.query = c.dht.findPeer(c.target, {\n        hash: false,\n        session: c.session,\n        closestNodes,\n        onlyClosestNodes: closestNodes !== null,\n        retries: closestNodes ? 1 : 3\n      })\n\n      for await (const data of c.query) {\n        await sem.wait()\n        if (isDone(c)) return\n\n        if (c.connect) {\n          sem.signal()\n          break\n        }\n\n        c.remoteRelayAddresses.push(data.from)\n        attempts++\n        connectThroughNode(c, data.from, null).then(signal, signal)\n      }\n\n      closestNodes = null\n\n      if (attempts > 0) await sem.flush()\n    }\n\n    c.query = null\n    if (isDone(c)) return\n\n    // flush the semaphore\n    await sem.flush()\n    if (isDone(c)) return\n  } catch (err) {\n    c.query = null\n    maybeDestroyEncryptedSocket(c, err)\n    return\n  }\n\n  if (!c.connect) {\n    maybeDestroyEncryptedSocket(c, attempts ? PEER_CONNECTION_FAILED() : PEER_NOT_FOUND())\n  }\n}\n\nasync function connectThroughNode(c, address, socket) {\n  if (!c.requesting) {\n    // If we have a stable server address, send it over now\n    const addr = c.dht.remoteAddress()\n    const localAddrs = c.lan ? Holepuncher.localAddresses(c.dht.io.serverSocket) : null\n    const addresses4 = []\n\n    if (addr) addresses4.push(addr)\n    if (localAddrs) addresses4.push(...localAddrs)\n\n    c.firewall = addr ? FIREWALL.OPEN : FIREWALL.UNKNOWN\n    c.requesting = true\n    c.request = await c.handshake.send({\n      error: ERROR.NONE,\n      firewall: c.firewall,\n      holepunch: null,\n      addresses4,\n      addresses6: [],\n      udx: {\n        reusableSocket: c.reusableSocket,\n        id: c.rawStream.id,\n        seq: 0\n      },\n      secretStream: {},\n      relayThrough: c.relayThrough ? { publicKey: c.relayThrough, token: c.relayToken } : null\n    })\n    if (isDone(c)) return\n  }\n\n  const { serverAddress, clientAddress, relayed, noise } = await c.dht._router.peerHandshake(\n    c.target,\n    { noise: c.request, socket, session: c.session },\n    address\n  )\n  if (isDone(c) || c.connect) return\n\n  const payload = await c.handshake.recv(noise)\n  if (isDone(c) || !payload) return\n\n  if (payload.version !== 1) {\n    maybeDestroyEncryptedSocket(c, SERVER_INCOMPATIBLE())\n    return\n  }\n  if (payload.error !== ERROR.NONE) {\n    maybeDestroyEncryptedSocket(c, SERVER_ERROR())\n    return\n  }\n  if (!payload.udx) {\n    maybeDestroyEncryptedSocket(c, SERVER_ERROR('Server did not send UDX data'))\n    return\n  }\n\n  const hs = c.handshake.final()\n\n  c.handshake = null\n  c.request = null\n  c.requesting = false\n  c.connect = {\n    relayed,\n    relayAddress: address,\n    clientAddress,\n    serverAddress,\n    payload\n  }\n\n  c.payload = new SecurePayload(hs.holepunchSecret)\n\n  c.onsocket = function (socket, port, host) {\n    if (c.rawStream === null) return // Already hole punched\n\n    if (c.rawStream.connected) {\n      const remoteChanging = c.rawStream.changeRemote(socket, c.connect.payload.udx.id, port, host)\n\n      if (remoteChanging) remoteChanging.catch(safetyCatch)\n    } else {\n      // cache the relay addrs for a future reconnect, we prefer the remote one so they\n      // can give us the correct ones from their pov\n      if (payload.relayAddresses && payload.relayAddresses.length) {\n        c.dht._relayAddressesCache.set(c.id, payload.relayAddresses)\n      } else if (c.remoteRelayAddresses.length) {\n        c.dht._relayAddressesCache.set(c.id, c.remoteRelayAddresses)\n      }\n\n      c.rawStream.connect(socket, c.connect.payload.udx.id, port, host)\n      c.encryptedSocket.start(c.rawStream, { handshake: hs })\n    }\n\n    if (c.reusableSocket && payload.udx.reusableSocket) {\n      c.dht._socketPool.routes.add(c.remotePublicKey, c.rawStream)\n    }\n\n    if (c.puncher) {\n      c.puncher.onabort = noop\n      c.puncher.destroy()\n    }\n\n    if (c.passiveConnectTimeout) {\n      clearPassiveConnectTimeout(c)\n    }\n\n    c.rawStream = null\n  }\n\n  if (payload.relayThrough || c.relayThrough) {\n    relayConnection(c, c.relayThrough, payload, hs)\n  }\n\n  if (c.serverSocket) {\n    c.onsocket(c.serverSocket, c.serverAddress.port, c.serverAddress.host)\n    return\n  }\n\n  if (!relayed) {\n    c.onsocket(socket || c.dht.socket, address.port, address.host)\n  }\n\n  c.session.destroy()\n}\n\nasync function updateHolepunch(c, peerAddress, relayAddr, payload) {\n  const holepunch = await c.dht._router.peerHolepunch(\n    c.target,\n    {\n      id: c.connect.payload.holepunch.id,\n      payload: c.payload.encrypt(payload),\n      peerAddress,\n      socket: c.puncher.socket,\n      session: c.session\n    },\n    relayAddr\n  )\n\n  if (isDone(c)) return null\n\n  const remotePayload = c.payload.decrypt(holepunch.payload)\n  if (!remotePayload) {\n    throw HOLEPUNCH_INVALID()\n  }\n\n  const { error, firewall, punching, addresses, remoteToken } = remotePayload\n\n  if (error === ERROR.TRY_LATER && c.relayToken && payload.punching) {\n    return {\n      tryLater: true,\n      ...holepunch,\n      payload: remotePayload\n    }\n  }\n\n  if (error !== ERROR.NONE) {\n    throw REMOTE_ABORTED('Remote aborted with error code ' + error)\n  }\n\n  const echoed = !!(remoteToken && payload.token && b4a.equals(remoteToken, payload.token))\n\n  c.puncher.updateRemote({\n    punching,\n    firewall,\n    addresses,\n    verified: echoed ? peerAddress.host : null\n  })\n\n  return {\n    tryLater: false,\n    ...holepunch,\n    payload: remotePayload\n  }\n}\n\nasync function probeRound(c, serverAddress, serverRelay, retry) {\n  // Open a quick low ttl session against what we think is the server\n  if (serverAddress) await c.puncher.openSession(serverAddress)\n\n  if (isDone(c)) return null\n\n  const reply = await updateHolepunch(c, serverRelay.peerAddress, serverRelay.relayAddress, {\n    error: ERROR.NONE,\n    firewall: c.puncher.nat.firewall,\n    round: c.round++,\n    connected: false,\n    punching: false,\n    addresses: c.puncher.nat.addresses,\n    remoteAddress: serverAddress,\n    token: null,\n    remoteToken: null\n  })\n\n  if (isDone(c) || !reply) return null\n\n  const { peerAddress } = reply\n  const { address, token } = reply.payload\n\n  c.puncher.nat.add(reply.to, reply.from)\n\n  // Open another quick low ttl session against what the server says their address is,\n  // if they haven't said they are random yet\n  if (\n    c.puncher.remoteFirewall < FIREWALL.RANDOM &&\n    address &&\n    address.host &&\n    address.port &&\n    diffAddress(address, serverAddress)\n  ) {\n    await c.puncher.openSession(address)\n    if (isDone(c)) return null\n  }\n\n  // If the remote told us they didn't know their nat firewall yet, give them a chance to figure it out\n  // They might say this to see if the \"fast mode\" punch comes through first.\n  if (c.puncher.remoteFirewall === FIREWALL.UNKNOWN) {\n    await c.sleeper.pause(1000)\n    if (isDone(c)) return null\n  }\n\n  let stable = await c.puncher.analyze(false)\n  if (isDone(c)) return null\n\n  // If the socket seems unstable, try to make it stable by setting the \"allowReopen\" flag\n  // Mostly relevant for mobile networks\n  if (!stable) {\n    stable = await c.puncher.analyze(true)\n    if (isDone(c)) return null\n    if (stable) return probeRound(c, serverAddress, serverRelay, false)\n  }\n\n  if ((c.puncher.remoteFirewall === FIREWALL.UNKNOWN || !token) && retry) {\n    return probeRound(c, serverAddress, serverRelay, false)\n  }\n\n  if (\n    c.puncher.remoteFirewall === FIREWALL.UNKNOWN ||\n    c.puncher.nat.firewall === FIREWALL.UNKNOWN\n  ) {\n    await abort(c, serverRelay, HOLEPUNCH_PROBE_TIMEOUT())\n    return null\n  }\n\n  if (c.puncher.remoteFirewall >= FIREWALL.RANDOM && c.puncher.nat.firewall >= FIREWALL.RANDOM) {\n    await abort(c, serverRelay, HOLEPUNCH_DOUBLE_RANDOMIZED_NATS())\n    return null\n  }\n\n  return { token, peerAddress }\n}\n\nasync function roundPunch(c, serverAddress, remoteToken, clientRelay, serverRelay, delayed) {\n  // We are gossiping our final NAT status to the other peer now\n  // so make sure we don't update our local view for now as that can make things weird\n  c.puncher.nat.freeze()\n\n  const isRandom =\n    c.puncher.remoteFirewall >= FIREWALL.RANDOM || c.puncher.nat.firewall >= FIREWALL.RANDOM\n  if (isRandom) {\n    while (\n      c.dht._randomPunches >= c.dht._randomPunchLimit ||\n      Date.now() - c.dht._lastRandomPunch < c.dht._randomPunchInterval\n    ) {\n      // if no relay can help, bail\n      if (!c.relayToken) throw HOLEPUNCH_ABORTED()\n\n      if (!delayed) {\n        delayed = true\n        await updateHolepunch(c, serverAddress, clientRelay, {\n          error: ERROR.NONE,\n          firewall: c.puncher.nat.firewall,\n          round: c.round++,\n          connected: false,\n          punching: false,\n          addresses: c.puncher.nat.addresses,\n          remoteAddress: null,\n          token: c.payload.token(serverAddress),\n          remoteToken\n        })\n        if (isDone(c)) return\n      }\n\n      await tryLater(c)\n      if (isDone(c)) return\n    }\n  }\n\n  // increment now, so we can commit to punching\n  if (isRandom) c.dht._randomPunches++\n\n  let reply\n\n  try {\n    // if delayed switch to the servers chosen relay - we validated anyway\n    reply = await updateHolepunch(\n      c,\n      delayed ? serverRelay.peerAddress : serverAddress,\n      delayed ? serverRelay.relayAddress : clientRelay,\n      {\n        error: ERROR.NONE,\n        firewall: c.puncher.nat.firewall,\n        round: c.round++,\n        connected: false,\n        punching: true,\n        addresses: c.puncher.nat.addresses,\n        remoteAddress: null,\n        token: delayed ? null : c.payload.token(serverAddress),\n        remoteToken\n      }\n    )\n  } finally {\n    // decrement as punch increments for us\n    if (isRandom) c.dht._randomPunches--\n  }\n\n  if (isDone(c)) return\n  if (!reply) return\n\n  if (reply.tryLater) {\n    await tryLater(c)\n    if (isDone(c)) return\n    return roundPunch(c, serverAddress, remoteToken, clientRelay, serverRelay, true)\n  }\n\n  if (!c.puncher.remoteHolepunching) {\n    throw REMOTE_NOT_HOLEPUNCHING()\n  }\n\n  if (!(await c.puncher.punch())) {\n    throw REMOTE_NOT_HOLEPUNCHABLE()\n  }\n}\n\nasync function tryLater(c) {\n  if (!c.relayToken) throw HOLEPUNCH_ABORTED()\n  await c.sleeper.pause(10000 + Math.round(Math.random() * 10000))\n}\n\nfunction maybeDestroyEncryptedSocket(c, err) {\n  if (isDone(c)) return\n  if (c.encryptedSocket.rawStream) return\n  if (c.relaySocket) return // waiting for the relay\n  if (c.puncher && !c.puncher.destroyed) return // waiting for the puncher\n  c.session.destroy()\n  c.encryptedSocket.destroy(err)\n}\n\nasync function abort(c, { peerAddress, relayAddress }, err) {\n  try {\n    await updateHolepunch(c, peerAddress, relayAddress, {\n      error: ERROR.ABORTED,\n      firewall: FIREWALL.UNKNOWN,\n      round: c.round++,\n      connected: false,\n      punching: false,\n      addresses: null,\n      remoteAddress: null,\n      token: null,\n      remoteToken: null\n    })\n  } catch {}\n\n  destroyPuncher(c)\n  maybeDestroyEncryptedSocket(c, err)\n}\n\nfunction relayConnection(c, relayThrough, payload, hs) {\n  let isInitiator\n  let publicKey\n  let token\n\n  if (payload.relayThrough) {\n    isInitiator = false\n    publicKey = payload.relayThrough.publicKey\n    token = payload.relayThrough.token\n  } else {\n    isInitiator = true\n    publicKey = relayThrough\n    token = c.relayToken\n  }\n\n  c.relayToken = token\n  c.relaySocket = c.dht.connect(publicKey)\n  c.relaySocket.setKeepAlive(c.relayKeepAlive)\n  c.relayClient = relay.Client.from(c.relaySocket, { id: c.relaySocket.publicKey })\n  c.relayTimeout = setTimeout(onabort, 15000, null)\n\n  c.relayClient.pair(isInitiator, token, c.rawStream).on('error', onabort).on('data', ondata)\n\n  function ondata(remoteId) {\n    if (c.relayTimeout) clearRelayTimeout(c)\n    if (c.rawStream === null) {\n      onabort(null)\n      return\n    }\n\n    c.relayPaired = true\n\n    const { remotePort, remoteHost, socket } = c.relaySocket.rawStream\n\n    c.rawStream\n      .on('close', () => c.relaySocket.destroy())\n      .connect(socket, remoteId, remotePort, remoteHost)\n\n    c.encryptedSocket.start(c.rawStream, { handshake: hs })\n  }\n\n  function onabort(err) {\n    if (c.relayTimeout) clearRelayTimeout(c)\n    const socket = c.relaySocket\n    c.relayToken = null\n    c.relaySocket = null\n    if (socket) socket.destroy()\n    maybeDestroyEncryptedSocket(c, err || RELAY_ABORTED())\n  }\n}\n\nfunction clearPassiveConnectTimeout(c) {\n  clearTimeout(c.passiveConnectTimeout)\n  c.passiveConnectTimeout = null\n}\n\nfunction clearRelayTimeout(c) {\n  clearTimeout(c.relayTimeout)\n  c.relayTimeout = null\n}\n\nfunction destroyPuncher(c) {\n  if (c.puncher) c.puncher.destroy()\n  c.session.destroy()\n}\n\nfunction pickServerRelay(relays, clientRelay) {\n  for (const r of relays) {\n    if (!diffAddress(r.relayAddress, clientRelay)) return r\n  }\n  return relays[0]\n}\n\nfunction diffAddress(a, b) {\n  return a.host !== b.host || a.port !== b.port\n}\n\nfunction defaultCreateHandshake(keyPair, remotePublicKey) {\n  return new NoiseWrap(keyPair, remotePublicKey)\n}\n\nfunction defaultCreateSecretStream(isInitiator, rawStream, opts) {\n  return new NoiseSecretStream(isInitiator, rawStream, opts)\n}\n\nfunction onlyNonReserved(addr) {\n  return !isReserved(addr.host)\n}\n\nfunction isRelay(relaySocket, socket, port, host) {\n  const stream = relaySocket.rawStream\n  if (!stream) return false\n  if (stream.socket !== socket) return false\n  return port === stream.remotePort && host === stream.remoteHost\n}\n\nfunction selectRelay(relayThrough) {\n  if (typeof relayThrough === 'function') relayThrough = relayThrough()\n  if (relayThrough === null) return null\n  if (Array.isArray(relayThrough))\n    return relayThrough[Math.floor(Math.random() * relayThrough.length)]\n  return relayThrough\n}\n\nfunction noop() {}\nconst EventEmitter = require('events')\nconst b4a = require('b4a')\nconst errors = require('./errors')\n\nmodule.exports = class ConnectionPool extends EventEmitter {\n  constructor(dht) {\n    super()\n\n    this._dht = dht\n    this._servers = new Map()\n    this._connecting = new Map()\n    this._connections = new Map()\n  }\n\n  _attachServer(server) {\n    const keyString = b4a.toString(server.publicKey, 'hex')\n\n    this._servers.set(keyString, server)\n\n    server\n      .on('close', () => {\n        this._servers.delete(keyString)\n      })\n      .on('connection', (socket) => {\n        this._attachStream(socket, true)\n      })\n  }\n\n  _attachStream(stream, opened) {\n    const existing = this.get(stream.remotePublicKey)\n\n    if (existing) {\n      const keepNew =\n        stream.isInitiator === existing.isInitiator ||\n        b4a.compare(stream.publicKey, stream.remotePublicKey) > 0\n\n      if (keepNew) {\n        let closed = false\n\n        const onclose = () => {\n          closed = true\n        }\n\n        existing\n          .on('error', noop)\n          .on('close', () => {\n            if (closed) return\n\n            stream.off('error', noop).off('close', onclose)\n\n            this._attachStream(stream, opened)\n          })\n          .destroy(errors.DUPLICATE_CONNECTION())\n\n        stream.on('error', noop).on('close', onclose)\n      } else {\n        stream.on('error', noop).destroy(errors.DUPLICATE_CONNECTION())\n      }\n\n      return\n    }\n\n    const session = new ConnectionRef(this, stream)\n\n    const keyString = b4a.toString(stream.remotePublicKey, 'hex')\n\n    if (opened) {\n      this._connections.set(keyString, session)\n\n      stream.on('close', () => {\n        this._connections.delete(keyString)\n      })\n\n      this.emit('connection', stream, session)\n    } else {\n      this._connecting.set(keyString, session)\n\n      stream\n        .on('error', noop)\n        .on('close', () => {\n          if (opened) this._connections.delete(keyString)\n          else this._connecting.delete(keyString)\n        })\n        .on('open', () => {\n          opened = true\n\n          this._connecting.delete(keyString)\n          this._connections.set(keyString, session)\n\n          stream.off('error', noop)\n\n          this.emit('connection', stream, session)\n        })\n    }\n\n    return session\n  }\n\n  get connecting() {\n    return this._connecting.size\n  }\n\n  get connections() {\n    return this._connections.values()\n  }\n\n  has(publicKey) {\n    const keyString = b4a.toString(publicKey, 'hex')\n\n    return this._connections.has(keyString) || this._connecting.has(keyString)\n  }\n\n  get(publicKey) {\n    const keyString = b4a.toString(publicKey, 'hex')\n\n    const existing = this._connections.get(keyString) || this._connecting.get(keyString)\n\n    return existing?._stream || null\n  }\n}\n\nclass ConnectionRef {\n  constructor(pool, stream) {\n    this._pool = pool\n    this._stream = stream\n    this._refs = 0\n  }\n\n  active() {\n    this._refs++\n  }\n\n  inactive() {\n    this._refs--\n  }\n\n  release() {\n    this._stream.destroy()\n  }\n}\n\nfunction noop() {}\nconst crypto = require('hypercore-crypto')\n\nconst COMMANDS = (exports.COMMANDS = {\n  PEER_HANDSHAKE: 0,\n  PEER_HOLEPUNCH: 1,\n  FIND_PEER: 2,\n  LOOKUP: 3,\n  ANNOUNCE: 4,\n  UNANNOUNCE: 5,\n  MUTABLE_PUT: 6,\n  MUTABLE_GET: 7,\n  IMMUTABLE_PUT: 8,\n  IMMUTABLE_GET: 9\n})\n\nexports.BOOTSTRAP_NODES = global.Pear?.config.dht?.bootstrap || [\n  '88.99.3.86@node1.hyperdht.org:49737',\n  '142.93.90.113@node2.hyperdht.org:49737',\n  '138.68.147.8@node3.hyperdht.org:49737'\n]\n\nexports.KNOWN_NODES = global.Pear?.config.dht?.nodes || []\n\nexports.FIREWALL = {\n  UNKNOWN: 0,\n  OPEN: 1,\n  CONSISTENT: 2,\n  RANDOM: 3\n}\n\nexports.ERROR = {\n  // noise / connection related\n  NONE: 0,\n  ABORTED: 1,\n  VERSION_MISMATCH: 2,\n  TRY_LATER: 3,\n  // dht related\n  SEQ_REUSED: 16,\n  SEQ_TOO_LOW: 17\n}\n\nconst [NS_ANNOUNCE, NS_UNANNOUNCE, NS_MUTABLE_PUT, NS_PEER_HANDSHAKE, NS_PEER_HOLEPUNCH] =\n  crypto.namespace('hyperswarm/dht', [\n    COMMANDS.ANNOUNCE,\n    COMMANDS.UNANNOUNCE,\n    COMMANDS.MUTABLE_PUT,\n    COMMANDS.PEER_HANDSHAKE,\n    COMMANDS.PEER_HOLEPUNCH\n  ])\n\nexports.NS = {\n  ANNOUNCE: NS_ANNOUNCE,\n  UNANNOUNCE: NS_UNANNOUNCE,\n  MUTABLE_PUT: NS_MUTABLE_PUT,\n  PEER_HANDSHAKE: NS_PEER_HANDSHAKE,\n  PEER_HOLEPUNCH: NS_PEER_HOLEPUNCH\n}\nconst sodium = require('sodium-universal')\nconst b4a = require('b4a')\n\nfunction hash(data) {\n  const out = b4a.allocUnsafe(32)\n  sodium.crypto_generichash(out, data)\n  return out\n}\n\nfunction unslabbedHash(data) {\n  const out = b4a.allocUnsafeSlow(32)\n  sodium.crypto_generichash(out, data)\n  return out\n}\n\nfunction createKeyPair(seed) {\n  const publicKey = b4a.alloc(32)\n  const secretKey = b4a.alloc(64)\n  if (seed) sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed)\n  else sodium.crypto_sign_keypair(publicKey, secretKey)\n  return { publicKey, secretKey }\n}\n\nmodule.exports = {\n  hash,\n  unslabbedHash,\n  createKeyPair\n}\nconst b4a = require('b4a')\nconst cenc = require('compact-encoding')\n\nfunction encodeUnslab(enc, m) {\n  // Faster than unslab(c.encode(enc, data)) because it avoids the mem copy.\n  // Makes sense to put in compact-encoding when we need it in other modules too\n  const state = cenc.state()\n  enc.preencode(state, m)\n  state.buffer = b4a.allocUnsafeSlow(state.end)\n  enc.encode(state, m)\n  return state.buffer\n}\n\nmodule.exports = {\n  encodeUnslab\n}\nmodule.exports = class DHTError extends Error {\n  constructor(msg, code, fn = DHTError) {\n    super(`${code}: ${msg}`)\n    this.code = code\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, fn)\n    }\n  }\n\n  get name() {\n    return 'DHTError'\n  }\n\n  static BAD_HANDSHAKE_REPLY(msg = 'Bad handshake reply') {\n    return new DHTError(msg, 'BAD_HANDSHAKE_REPLY', DHTError.BAD_HANDSHAKE_REPLY)\n  }\n\n  static BAD_HOLEPUNCH_REPLY(msg = 'Bad holepunch reply') {\n    return new DHTError(msg, 'BAD_HOLEPUNCH_REPLY', DHTError.BAD_HOLEPUNCH_REPLY)\n  }\n\n  static HOLEPUNCH_ABORTED(msg = 'Holepunch aborted') {\n    return new DHTError(msg, 'HOLEPUNCH_ABORTED', DHTError.HOLEPUNCH_ABORTED)\n  }\n\n  static HOLEPUNCH_INVALID(msg = 'Invalid holepunch payload') {\n    return new DHTError(msg, 'HOLEPUNCH_INVALID', DHTError.HOLEPUNCH_INVALID)\n  }\n\n  static HOLEPUNCH_PROBE_TIMEOUT(msg = 'Holepunching probe did not finish in time') {\n    return new DHTError(msg, 'HOLEPUNCH_PROBE_TIMEOUT', DHTError.HOLEPUNCH_PROBE_TIMEOUT)\n  }\n\n  static HOLEPUNCH_DOUBLE_RANDOMIZED_NATS(msg = 'Both remote and local NATs are randomized') {\n    return new DHTError(\n      msg,\n      'HOLEPUNCH_DOUBLE_RANDOMIZED_NATS',\n      DHTError.HOLEPUNCH_DOUBLE_RANDOMIZED_NATS\n    )\n  }\n\n  static CANNOT_HOLEPUNCH(msg = 'Cannot holepunch to remote') {\n    return new DHTError(msg, 'CANNOT_HOLEPUNCH', DHTError.CANNOT_HOLEPUNCH)\n  }\n\n  static REMOTE_NOT_HOLEPUNCHING(msg = 'Remote is not holepunching') {\n    return new DHTError(msg, 'REMOTE_NOT_HOLEPUNCHING', DHTError.REMOTE_NOT_HOLEPUNCHING)\n  }\n\n  static REMOTE_NOT_HOLEPUNCHABLE(msg = 'Remote is not holepunchable') {\n    return new DHTError(msg, 'REMOTE_NOT_HOLEPUNCHABLE', DHTError.REMOTE_NOT_HOLEPUNCHABLE)\n  }\n\n  static REMOTE_ABORTED(msg = 'Remote aborted') {\n    return new DHTError(msg, 'REMOTE_ABORTED', DHTError.REMOTE_ABORTED)\n  }\n\n  static HANDSHAKE_UNFINISHED(msg = 'Handshake did not finish') {\n    return new DHTError(msg, 'HANDSHAKE_UNFINISHED', DHTError.HANDSHAKE_UNFINISHED)\n  }\n\n  static HANDSHAKE_INVALID(msg = 'Received invalid handshake') {\n    return new DHTError(msg, 'HANDSHAKE_INVALID', DHTError.HANDSHAKE_INVALID)\n  }\n\n  static ALREADY_LISTENING(msg = 'Already listening') {\n    return new DHTError(msg, 'ALREADY_LISTENING', DHTError.ALREADY_LISTENING)\n  }\n\n  static KEYPAIR_ALREADY_USED(msg = 'Keypair already used') {\n    return new DHTError(msg, 'KEYPAIR_ALREADY_USED', DHTError.KEYPAIR_ALREADY_USED)\n  }\n\n  static NODE_DESTROYED(msg = 'Node destroyed') {\n    return new DHTError(msg, 'NODE_DESTROYED', DHTError.NODE_DESTROYED)\n  }\n\n  static PEER_CONNECTION_FAILED(msg = 'Could not connect to peer') {\n    return new DHTError(msg, 'PEER_CONNECTION_FAILED', DHTError.PEER_CONNECTION_FAILED)\n  }\n\n  static PEER_NOT_FOUND(msg = 'Peer not found') {\n    return new DHTError(msg, 'PEER_NOT_FOUND', DHTError.PEER_NOT_FOUND)\n  }\n\n  static STREAM_NOT_CONNECTED(msg = 'Stream is not connected') {\n    return new DHTError(msg, 'STREAM_NOT_CONNECTED', DHTError.STREAM_DISCONNECTED)\n  }\n\n  static SERVER_INCOMPATIBLE(msg = 'Server is using an incompatible version') {\n    return new DHTError(msg, 'SERVER_INCOMPATIBLE', DHTError.SERVER_INCOMPATIBLE)\n  }\n\n  static SERVER_ERROR(msg = 'Server returned an error') {\n    return new DHTError(msg, 'SERVER_ERROR', DHTError.SERVER_ERROR)\n  }\n\n  static DUPLICATE_CONNECTION(msg = 'Duplicate connection') {\n    return new DHTError(msg, 'DUPLICATE_CONNECTION', DHTError.DUPLICATE_CONNECTION)\n  }\n\n  static RELAY_ABORTED(msg = 'Relay aborted') {\n    return new DHTError(msg, 'RELAY_ABORTED', DHTError.RELAY_ABORTED)\n  }\n\n  static SUSPENDED(msg = 'Suspended') {\n    return new DHTError(msg, 'SUSPENDED', DHTError.SUSPENDED)\n  }\n}\nconst b4a = require('b4a')\nconst Nat = require('./nat')\nconst Sleeper = require('./sleeper')\nconst { FIREWALL } = require('./constants')\n\nconst BIRTHDAY_SOCKETS = 256\nconst HOLEPUNCH = b4a.from([0])\nconst HOLEPUNCH_TTL = 5\nconst DEFAULT_TTL = 64\nconst MAX_REOPENS = 3\n\nmodule.exports = class Holepuncher {\n  constructor(dht, session, isInitiator, remoteFirewall = FIREWALL.UNKNOWN) {\n    const holder = dht._socketPool.acquire()\n\n    this.dht = dht\n    this.session = session\n\n    this.nat = new Nat(dht, session, holder.socket)\n    this.nat.autoSample()\n\n    this.isInitiator = isInitiator\n\n    // events\n    this.onconnect = noop\n    this.onabort = noop\n\n    this.punching = false\n    this.connected = false\n    this.destroyed = false\n    this.randomized = false\n\n    // track remote state\n    this.remoteFirewall = remoteFirewall\n    this.remoteAddresses = []\n    this.remoteHolepunching = false\n\n    this._sleeper = new Sleeper()\n    this._reopening = null\n    this._timeout = null\n    this._punching = null\n    this._allHolders = []\n    this._holder = this._addRef(holder)\n  }\n\n  get socket() {\n    return this._holder.socket\n  }\n\n  updateRemote({ punching, firewall, addresses, verified }) {\n    const remoteAddresses = []\n\n    if (addresses) {\n      for (const addr of addresses) {\n        remoteAddresses.push({\n          host: addr.host,\n          port: addr.port,\n          verified: verified === addr.host || this._isVerified(addr.host)\n        })\n      }\n    }\n\n    this.remoteFirewall = firewall\n    this.remoteAddresses = remoteAddresses\n    this.remoteHolepunching = punching\n  }\n\n  _isVerified(host) {\n    for (const addr of this.remoteAddresses) {\n      if (addr.verified && addr.host === host) {\n        return true\n      }\n    }\n    return false\n  }\n\n  ping(addr, socket = this._holder.socket) {\n    return holepunch(socket, addr, false)\n  }\n\n  openSession(addr, socket = this._holder.socket) {\n    return holepunch(socket, addr, true)\n  }\n\n  async analyze(allowReopen) {\n    await this.nat.analyzing\n    if (this._unstable()) {\n      if (!allowReopen) return false\n      if (!this._reopening) this._reopening = this._reopen()\n      return this._reopening\n    }\n    return true\n  }\n\n  _unstable() {\n    // TODO!!: We need an additional heuristic here... If we were NOT random in the past we should also do this.\n    const firewall = this.nat.firewall\n    return (\n      (this.remoteFirewall >= FIREWALL.RANDOM && firewall >= FIREWALL.RANDOM) ||\n      firewall === FIREWALL.UNKNOWN\n    )\n  }\n\n  _reset() {\n    const prev = this._holder\n\n    this._allHolders.pop()\n    this._holder = this._addRef(this.dht._socketPool.acquire())\n\n    prev.release()\n    this.nat.destroy()\n\n    this.nat = new Nat(this.dht, this.session, this._holder.socket)\n    // TODO: maybe make auto sampling configurable somehow?\n    this.nat.autoSample()\n  }\n\n  _addRef(ref) {\n    this._allHolders.push(ref)\n    ref.onholepunchmessage = (msg, rinfo) => this._onholepunchmessage(msg, rinfo, ref)\n    return ref\n  }\n\n  _onholepunchmessage(_, addr, ref) {\n    if (!this.isInitiator) {\n      // TODO: we don't need this if we had a way to connect a socket to many hosts\n      holepunch(ref.socket, addr, false) // never fails\n      return\n    }\n\n    if (this.connected) return\n\n    this.connected = true\n    this.punching = false\n\n    for (const r of this._allHolders) {\n      if (r === ref) continue\n      r.release()\n    }\n\n    this._allHolders[0] = ref\n    while (this._allHolders.length > 1) this._allHolders.pop()\n\n    this._decrementRandomized()\n    this.onconnect(ref.socket, addr.port, addr.host)\n  }\n\n  _done() {\n    return this.destroyed || this.connected\n  }\n\n  async _reopen() {\n    for (let i = 0; this._unstable() && i < MAX_REOPENS && !this._done() && !this.punching; i++) {\n      this._reset()\n      await this.nat.analyzing\n    }\n\n    return coerceFirewall(this.nat.firewall) === FIREWALL.CONSISTENT\n  }\n\n  punch() {\n    if (!this._punching) this._punching = this._punch()\n    return this._punching\n  }\n\n  async _punch() {\n    if (this._done() || !this.remoteAddresses.length) return false\n\n    this.punching = true\n\n    // Coerce into consistency for now. Obvs we could make this this more efficient if we use that info\n    // but that's seldomly used since those will just use tcp most of the time.\n\n    const local = coerceFirewall(this.nat.firewall)\n    const remote = coerceFirewall(this.remoteFirewall)\n\n    // Note that most of these async functions are meant to run in the background\n    // which is why we don't await them here and why they are not allowed to throw\n\n    let remoteVerifiedAddress = null\n    for (const addr of this.remoteAddresses) {\n      if (addr.verified) {\n        remoteVerifiedAddress = addr\n        break\n      }\n    }\n\n    if (local === FIREWALL.CONSISTENT && remote === FIREWALL.CONSISTENT) {\n      this.dht.stats.punches.consistent++\n      this._consistentProbe()\n      return true\n    }\n\n    if (!remoteVerifiedAddress) return false\n\n    if (local === FIREWALL.CONSISTENT && remote >= FIREWALL.RANDOM) {\n      this.dht.stats.punches.random++\n      this._incrementRandomized()\n      this._randomProbes(remoteVerifiedAddress)\n      return true\n    }\n\n    if (local >= FIREWALL.RANDOM && remote === FIREWALL.CONSISTENT) {\n      this.dht.stats.punches.random++\n      this._incrementRandomized()\n      await this._openBirthdaySockets(remoteVerifiedAddress)\n      if (this.punching) this._keepAliveRandomNat(remoteVerifiedAddress)\n      return true\n    }\n\n    return false\n  }\n\n  // Note that this never throws so it is safe to run in the background\n  async _consistentProbe() {\n    // Here we do the sleep first because the \"fast open\" mode in the server just fired a ping\n    if (!this.isInitiator) await this._sleeper.pause(1000)\n\n    let tries = 0\n\n    while (this.punching && tries++ < 10) {\n      for (const addr of this.remoteAddresses) {\n        // only try unverified addresses every 4 ticks\n        if (!addr.verified && (tries & 3) !== 0) continue\n        await holepunch(this._holder.socket, addr, false)\n      }\n      if (this.punching) await this._sleeper.pause(1000)\n    }\n\n    this._autoDestroy()\n  }\n\n  // Note that this never throws so it is safe to run in the background\n  async _randomProbes(remoteAddr) {\n    let tries = 1750 // ~35s\n\n    while (this.punching && tries-- > 0) {\n      const addr = { host: remoteAddr.host, port: randomPort() }\n      await holepunch(this._holder.socket, addr, false)\n      if (this.punching) await this._sleeper.pause(20)\n    }\n\n    this._autoDestroy()\n  }\n\n  // Note that this never throws so it is safe to run in the background\n  async _keepAliveRandomNat(remoteAddr) {\n    let i = 0\n    let lowTTLRounds = 1\n\n    // TODO: experiment with this here. We just bursted all the messages in\n    // openOtherSockets to ensure the sockets are open, so it's potentially\n    // a good idea to slow down for a bit.\n    await this._sleeper.pause(100)\n\n    let tries = 1750 // ~35s\n\n    while (this.punching && tries-- > 0) {\n      if (i === this._allHolders.length) {\n        i = 0\n        if (lowTTLRounds > 0) lowTTLRounds--\n      }\n\n      await holepunch(this._allHolders[i++].socket, remoteAddr, lowTTLRounds > 0)\n      if (this.punching) await this._sleeper.pause(20)\n    }\n\n    this._autoDestroy()\n  }\n\n  async _openBirthdaySockets(remoteAddr) {\n    while (this.punching && this._allHolders.length < BIRTHDAY_SOCKETS) {\n      const ref = this._addRef(this.dht._socketPool.acquire())\n      await holepunch(ref.socket, remoteAddr, HOLEPUNCH_TTL)\n    }\n  }\n\n  _autoDestroy() {\n    if (!this.connected) this.destroy()\n  }\n\n  _incrementRandomized() {\n    if (!this.randomized) {\n      this.randomized = true\n      this.dht._randomPunches++\n    }\n  }\n\n  _decrementRandomized() {\n    if (this.randomized) {\n      this.dht._lastRandomPunch = Date.now()\n      this.randomized = false\n      this.dht._randomPunches--\n    }\n  }\n\n  destroy() {\n    if (this.destroyed) return\n    this.destroyed = true\n    this.punching = false\n\n    for (const ref of this._allHolders) ref.release()\n    this._allHolders = []\n    this.nat.destroy()\n\n    if (!this.connected) {\n      this._decrementRandomized()\n      this.onabort()\n    }\n  }\n\n  static ping(socket, addr) {\n    return holepunch(socket, addr, false)\n  }\n\n  static localAddresses(socket) {\n    return localAddresses(socket)\n  }\n\n  static matchAddress(myAddresses, externalAddresses) {\n    return matchAddress(myAddresses, externalAddresses)\n  }\n}\n\nfunction holepunch(socket, addr, lowTTL) {\n  return socket.send(HOLEPUNCH, addr.port, addr.host, lowTTL ? HOLEPUNCH_TTL : DEFAULT_TTL)\n}\n\nfunction randomPort() {\n  return (1000 + Math.random() * 64536) | 0\n}\n\nfunction coerceFirewall(fw) {\n  return fw === FIREWALL.OPEN ? FIREWALL.CONSISTENT : fw\n}\n\nfunction localAddresses(socket) {\n  const addrs = []\n  const { host, port } = socket.address()\n\n  if (host === '127.0.0.1') return [{ host, port }]\n\n  for (const n of socket.udx.networkInterfaces()) {\n    if (n.family !== 4 || n.internal) continue\n\n    addrs.push({ host: n.host, port })\n  }\n\n  if (addrs.length === 0) {\n    addrs.push({ host: '127.0.0.1', port })\n  }\n\n  return addrs\n}\n\nfunction matchAddress(localAddresses, remoteLocalAddresses) {\n  if (remoteLocalAddresses.length === 0) return null\n\n  let best = { segment: 1, addr: null }\n\n  for (const localAddress of localAddresses) {\n    // => 192.168.122.238\n    const a = localAddress.host.split('.')\n\n    for (const remoteAddress of remoteLocalAddresses) {\n      // => 192.168.0.23\n      // => 192.168.122.1\n      const b = remoteAddress.host.split('.')\n\n      // Matches 192.*.*.*\n      if (a[0] === b[0]) {\n        if (best.segment === 1) best = { segment: 2, addr: remoteAddress }\n\n        // Matches 192.168.*.*\n        if (a[1] === b[1]) {\n          if (best.segment === 2) best = { segment: 3, addr: remoteAddress }\n\n          // Matches 192.168.122.*\n          if (a[2] === b[2]) return remoteAddress\n        }\n      }\n    }\n  }\n\n  return best.addr\n}\n\nfunction noop() {}\nconst c = require('compact-encoding')\nconst net = require('compact-encoding-net')\n\nconst ipv4 = {\n  ...net.ipv4Address,\n  decode(state) {\n    const ip = net.ipv4Address.decode(state)\n    return {\n      host: ip.host,\n      port: ip.port\n    }\n  }\n}\n\nconst ipv4Array = c.array(ipv4)\n\nconst ipv6 = {\n  ...net.ipv6Address,\n  decode(state) {\n    const ip = net.ipv6Address.decode(state)\n    return {\n      host: ip.host,\n      port: ip.port\n    }\n  }\n}\n\nconst ipv6Array = c.array(ipv6)\n\nexports.handshake = {\n  preencode(state, m) {\n    state.end += 1 + 1 + (m.peerAddress ? 6 : 0) + (m.relayAddress ? 6 : 0)\n    c.buffer.preencode(state, m.noise)\n  },\n  encode(state, m) {\n    const flags = (m.peerAddress ? 1 : 0) | (m.relayAddress ? 2 : 0)\n\n    c.uint.encode(state, flags)\n    c.uint.encode(state, m.mode)\n    c.buffer.encode(state, m.noise)\n\n    if (m.peerAddress) ipv4.encode(state, m.peerAddress)\n    if (m.relayAddress) ipv4.encode(state, m.relayAddress)\n  },\n  decode(state) {\n    const flags = c.uint.decode(state)\n\n    return {\n      mode: c.uint.decode(state),\n      noise: c.buffer.decode(state),\n      peerAddress: flags & 1 ? ipv4.decode(state) : null,\n      relayAddress: flags & 2 ? ipv4.decode(state) : null\n    }\n  }\n}\n\nconst relayInfo = {\n  preencode(state, m) {\n    state.end += 12\n  },\n  encode(state, m) {\n    ipv4.encode(state, m.relayAddress)\n    ipv4.encode(state, m.peerAddress)\n  },\n  decode(state) {\n    return {\n      relayAddress: ipv4.decode(state),\n      peerAddress: ipv4.decode(state)\n    }\n  }\n}\n\nconst relayInfoArray = c.array(relayInfo)\n\nconst holepunchInfo = {\n  preencode(state, m) {\n    c.uint.preencode(state, m.id)\n    relayInfoArray.preencode(state, m.relays)\n  },\n  encode(state, m) {\n    c.uint.encode(state, m.id)\n    relayInfoArray.encode(state, m.relays)\n  },\n  decode(state) {\n    return {\n      id: c.uint.decode(state),\n      relays: relayInfoArray.decode(state)\n    }\n  }\n}\n\nconst udxInfo = {\n  preencode(state, m) {\n    state.end += 2 // version + features\n    c.uint.preencode(state, m.id)\n    c.uint.preencode(state, m.seq)\n  },\n  encode(state, m) {\n    c.uint.encode(state, 1)\n    c.uint.encode(state, m.reusableSocket ? 1 : 0)\n    c.uint.encode(state, m.id)\n    c.uint.encode(state, m.seq)\n  },\n  decode(state) {\n    const version = c.uint.decode(state)\n    const features = c.uint.decode(state)\n\n    return {\n      version,\n      reusableSocket: (features & 1) !== 0,\n      id: c.uint.decode(state),\n      seq: c.uint.decode(state)\n    }\n  }\n}\n\nconst secretStreamInfo = {\n  preencode(state, m) {\n    c.uint.preencode(state, 1)\n  },\n  encode(state, m) {\n    c.uint.encode(state, 1)\n  },\n  decode(state) {\n    return {\n      version: c.uint.decode(state)\n    }\n  }\n}\n\nconst relayThroughInfo = {\n  preencode(state, m) {\n    c.uint.preencode(state, 1) // version\n    c.uint.preencode(state, 0) // flags\n    c.fixed32.preencode(state, m.publicKey)\n    c.fixed32.preencode(state, m.token)\n  },\n  encode(state, m) {\n    c.uint.encode(state, 1)\n    c.uint.encode(state, 0)\n    c.fixed32.encode(state, m.publicKey)\n    c.fixed32.encode(state, m.token)\n  },\n  decode(state) {\n    const version = c.uint.decode(state)\n    c.uint.decode(state)\n\n    return {\n      version,\n      publicKey: c.fixed32.decode(state),\n      token: c.fixed32.decode(state)\n    }\n  }\n}\n\nexports.noisePayload = {\n  preencode(state, m) {\n    state.end += 4 // version + flags + error + firewall\n    if (m.holepunch) holepunchInfo.preencode(state, m.holepunch)\n    if (m.addresses4 && m.addresses4.length) ipv4Array.preencode(state, m.addresses4)\n    if (m.addresses6 && m.addresses6.length) ipv6Array.preencode(state, m.addresses6)\n    if (m.udx) udxInfo.preencode(state, m.udx)\n    if (m.secretStream) secretStreamInfo.preencode(state, m.secretStream)\n    if (m.relayThrough) relayThroughInfo.preencode(state, m.relayThrough)\n    if (m.relayAddresses) ipv4Array.preencode(state, m.relayAddresses)\n  },\n  encode(state, m) {\n    let flags = 0\n\n    if (m.holepunch) flags |= 1\n    if (m.addresses4 && m.addresses4.length) flags |= 2\n    if (m.addresses6 && m.addresses6.length) flags |= 4\n    if (m.udx) flags |= 8\n    if (m.secretStream) flags |= 16\n    if (m.relayThrough) flags |= 32\n    if (m.relayAddresses) flags |= 64\n\n    c.uint.encode(state, 1) // version\n    c.uint.encode(state, flags)\n    c.uint.encode(state, m.error)\n    c.uint.encode(state, m.firewall)\n\n    if (m.holepunch) holepunchInfo.encode(state, m.holepunch)\n    if (m.addresses4 && m.addresses4.length) ipv4Array.encode(state, m.addresses4)\n    if (m.addresses6 && m.addresses6.length) ipv6Array.encode(state, m.addresses6)\n    if (m.udx) udxInfo.encode(state, m.udx)\n    if (m.secretStream) secretStreamInfo.encode(state, m.secretStream)\n    if (m.relayThrough) relayThroughInfo.encode(state, m.relayThrough)\n    if (m.relayAddresses) ipv4Array.encode(state, m.relayAddresses)\n  },\n  decode(state) {\n    const version = c.uint.decode(state)\n\n    if (version !== 1) {\n      // Do not attempt to decode but return this back to the user so they can\n      // actually handle it\n      return {\n        version,\n        error: 0,\n        firewall: 0,\n        holepunch: null,\n        addresses4: [],\n        addresses6: [],\n        udx: null,\n        secretStream: null,\n        relayThrough: null,\n        relayAddresses: null\n      }\n    }\n\n    const flags = c.uint.decode(state)\n\n    return {\n      version,\n      error: c.uint.decode(state),\n      firewall: c.uint.decode(state),\n      holepunch: (flags & 1) !== 0 ? holepunchInfo.decode(state) : null,\n      addresses4: (flags & 2) !== 0 ? ipv4Array.decode(state) : [],\n      addresses6: (flags & 4) !== 0 ? ipv6Array.decode(state) : [],\n      udx: (flags & 8) !== 0 ? udxInfo.decode(state) : null,\n      secretStream: (flags & 16) !== 0 ? secretStreamInfo.decode(state) : null,\n      relayThrough: (flags & 32) !== 0 ? relayThroughInfo.decode(state) : null,\n      relayAddresses: (flags & 64) !== 0 ? ipv4Array.decode(state) : null\n    }\n  }\n}\n\nexports.holepunch = {\n  preencode(state, m) {\n    state.end += 2\n    c.uint.preencode(state, m.id)\n    c.buffer.preencode(state, m.payload)\n    if (m.peerAddress) ipv4.preencode(state, m.peerAddress)\n  },\n  encode(state, m) {\n    const flags = m.peerAddress ? 1 : 0\n    c.uint.encode(state, flags)\n    c.uint.encode(state, m.mode)\n    c.uint.encode(state, m.id)\n    c.buffer.encode(state, m.payload)\n    if (m.peerAddress) ipv4.encode(state, m.peerAddress)\n  },\n  decode(state) {\n    const flags = c.uint.decode(state)\n    return {\n      mode: c.uint.decode(state),\n      id: c.uint.decode(state),\n      payload: c.buffer.decode(state),\n      peerAddress: flags & 1 ? ipv4.decode(state) : null\n    }\n  }\n}\n\nexports.holepunchPayload = {\n  preencode(state, m) {\n    state.end += 4 // flags + error + firewall + round\n    if (m.addresses) ipv4Array.preencode(state, m.addresses)\n    if (m.remoteAddress) state.end += 6\n    if (m.token) state.end += 32\n    if (m.remoteToken) state.end += 32\n  },\n  encode(state, m) {\n    const flags =\n      (m.connected ? 1 : 0) |\n      (m.punching ? 2 : 0) |\n      (m.addresses ? 4 : 0) |\n      (m.remoteAddress ? 8 : 0) |\n      (m.token ? 16 : 0) |\n      (m.remoteToken ? 32 : 0)\n\n    c.uint.encode(state, flags)\n    c.uint.encode(state, m.error)\n    c.uint.encode(state, m.firewall)\n    c.uint.encode(state, m.round)\n\n    if (m.addresses) ipv4Array.encode(state, m.addresses)\n    if (m.remoteAddress) ipv4.encode(state, m.remoteAddress)\n    if (m.token) c.fixed32.encode(state, m.token)\n    if (m.remoteToken) c.fixed32.encode(state, m.remoteToken)\n  },\n  decode(state) {\n    const flags = c.uint.decode(state)\n\n    return {\n      error: c.uint.decode(state),\n      firewall: c.uint.decode(state),\n      round: c.uint.decode(state),\n      connected: (flags & 1) !== 0,\n      punching: (flags & 2) !== 0,\n      addresses: (flags & 4) !== 0 ? ipv4Array.decode(state) : null,\n      remoteAddress: (flags & 8) !== 0 ? ipv4.decode(state) : null,\n      token: (flags & 16) !== 0 ? c.fixed32.decode(state) : null,\n      remoteToken: (flags & 32) !== 0 ? c.fixed32.decode(state) : null\n    }\n  }\n}\n\nconst peer = (exports.peer = {\n  preencode(state, m) {\n    state.end += 32\n    ipv4Array.preencode(state, m.relayAddresses)\n  },\n  encode(state, m) {\n    c.fixed32.encode(state, m.publicKey)\n    ipv4Array.encode(state, m.relayAddresses)\n  },\n  decode(state) {\n    return {\n      publicKey: c.fixed32.decode(state),\n      relayAddresses: ipv4Array.decode(state)\n    }\n  }\n})\n\nconst peers = (exports.peers = c.array(peer))\n\nconst rawPeers = c.array(c.raw)\n\nexports.lookupRawReply = {\n  preencode(state, m) {\n    rawPeers.preencode(state, m.peers)\n    c.uint.preencode(state, m.bump)\n  },\n  encode(state, m) {\n    rawPeers.encode(state, m.peers)\n    c.uint.encode(state, m.bump)\n  },\n  decode(state) {\n    return {\n      peers: peers.decode(state),\n      bump: state.start < state.end ? c.uint.decode(state) : 0\n    }\n  }\n}\n\nexports.announce = {\n  preencode(state, m) {\n    state.end++ // flags\n    if (m.peer) peer.preencode(state, m.peer)\n    if (m.refresh) state.end += 32\n    if (m.signature) state.end += 64\n    if (m.bump) c.uint.preencode(state, m.bump)\n  },\n  encode(state, m) {\n    const flags = (m.peer ? 1 : 0) | (m.refresh ? 2 : 0) | (m.signature ? 4 : 0) | (m.bump ? 8 : 0)\n    c.uint.encode(state, flags)\n    if (m.peer) peer.encode(state, m.peer)\n    if (m.refresh) c.fixed32.encode(state, m.refresh)\n    if (m.signature) c.fixed64.encode(state, m.signature)\n    if (m.bump) c.uint.encode(state, m.bump)\n  },\n  decode(state) {\n    const flags = c.uint.decode(state)\n\n    return {\n      peer: (flags & 1) !== 0 ? peer.decode(state) : null,\n      refresh: (flags & 2) !== 0 ? c.fixed32.decode(state) : null,\n      signature: (flags & 4) !== 0 ? c.fixed64.decode(state) : null,\n      bump: (flags & 8) !== 0 ? c.uint.decode(state) : 0\n    }\n  }\n}\n\nexports.mutableSignable = {\n  preencode(state, m) {\n    c.uint.preencode(state, m.seq)\n    c.buffer.preencode(state, m.value)\n  },\n  encode(state, m) {\n    c.uint.encode(state, m.seq)\n    c.buffer.encode(state, m.value)\n  },\n  decode(state) {\n    return {\n      seq: c.uint.decode(state),\n      value: c.buffer.decode(state)\n    }\n  }\n}\n\nexports.mutablePutRequest = {\n  preencode(state, m) {\n    c.fixed32.preencode(state, m.publicKey)\n    c.uint.preencode(state, m.seq)\n    c.buffer.preencode(state, m.value)\n    c.fixed64.preencode(state, m.signature)\n  },\n  encode(state, m) {\n    c.fixed32.encode(state, m.publicKey)\n    c.uint.encode(state, m.seq)\n    c.buffer.encode(state, m.value)\n    c.fixed64.encode(state, m.signature)\n  },\n  decode(state) {\n    return {\n      publicKey: c.fixed32.decode(state),\n      seq: c.uint.decode(state),\n      value: c.buffer.decode(state),\n      signature: c.fixed64.decode(state)\n    }\n  }\n}\n\nexports.mutableGetResponse = {\n  preencode(state, m) {\n    c.uint.preencode(state, m.seq)\n    c.buffer.preencode(state, m.value)\n    c.fixed64.preencode(state, m.signature)\n  },\n  encode(state, m) {\n    c.uint.encode(state, m.seq)\n    c.buffer.encode(state, m.value)\n    c.fixed64.encode(state, m.signature)\n  },\n  decode(state) {\n    return {\n      seq: c.uint.decode(state),\n      value: c.buffer.decode(state),\n      signature: c.fixed64.decode(state)\n    }\n  }\n}\nconst { FIREWALL } = require('../lib/constants')\n\nmodule.exports = class Nat {\n  constructor(dht, session, socket) {\n    this._samplesHost = []\n    this._samplesFull = []\n    this._visited = new Map()\n    this._resolve = null\n    this._minSamples = 4\n    this._autoSampling = false\n\n    this.dht = dht\n    this.session = session\n    this.socket = socket\n\n    this.sampled = 0\n    this.firewall = dht.firewalled ? FIREWALL.UNKNOWN : FIREWALL.OPEN\n    this.addresses = null\n\n    this.analyzing = new Promise((resolve) => {\n      this._resolve = resolve\n    })\n  }\n\n  autoSample(retry = true) {\n    if (this._autoSampling) return\n    this._autoSampling = true\n\n    const self = this\n    const socket = this.socket\n    const maxPings = this._minSamples\n\n    let skip = this.dht.nodes.length >= 8 ? 5 : 0\n    let pending = 0\n\n    // TODO: it would be best to pick the nodes to help us based on latency to us\n    // That should reduce connect latency in general. We should investigate tracking that later on.\n\n    // TODO 2: try to pick nodes with different IPs as well, as that'll help multi IP cell connections...\n    // If we expose this from the nat sampler then the DHT should be able to help us filter out scams as well...\n\n    for (\n      let node = this.dht.nodes.latest;\n      node && this.sampled + pending < maxPings;\n      node = node.prev\n    ) {\n      if (skip > 0) {\n        skip--\n        continue\n      }\n\n      const ref = node.host + ':' + node.port\n\n      if (this._visited.has(ref)) continue\n      this._visited.set(ref, 1)\n\n      pending++\n      this.session.ping(node, { socket, retry: false }).then(onpong, onskip)\n    }\n\n    pending++\n    onskip()\n\n    function onpong(res) {\n      self.add(res.to, res.from)\n      onskip()\n    }\n\n    function onskip() {\n      if (--pending === 0 && self.sampled < self._minSamples) {\n        if (retry) {\n          self._autoSampling = false\n          self.autoSample(false)\n          return\n        }\n        self._resolve()\n      }\n    }\n  }\n\n  destroy() {\n    this._autoSampling = true\n    this._minSamples = 0\n    this._resolve()\n  }\n\n  unfreeze() {\n    this.frozen = false\n    this._updateFirewall()\n    this._updateAddresses()\n  }\n\n  freeze() {\n    this.frozen = true\n  }\n\n  _updateFirewall() {\n    if (!this.dht.firewalled) {\n      this.firewall = FIREWALL.OPEN\n      return\n    }\n\n    if (this.sampled < 3) return\n\n    const max = this._samplesFull[0].hits\n\n    if (max >= 3) {\n      this.firewall = FIREWALL.CONSISTENT\n      return\n    }\n\n    if (max === 1) {\n      this.firewall = FIREWALL.RANDOM\n      return\n    }\n\n    // else max === 2\n\n    // 1 host, >= 4 total samples ie, 2 bad ones -> random\n    if (this._samplesHost.length === 1 && this.sampled > 3) {\n      this.firewall = FIREWALL.RANDOM\n      return\n    }\n\n    // double hit on two different ips -> assume consistent\n    if (this._samplesHost.length > 1 && this._samplesFull[1].hits > 1) {\n      this.firewall = FIREWALL.CONSISTENT\n      return\n    }\n\n    // (4 is just means - all the samples we expect) - no decision - assume random\n    if (this.sampled > 4) {\n      this.firewall = FIREWALL.RANDOM\n    }\n  }\n\n  _updateAddresses() {\n    if (this.firewall === FIREWALL.UNKNOWN) {\n      this.addresses = null\n      return\n    }\n\n    if (this.firewall === FIREWALL.RANDOM) {\n      this.addresses = [this._samplesHost[0]]\n      return\n    }\n\n    if (this.firewall === FIREWALL.CONSISTENT) {\n      this.addresses = []\n      for (const addr of this._samplesFull) {\n        if (addr.hits >= 2 || this.addresses.length < 2) this.addresses.push(addr)\n      }\n    }\n  }\n\n  update() {\n    if (this.dht.firewalled && this.firewall === FIREWALL.OPEN) {\n      this.firewall = FIREWALL.UNKNOWN\n    }\n    this._updateFirewall()\n    this._updateAddresses()\n  }\n\n  add(addr, from) {\n    const ref = from.host + ':' + from.port\n\n    if (this._visited.get(ref) === 2) return\n    this._visited.set(ref, 2)\n\n    addSample(this._samplesHost, addr.host, 0)\n    addSample(this._samplesFull, addr.host, addr.port)\n\n    if ((++this.sampled >= 3 || !this.dht.firewalled) && !this.frozen) {\n      this.update()\n    }\n\n    if (this.firewall === FIREWALL.CONSISTENT || this.firewall === FIREWALL.OPEN) {\n      this._resolve()\n    } else if (this.sampled >= this._minSamples) {\n      this._resolve()\n    }\n  }\n}\n\nfunction addSample(samples, host, port) {\n  for (let i = 0; i < samples.length; i++) {\n    const s = samples[i]\n\n    if (s.port !== port || s.host !== host) continue\n    s.hits++\n\n    for (; i > 0; i--) {\n      const prev = samples[i - 1]\n      if (prev.hits >= s.hits) return\n      samples[i - 1] = s\n      samples[i] = prev\n    }\n\n    return\n  }\n\n  samples.push({\n    host,\n    port,\n    hits: 1\n  })\n}\nconst NoiseSecretStream = require('@hyperswarm/secret-stream')\nconst NoiseHandshake = require('noise-handshake')\nconst curve = require('noise-curve-ed')\nconst c = require('compact-encoding')\nconst b4a = require('b4a')\nconst sodium = require('sodium-universal')\nconst m = require('./messages')\nconst { NS } = require('./constants')\nconst { HANDSHAKE_UNFINISHED } = require('./errors')\n\nconst NOISE_PROLOUGE = NS.PEER_HANDSHAKE\n\nmodule.exports = class NoiseWrap {\n  constructor(keyPair, remotePublicKey) {\n    this.isInitiator = !!remotePublicKey\n    this.remotePublicKey = remotePublicKey\n    this.keyPair = keyPair\n    this.handshake = new NoiseHandshake('IK', this.isInitiator, keyPair, { curve })\n    this.handshake.initialise(NOISE_PROLOUGE, remotePublicKey)\n  }\n\n  send(payload) {\n    const buf = c.encode(m.noisePayload, payload)\n    return this.handshake.send(buf)\n  }\n\n  recv(buf) {\n    const payload = c.decode(m.noisePayload, this.handshake.recv(buf))\n    this.remotePublicKey = b4a.toBuffer(this.handshake.rs)\n    return payload\n  }\n\n  final() {\n    if (!this.handshake.complete) throw HANDSHAKE_UNFINISHED()\n\n    const holepunchSecret = b4a.allocUnsafe(32)\n\n    sodium.crypto_generichash(holepunchSecret, NS.PEER_HOLEPUNCH, this.handshake.hash)\n\n    return {\n      isInitiator: this.isInitiator,\n      publicKey: this.keyPair.publicKey,\n      streamId: this.streamId,\n      remotePublicKey: this.remotePublicKey,\n      remoteId: NoiseSecretStream.id(this.handshake.hash, !this.isInitiator),\n      holepunchSecret,\n      hash: b4a.toBuffer(this.handshake.hash),\n      rx: b4a.toBuffer(this.handshake.rx),\n      tx: b4a.toBuffer(this.handshake.tx)\n    }\n  }\n}\nconst c = require('compact-encoding')\nconst sodium = require('sodium-universal')\nconst RecordCache = require('record-cache')\nconst Cache = require('xache')\nconst b4a = require('b4a')\nconst unslab = require('unslab')\n\nconst { encodeUnslab } = require('./encode')\nconst m = require('./messages')\nconst { NS, ERROR } = require('./constants')\n\nconst EMPTY = b4a.alloc(0)\nconst TMP = b4a.allocUnsafe(32)\nconst MAX_BUMP_DRIFT = 60_000\n\nmodule.exports = class Persistent {\n  constructor(dht, opts) {\n    this.dht = dht\n    this.records = new RecordCache(opts.records)\n    this.bumps = new Cache(opts.bumps)\n    this.refreshes = new Cache(opts.refreshes)\n    this.mutables = new Cache(opts.mutables)\n    this.immutables = new Cache(opts.immutables)\n  }\n\n  onlookup(req) {\n    if (!req.target) return\n\n    const k = b4a.toString(req.target, 'hex')\n    const records = this.records.get(k, 20)\n    const bump = this.bumps.get(k) || 0\n    const fwd = this.dht._router.get(k)\n\n    if (fwd && records.length < 20) records.push(fwd.record)\n\n    req.reply(records.length ? c.encode(m.lookupRawReply, { peers: records, bump }) : null)\n  }\n\n  onfindpeer(req) {\n    if (!req.target) return\n    const fwd = this.dht._router.get(req.target)\n    req.reply(fwd ? fwd.record : null)\n  }\n\n  unannounce(target, publicKey) {\n    const k = b4a.toString(target, 'hex')\n    sodium.crypto_generichash(TMP, publicKey)\n\n    if (b4a.equals(TMP, target)) this.dht._router.delete(k)\n    this.records.remove(k, publicKey)\n  }\n\n  onunannounce(req) {\n    if (!req.target || !req.token) return\n\n    const unann = decode(m.announce, req.value)\n    if (unann === null) return\n\n    const { peer, signature } = unann\n    if (!peer || !signature) return\n\n    const signable = annSignable(req.target, req.token, this.dht.id, unann, NS.UNANNOUNCE)\n\n    if (!sodium.crypto_sign_verify_detached(signature, signable, peer.publicKey)) {\n      return\n    }\n\n    this.unannounce(req.target, peer.publicKey)\n    req.reply(null, { token: false, closerNodes: false })\n  }\n\n  _onrefresh(token, req) {\n    sodium.crypto_generichash(TMP, token)\n    const activeRefresh = b4a.toString(TMP, 'hex')\n\n    const r = this.refreshes.get(activeRefresh)\n    if (!r) return\n\n    const { announceSelf, k, record } = r\n    const publicKey = record.subarray(0, 32)\n\n    if (announceSelf) {\n      this.dht._router.set(k, {\n        relay: req.from,\n        record,\n        onconnect: null,\n        onholepunch: null\n      })\n      this.records.remove(k, publicKey)\n    } else {\n      this.records.add(k, publicKey, record)\n    }\n\n    this.refreshes.delete(activeRefresh)\n    this.refreshes.set(b4a.toString(token, 'hex'), r)\n\n    req.reply(null, { token: false, closerNodes: false })\n  }\n\n  onannounce(req) {\n    if (!req.target || !req.token || !this.dht.id) return\n\n    const ann = decode(m.announce, req.value)\n    if (ann === null) return\n\n    const signable = annSignable(req.target, req.token, this.dht.id, ann, NS.ANNOUNCE)\n    const { peer, refresh, signature, bump } = ann\n\n    if (!peer) {\n      if (!refresh) return\n      this._onrefresh(refresh, req)\n      return\n    }\n\n    if (!signature || !sodium.crypto_sign_verify_detached(signature, signable, peer.publicKey)) {\n      return\n    }\n\n    // TODO: it would be potentially be more optimal to allow more than 3 addresses here for a findPeer response\n    // and only use max 3 for a lookup reply\n    if (peer.relayAddresses.length > 3) {\n      peer.relayAddresses = peer.relayAddresses.slice(0, 3)\n    }\n\n    sodium.crypto_generichash(TMP, peer.publicKey)\n\n    const k = b4a.toString(req.target, 'hex')\n    const announceSelf = b4a.equals(TMP, req.target)\n    const record = encodeUnslab(m.peer, peer)\n\n    if (announceSelf) {\n      this.dht._router.set(k, {\n        relay: req.from,\n        record,\n        onconnect: null,\n        onholepunch: null\n      })\n      this.records.remove(k, peer.publicKey)\n    } else {\n      const currentBump = this.bumps.get(k) || 0\n      if (bump > currentBump && bump <= Date.now() + MAX_BUMP_DRIFT) this.bumps.set(k, bump)\n      this.records.add(k, peer.publicKey, record)\n    }\n\n    if (refresh) {\n      this.refreshes.set(b4a.toString(refresh, 'hex'), { k, record, announceSelf })\n    }\n\n    req.reply(null, { token: false, closerNodes: false })\n  }\n\n  onmutableget(req) {\n    if (!req.target || !req.value) return\n\n    let seq = 0\n    try {\n      seq = c.decode(c.uint, req.value)\n    } catch {\n      return\n    }\n\n    const k = b4a.toString(req.target, 'hex')\n    const value = this.mutables.get(k)\n\n    if (!value) {\n      req.reply(null)\n      return\n    }\n\n    const localSeq = c.decode(c.uint, value)\n    req.reply(localSeq < seq ? null : value)\n  }\n\n  onmutableput(req) {\n    if (!req.target || !req.token || !req.value) return\n\n    const p = decode(m.mutablePutRequest, req.value)\n    if (!p) return\n\n    const { publicKey, seq, value, signature } = p\n\n    const hash = b4a.allocUnsafe(32)\n    sodium.crypto_generichash(hash, publicKey)\n    if (!b4a.equals(hash, req.target)) return\n\n    if (!value || !verifyMutable(signature, seq, value, publicKey)) return\n\n    const k = b4a.toString(hash, 'hex')\n    const local = this.mutables.get(k)\n\n    if (local) {\n      const existing = c.decode(m.mutableGetResponse, local)\n      if (existing.value && existing.seq === seq && b4a.compare(value, existing.value) !== 0) {\n        req.error(ERROR.SEQ_REUSED)\n        return\n      }\n      if (seq < existing.seq) {\n        req.error(ERROR.SEQ_TOO_LOW)\n        return\n      }\n    }\n\n    this.mutables.set(k, encodeUnslab(m.mutableGetResponse, { seq, value, signature }))\n    req.reply(null)\n  }\n\n  onimmutableget(req) {\n    if (!req.target) return\n\n    const k = b4a.toString(req.target, 'hex')\n    const value = this.immutables.get(k)\n\n    req.reply(value || null)\n  }\n\n  onimmutableput(req) {\n    if (!req.target || !req.token || !req.value) return\n\n    const hash = b4a.alloc(32)\n    sodium.crypto_generichash(hash, req.value)\n    if (!b4a.equals(hash, req.target)) return\n\n    const k = b4a.toString(hash, 'hex')\n    this.immutables.set(k, unslab(req.value))\n\n    req.reply(null)\n  }\n\n  destroy() {\n    this.records.destroy()\n    this.refreshes.destroy()\n    this.mutables.destroy()\n    this.immutables.destroy()\n  }\n\n  static signMutable(seq, value, keyPair) {\n    const signable = b4a.allocUnsafe(32 + 32)\n    const hash = signable.subarray(32)\n\n    signable.set(NS.MUTABLE_PUT, 0)\n\n    sodium.crypto_generichash(hash, c.encode(m.mutableSignable, { seq, value }))\n    return sign(signable, keyPair)\n  }\n\n  static verifyMutable(signature, seq, value, publicKey) {\n    return verifyMutable(signature, seq, value, publicKey)\n  }\n\n  static signAnnounce(target, token, id, ann, keyPair) {\n    return sign(annSignable(target, token, id, ann, NS.ANNOUNCE), keyPair)\n  }\n\n  static signUnannounce(target, token, id, ann, keyPair) {\n    return sign(annSignable(target, token, id, ann, NS.UNANNOUNCE), keyPair)\n  }\n}\n\nfunction verifyMutable(signature, seq, value, publicKey) {\n  const signable = b4a.allocUnsafe(32 + 32)\n  const hash = signable.subarray(32)\n\n  signable.set(NS.MUTABLE_PUT, 0)\n\n  sodium.crypto_generichash(hash, c.encode(m.mutableSignable, { seq, value }))\n  return sodium.crypto_sign_verify_detached(signature, signable, publicKey)\n}\n\nfunction annSignable(target, token, id, ann, ns) {\n  const signable = b4a.allocUnsafe(32 + 32)\n  const hash = signable.subarray(32)\n\n  signable.set(ns, 0)\n\n  sodium.crypto_generichash_batch(hash, [\n    target,\n    id,\n    token,\n    c.encode(m.peer, ann.peer), // note that this is the partial encoding of the announce message so we could just use that for perf\n    ann.refresh || EMPTY\n  ])\n\n  return signable\n}\n\nfunction sign(signable, keyPair) {\n  if (keyPair.sign) {\n    return keyPair.sign(signable)\n  }\n  const secretKey = keyPair.secretKey ? keyPair.secretKey : keyPair\n  const signature = b4a.allocUnsafe(64)\n  sodium.crypto_sign_detached(signature, signable, secretKey)\n  return signature\n}\n\nfunction decode(enc, val) {\n  try {\n    return val && c.decode(enc, val)\n  } catch (err) {\n    return null\n  }\n}\nmodule.exports = class RawStreamSet {\n  constructor(dht) {\n    this._dht = dht\n\n    this._prefix = 16 - 1 // 16 is the default stream-set side in udx\n    this._streams = new Map()\n  }\n\n  get size() {\n    return this._streams.size\n  }\n\n  [Symbol.iterator]() {\n    return this._streams.values()\n  }\n\n  add(opts) {\n    const self = this\n\n    // TODO: we should prob have a udx helper for id generation, given the slight complexity\n    // of the below. requires a PRNG in udx tho.\n\n    let id = 0\n\n    while (true) {\n      id = (Math.random() * 0x100000000) >>> 0\n\n      if (this._streams.has(id & this._prefix)) continue\n      break\n    }\n\n    // always have ~50% change of rolling a free one\n    if (2 * this._streams.size >= this._prefix) {\n      // ie 0b11111 = 0b1111 + 1 + 0b1111\n      this._prefix = 2 * this._prefix + 1\n\n      // move the prefixes over\n      const next = new Map()\n      for (const stream of this._streams.values()) {\n        next.set(stream.id & this._prefix, stream)\n      }\n      this._streams = next\n    }\n\n    const stream = this._dht.udx.createStream(id, opts)\n    this._streams.set(id & this._prefix, stream)\n\n    stream.on('close', onclose)\n\n    return stream\n\n    function onclose() {\n      self._streams.delete(id & self._prefix)\n    }\n  }\n\n  async clear() {\n    const destroying = []\n\n    for (const stream of this._streams.values()) {\n      destroying.push(new Promise((resolve) => stream.once('close', resolve).destroy()))\n    }\n\n    await Promise.allSettled(destroying)\n  }\n}\nconst c = require('compact-encoding')\nconst Cache = require('xache')\nconst safetyCatch = require('safety-catch')\nconst b4a = require('b4a')\nconst { handshake, holepunch } = require('./messages')\nconst { COMMANDS } = require('./constants')\nconst { BAD_HANDSHAKE_REPLY, BAD_HOLEPUNCH_REPLY } = require('./errors')\n\nconst FROM_CLIENT = 0\nconst FROM_SERVER = 1\nconst FROM_RELAY = 2\nconst FROM_SECOND_RELAY = 3\nconst REPLY = 4\n\n// TODO: While the current design is very trustless in regards to clients/servers trusting the DHT,\n// we should add a bunch of rate limits everywhere, especially including here to avoid bad users\n// using a DHT node to relay traffic indiscriminately using the connect/holepunch messages.\n// That's mostly from an abuse POV as none of the messsages do amplication.\n\nmodule.exports = class Router {\n  constructor(dht, opts) {\n    this.dht = dht\n    this.forwards = new Cache(opts.forwards)\n  }\n\n  set(target, state) {\n    if (state.onpeerhandshake) {\n      this.forwards.retain(toString(target), state)\n    } else {\n      this.forwards.set(toString(target), state)\n    }\n  }\n\n  get(target) {\n    return this.forwards.get(toString(target))\n  }\n\n  delete(target) {\n    this.forwards.delete(toString(target))\n  }\n\n  destroy() {\n    this.forwards.destroy()\n  }\n\n  async peerHandshake(target, { noise, peerAddress, relayAddress, socket, session }, to) {\n    const dht = this.dht\n\n    const requestValue = c.encode(handshake, {\n      mode: FROM_CLIENT,\n      noise,\n      peerAddress,\n      relayAddress\n    })\n\n    const res = await dht.request(\n      { command: COMMANDS.PEER_HANDSHAKE, target, value: requestValue },\n      to,\n      { socket, session }\n    )\n\n    const hs = decode(handshake, res.value)\n    if (\n      !hs ||\n      hs.mode !== REPLY ||\n      to.host !== res.from.host ||\n      to.port !== res.from.port ||\n      !hs.noise\n    ) {\n      throw BAD_HANDSHAKE_REPLY()\n    }\n\n    return {\n      noise: hs.noise,\n      relayed: !!hs.peerAddress,\n      serverAddress: hs.peerAddress || to,\n      clientAddress: res.to\n    }\n  }\n\n  async onpeerhandshake(req) {\n    const hs = req.value && decode(handshake, req.value)\n    if (!hs) return\n\n    const { mode, noise, peerAddress, relayAddress } = hs\n\n    const state = req.target && this.get(req.target)\n    const isServer = !!(state && state.onpeerhandshake)\n    const relay = state && state.relay\n\n    if (isServer) {\n      let reply = null\n      try {\n        reply = noise && (await state.onpeerhandshake({ noise, peerAddress }, req))\n      } catch (e) {\n        safetyCatch(e)\n        return\n      }\n      if (!reply || !reply.noise) return\n      const opts = { socket: reply.socket, closerNodes: false, token: false }\n\n      switch (mode) {\n        case FROM_CLIENT: {\n          req.reply(\n            c.encode(handshake, { mode: REPLY, noise: reply.noise, peerAddress: null }),\n            opts\n          )\n          return\n        }\n        case FROM_RELAY: {\n          req.relay(\n            c.encode(handshake, { mode: FROM_SERVER, noise: reply.noise, peerAddress }),\n            req.from,\n            opts\n          )\n          return\n        }\n        case FROM_SECOND_RELAY: {\n          if (!relayAddress) return\n          req.relay(\n            c.encode(handshake, { mode: FROM_SERVER, noise: reply.noise, peerAddress }),\n            relayAddress,\n            opts\n          )\n          return // eslint-disable-line\n        }\n      }\n    } else {\n      switch (mode) {\n        case FROM_CLIENT: {\n          // TODO: if no relay is known route closer to the target instead of timing out\n          if (!noise) return\n          if (!relay && !relayAddress) {\n            // help the user route\n            req.reply(null, { token: false, closerNodes: true })\n            return\n          }\n          req.relay(\n            c.encode(handshake, {\n              mode: FROM_RELAY,\n              noise,\n              peerAddress: req.from,\n              relayAddress: null\n            }),\n            relayAddress || relay\n          )\n          return\n        }\n        case FROM_RELAY: {\n          if (!relay || !noise) return\n          req.relay(\n            c.encode(handshake, {\n              mode: FROM_SECOND_RELAY,\n              noise,\n              peerAddress,\n              relayAddress: req.from\n            }),\n            relay\n          )\n          return\n        }\n        case FROM_SERVER: {\n          if (!peerAddress || !noise) return\n          req.reply(\n            c.encode(handshake, { mode: REPLY, noise, peerAddress: req.from, relayAddress: null }),\n            { to: peerAddress, closerNodes: false, token: false }\n          )\n          return // eslint-disable-line\n        }\n      }\n    }\n  }\n\n  async peerHolepunch(target, { id, payload, peerAddress, socket, session }, to) {\n    const dht = this.dht\n    const requestValue = c.encode(holepunch, {\n      mode: FROM_CLIENT,\n      id,\n      payload,\n      peerAddress\n    })\n\n    const res = await dht.request(\n      { command: COMMANDS.PEER_HOLEPUNCH, target, value: requestValue },\n      to,\n      { socket, session }\n    )\n\n    const hp = decode(holepunch, res.value)\n    if (!hp || hp.mode !== REPLY || to.host !== res.from.host || to.port !== res.from.port) {\n      throw BAD_HOLEPUNCH_REPLY()\n    }\n\n    return {\n      from: res.from,\n      to: res.to,\n      payload: hp.payload,\n      peerAddress: hp.peerAddress || to\n    }\n  }\n\n  async onpeerholepunch(req) {\n    const hp = req.value && decode(holepunch, req.value)\n    if (!hp) return\n\n    const { mode, id, payload, peerAddress } = hp\n\n    const state = req.target && this.get(req.target)\n    const isServer = !!(state && state.onpeerholepunch)\n    const relay = state && state.relay\n\n    switch (mode) {\n      case FROM_CLIENT: {\n        if (!peerAddress && !relay) return\n        req.relay(\n          c.encode(holepunch, { mode: FROM_RELAY, id, payload, peerAddress: req.from }),\n          peerAddress || relay\n        )\n        return\n      }\n      case FROM_RELAY: {\n        if (!isServer || !peerAddress) return\n        let reply = null\n        try {\n          reply = await state.onpeerholepunch({ id, payload, peerAddress }, req)\n        } catch (e) {\n          safetyCatch(e)\n          return\n        }\n        if (!reply) return\n        const opts = { socket: reply.socket, closerNodes: false, token: false }\n        req.relay(\n          c.encode(holepunch, { mode: FROM_SERVER, id: 0, payload: reply.payload, peerAddress }),\n          req.from,\n          opts\n        )\n        return\n      }\n      case FROM_SERVER: {\n        req.reply(c.encode(holepunch, { mode: REPLY, id, payload, peerAddress: req.from }), {\n          to: peerAddress,\n          closerNodes: false,\n          token: false\n        })\n        return // eslint-disable-line\n      }\n    }\n  }\n}\n\nfunction decode(enc, val) {\n  try {\n    return c.decode(enc, val)\n  } catch {\n    return null\n  }\n}\n\nfunction toString(t) {\n  return typeof t === 'string' ? t : b4a.toString(t, 'hex')\n}\nconst sodium = require('sodium-universal')\nconst b4a = require('b4a')\nconst { holepunchPayload } = require('./messages')\n\nmodule.exports = class HolepunchPayload {\n  constructor(holepunchSecret) {\n    this._sharedSecret = holepunchSecret\n    this._localSecret = b4a.allocUnsafe(32)\n\n    sodium.randombytes_buf(this._localSecret)\n  }\n\n  decrypt(buffer) {\n    const state = { start: 24, end: buffer.byteLength - 16, buffer }\n\n    if (state.end <= state.start) return null\n\n    const nonce = buffer.subarray(0, 24)\n    const msg = state.buffer.subarray(state.start, state.end)\n    const cipher = state.buffer.subarray(state.start)\n\n    if (!sodium.crypto_secretbox_open_easy(msg, cipher, nonce, this._sharedSecret)) return null\n\n    try {\n      return holepunchPayload.decode(state)\n    } catch {\n      return null\n    }\n  }\n\n  encrypt(payload) {\n    const state = { start: 24, end: 24, buffer: null }\n    holepunchPayload.preencode(state, payload)\n    state.buffer = b4a.allocUnsafe(state.end + 16)\n\n    const nonce = state.buffer.subarray(0, 24)\n    const msg = state.buffer.subarray(state.start, state.end)\n    const cipher = state.buffer.subarray(state.start)\n\n    holepunchPayload.encode(state, payload)\n    sodium.randombytes_buf(nonce)\n    sodium.crypto_secretbox_easy(cipher, msg, nonce, this._sharedSecret)\n\n    return state.buffer\n  }\n\n  token(addr) {\n    const out = b4a.allocUnsafe(32)\n    sodium.crypto_generichash(out, b4a.from(addr.host), this._localSecret)\n    return out\n  }\n}\nconst DONE = Promise.resolve(true)\nconst DESTROYED = Promise.resolve(false)\n\nmodule.exports = class Semaphore {\n  constructor(limit = 1) {\n    this.limit = limit\n    this.active = 0\n    this.waiting = []\n\n    this.flushedPromise = null\n    this.flushedResolve = null\n\n    this.destroyed = false\n\n    this._onwait = this._queueWaiting.bind(this)\n    this._onflush = this._queueFlushed.bind(this)\n  }\n\n  _queueWaiting(resolve) {\n    this.waiting.push(resolve)\n  }\n\n  _queueFlushed(resolve) {\n    this.flushedResolve = resolve\n  }\n\n  wait() {\n    if (this.destroyed === true) return DESTROYED\n\n    if (this.active < this.limit && this.waiting.length === 0) {\n      this.active++\n      return DONE\n    }\n\n    return new Promise(this._onwait)\n  }\n\n  signal() {\n    if (this.destroyed === true) return\n\n    this.active--\n    while (this.active < this.limit && this.waiting.length > 0 && this.destroyed === false) {\n      this.active++\n      this.waiting.shift()(true)\n    }\n\n    if (this.active === 0 && this.flushedResolve) {\n      const resolve = this.flushedResolve\n      this.flushedResolve = null\n      this.flushedPromise = null\n      resolve(true)\n    }\n  }\n\n  async flush() {\n    if (this.destroyed === true) return\n    if (this.active === 0) return\n    if (this.flushedPromise) return this.flushedPromise\n    this.flushedPromise = new Promise(this._onflush)\n    return this.flushedPromise\n  }\n\n  destroy() {\n    this.destroyed = true\n    this.active = 0\n    while (this.waiting.length) this.waiting.pop()(false)\n    if (this.flushedResolve) this.flushedResolve(false)\n  }\n}\nconst { EventEmitter } = require('events')\nconst safetyCatch = require('safety-catch')\nconst NoiseSecretStream = require('@hyperswarm/secret-stream')\nconst b4a = require('b4a')\nconst relay = require('blind-relay')\nconst NoiseWrap = require('./noise-wrap')\nconst Announcer = require('./announcer')\nconst { FIREWALL, ERROR } = require('./constants')\nconst { unslabbedHash } = require('./crypto')\nconst SecurePayload = require('./secure-payload')\nconst Holepuncher = require('./holepuncher')\nconst { isPrivate } = require('bogon')\nconst { ALREADY_LISTENING, NODE_DESTROYED, KEYPAIR_ALREADY_USED } = require('./errors')\n\nconst HANDSHAKE_CLEAR_WAIT = 10000\nconst HANDSHAKE_INITIAL_TIMEOUT = 10000\n\nmodule.exports = class Server extends EventEmitter {\n  constructor(dht, opts = {}) {\n    super()\n\n    this.dht = dht\n    this.target = null\n\n    this.closed = false\n    this.firewall = opts.firewall || (() => false)\n    this.holepunch = opts.holepunch || (() => true)\n    this.relayThrough = opts.relayThrough || null\n    this.relayKeepAlive = opts.relayKeepAlive || 5000\n    this.pool = opts.pool || null\n    this.createHandshake = opts.createHandshake || defaultCreateHandshake\n    this.createSecretStream = opts.createSecretStream || defaultCreateSecretStream\n    this.suspended = false\n    this.handshakeClearWait = opts.handshakeClearWait || HANDSHAKE_CLEAR_WAIT\n\n    this._shareLocalAddress = opts.shareLocalAddress !== false\n    this._reusableSocket = !!opts.reusableSocket\n    this._neverPunch = opts.holepunch === false // useful for fully disabling punching\n    this._keyPair = null\n    this._announcer = null\n    this._connects = new Map()\n    this._holepunches = []\n    this._listening = null\n    this._closing = null\n  }\n\n  get listening() {\n    return this._listening !== null\n  }\n\n  get publicKey() {\n    return this._keyPair && this._keyPair.publicKey\n  }\n\n  get relayAddresses() {\n    return this._announcer ? this._announcer.relayAddresses : []\n  }\n\n  onconnection(encryptedSocket) {\n    this.emit('connection', encryptedSocket)\n  }\n\n  async suspend({ log = noop } = {}) {\n    log('Suspending hyperdht server')\n    if (this._listening !== null) await this._listening\n    log('Suspending hyperdht server (post listening)')\n    this.suspended = true\n    this._clearAll()\n    return this._announcer ? this._announcer.suspend({ log }) : Promise.resolve()\n  }\n\n  async resume() {\n    if (this._listening !== null) await this._listening\n    this.suspended = false\n    return this._announcer ? this._announcer.resume() : Promise.resolve()\n  }\n\n  address() {\n    if (!this._keyPair) return null\n\n    return {\n      publicKey: this._keyPair.publicKey,\n      host: this.dht.host,\n      port: this.dht.port\n    }\n  }\n\n  close() {\n    if (this._closing) return this._closing\n    this._closing = this._close()\n    return this._closing\n  }\n\n  _gc() {\n    this.dht.listening.delete(this)\n    if (this.target) this.dht._router.delete(this.target)\n  }\n\n  async _stopListening() {\n    try {\n      if (this._announcer) await this._announcer.stop()\n    } catch {\n      // ignore\n    }\n\n    this._announcer = null\n    this._listening = null\n    this._keyPair = null\n  }\n\n  async _close() {\n    if (this._listening === null) {\n      this.closed = true\n      this.emit('close')\n      return\n    }\n\n    try {\n      await this._listening\n    } catch {}\n\n    this._gc()\n    this._clearAll()\n\n    await this._stopListening()\n\n    this.closed = true\n    this.emit('close')\n  }\n\n  _clearAll() {\n    while (this._holepunches.length > 0) {\n      const h = this._holepunches.pop()\n      if (h && h.puncher) h.puncher.destroy()\n      if (h && h.clearing) clearTimeout(h.clearing)\n      if (h && h.prepunching) clearTimeout(h.prepunching)\n      if (h && h.rawStream) h.rawStream.destroy()\n    }\n\n    this._connects.clear()\n  }\n\n  async listen(keyPair = this.dht.defaultKeyPair, opts = {}) {\n    if (this._listening !== null) throw ALREADY_LISTENING()\n    if (this.dht.destroyed) throw NODE_DESTROYED()\n\n    this._listening = this._listen(keyPair, opts)\n    await this._listening\n    return this\n  }\n\n  async _listen(keyPair, opts) {\n    // From now on, the DHT object which created me is responsible for closing me\n    this.dht.listening.add(this)\n\n    try {\n      await this.dht.bind()\n      if (this._closing) return\n\n      for (const s of this.dht.listening) {\n        if (s._keyPair && b4a.equals(s._keyPair.publicKey, keyPair.publicKey)) {\n          throw KEYPAIR_ALREADY_USED()\n        }\n      }\n\n      this.target = unslabbedHash(keyPair.publicKey)\n      this._keyPair = keyPair\n      this._announcer = new Announcer(this.dht, keyPair, this.target, opts)\n\n      this.dht._router.set(this.target, {\n        relay: null,\n        record: this._announcer.record,\n        onpeerhandshake: this._onpeerhandshake.bind(this),\n        onpeerholepunch: this._onpeerholepunch.bind(this)\n      })\n\n      // warm it up for now\n      this._localAddresses().catch(safetyCatch)\n\n      await this._announcer.start()\n    } catch (err) {\n      await this._stopListening()\n      this._gc()\n      throw err\n    }\n\n    if (this._closing) return\n    if (this.suspended) await this._announcer.suspend()\n\n    if (this._closing) return\n    if (this.dht.destroyed) throw NODE_DESTROYED()\n\n    if (this.pool) this.pool._attachServer(this)\n\n    this.emit('listening')\n  }\n\n  refresh() {\n    if (this._announcer && !this.suspended) this._announcer.refresh()\n  }\n\n  notifyOnline() {\n    if (this._announcer) this._announcer.online.notify()\n  }\n\n  _localAddresses() {\n    return this.dht.validateLocalAddresses(Holepuncher.localAddresses(this.dht.io.serverSocket))\n  }\n\n  async _addHandshake(k, noise, clientAddress, { from, to: serverAddress, socket }, direct) {\n    let id = this._holepunches.indexOf(null)\n    if (id === -1) id = this._holepunches.push(null) - 1\n\n    const hs = {\n      round: 0,\n      reply: null,\n      puncher: null,\n      payload: null,\n      rawStream: null,\n      encryptedSocket: null,\n      prepunching: null,\n      firewalled: true,\n      clearing: null,\n      onsocket: null,\n      aborted: false,\n\n      // Relay state\n      relayTimeout: null,\n      relayToken: null,\n      relaySocket: null,\n      relayClient: null,\n      relayPaired: false\n    }\n\n    this._holepunches[id] = hs\n\n    const handshake = this.createHandshake(this._keyPair, null)\n\n    let remotePayload\n    try {\n      remotePayload = await handshake.recv(noise)\n    } catch (err) {\n      safetyCatch(err)\n      this._clearLater(hs, id, k)\n      return null\n    }\n\n    if (this._closing || this.suspended) return null\n\n    try {\n      hs.firewalled = await this.firewall(handshake.remotePublicKey, remotePayload, clientAddress)\n    } catch (err) {\n      safetyCatch(err)\n    }\n\n    if (this._closing || this.suspended) return null\n\n    if (hs.firewalled) {\n      this._clearLater(hs, id, k)\n      return null\n    }\n\n    const error =\n      remotePayload.version === 1\n        ? remotePayload.udx\n          ? ERROR.NONE\n          : ERROR.ABORTED\n        : ERROR.VERSION_MISMATCH\n\n    const addresses = []\n    const ourRemoteAddr = this.dht.remoteAddress()\n    const ourLocalAddrs = this._shareLocalAddress ? await this._localAddresses() : null\n\n    if (this._closing || this.suspended) return null\n\n    if (ourRemoteAddr) addresses.push(ourRemoteAddr)\n    if (ourLocalAddrs) addresses.push(...ourLocalAddrs)\n\n    if (error === ERROR.NONE) {\n      hs.rawStream = this.dht.createRawStream({\n        framed: true,\n        firewall(socket, port, host) {\n          // Check if the traffic originated from the socket on which we're expecting relay traffic. If so,\n          // we haven't hole punched yet and the other side is just sending us traffic through the relay.\n          if (hs.relaySocket && isRelay(hs.relaySocket, socket, port, host)) {\n            return false\n          }\n\n          hs.onsocket(socket, port, host)\n          return false\n        }\n      })\n\n      hs.rawStream.on('error', autoDestroy)\n\n      // Handles the case where onsocket is never called, but the stream got setup\n      // This can happen on a relayed connection which never connects directly\n      // (onsocket is called there only when the direct connection is established)\n      const onrawstreamclose = () => {\n        if (this._closing) return\n        this._clearLater(hs, id, k)\n      }\n      hs.rawStream.on('close', onrawstreamclose)\n\n      hs.onsocket = (socket, port, host) => {\n        if (hs.rawStream === null) return // Already hole punched\n\n        this._clearLater(hs, id, k)\n\n        if (hs.prepunching) {\n          clearTimeout(hs.prepunching)\n          hs.prepunching = null\n        }\n\n        if (this._reusableSocket && remotePayload.udx.reusableSocket) {\n          this.dht._socketPool.routes.add(handshake.remotePublicKey, hs.rawStream)\n        }\n\n        hs.rawStream.removeListener('error', autoDestroy)\n        hs.rawStream.removeListener('close', onrawstreamclose)\n\n        if (hs.rawStream.connected) {\n          const remoteChanging = hs.rawStream.changeRemote(socket, remotePayload.udx.id, port, host)\n\n          if (remoteChanging) remoteChanging.catch(safetyCatch)\n        } else {\n          hs.rawStream.connect(socket, remotePayload.udx.id, port, host)\n          hs.encryptedSocket = this.createSecretStream(false, hs.rawStream, {\n            handshake: h,\n            keepAlive: this.dht.connectionKeepAlive\n          })\n\n          this.onconnection(hs.encryptedSocket)\n        }\n\n        if (hs.puncher) {\n          hs.puncher.onabort = noop\n          hs.puncher.destroy()\n        }\n\n        hs.rawStream = null\n      }\n\n      function autoDestroy() {\n        if (hs.puncher) hs.puncher.destroy()\n      }\n    }\n\n    const relayAddresses = this.relayAddresses\n    const relayThrough = selectRelay(this.relayThrough)\n\n    if (relayThrough) hs.relayToken = relay.token()\n\n    try {\n      hs.reply = await handshake.send({\n        error,\n        firewall: ourRemoteAddr ? FIREWALL.OPEN : FIREWALL.UNKNOWN,\n        holepunch: ourRemoteAddr ? null : { id, relays: this._announcer.relays },\n        addresses4: addresses,\n        addresses6: null,\n        udx: {\n          reusableSocket: this._reusableSocket,\n          id: hs.rawStream ? hs.rawStream.id : 0,\n          seq: 0\n        },\n        secretStream: {},\n        relayThrough: relayThrough ? { publicKey: relayThrough, token: hs.relayToken } : null,\n        relayAddresses: relayAddresses.length ? relayAddresses : null\n      })\n    } catch (err) {\n      safetyCatch(err)\n      hs.rawStream.destroy()\n      this._clearLater(hs, id, k)\n      return null\n    }\n\n    if (this._closing || this.suspended) {\n      hs.rawStream.destroy()\n      return null\n    }\n\n    const h = handshake.final()\n\n    if (error !== ERROR.NONE) {\n      hs.rawStream.destroy()\n      this._clearLater(hs, id, k)\n      return hs\n    }\n\n    if (remotePayload.firewall === FIREWALL.OPEN || direct) {\n      const sock = direct ? socket : this.dht.socket\n      this.dht.stats.punches.open++\n      hs.onsocket(sock, clientAddress.port, clientAddress.host)\n      return hs\n    }\n\n    if (relayThrough || remotePayload.relayThrough) {\n      this._relayConnection(hs, relayThrough, remotePayload, h)\n    }\n\n    const onabort = () => {\n      hs.aborted = true\n      if (hs.prepunching) clearTimeout(hs.prepunching)\n      hs.prepunching = null\n      if (hs.rawStream.destroyed) {\n        this._clearLater(hs, id, k)\n        return\n      }\n\n      hs.rawStream.on('close', () => this._clearLater(hs, id, k))\n      if (hs.relayToken === null) hs.rawStream.destroy()\n    }\n\n    if (!direct && clientAddress.host === serverAddress.host) {\n      const clientAddresses = remotePayload.addresses4.filter(onlyPrivateHosts)\n\n      if (clientAddresses.length > 0 && this._shareLocalAddress) {\n        const myAddresses = await this._localAddresses()\n        const addr = Holepuncher.matchAddress(myAddresses, clientAddresses)\n\n        if (addr) {\n          hs.prepunching = setTimeout(onabort, HANDSHAKE_INITIAL_TIMEOUT)\n          return hs\n        }\n      }\n    }\n\n    if (this._closing || this.suspended) return null\n\n    if (ourRemoteAddr || this._neverPunch) {\n      hs.prepunching = setTimeout(onabort, HANDSHAKE_INITIAL_TIMEOUT)\n      return hs\n    }\n\n    hs.payload = new SecurePayload(h.holepunchSecret)\n    hs.puncher = new Holepuncher(this.dht, this.dht.session(), false, remotePayload.firewall)\n\n    hs.puncher.onconnect = hs.onsocket\n    hs.puncher.onabort = onabort\n    hs.prepunching = setTimeout(hs.puncher.destroy.bind(hs.puncher), HANDSHAKE_INITIAL_TIMEOUT)\n\n    return hs\n  }\n\n  _clearLater(hs, id, k) {\n    if (hs.clearing) return\n    hs.clearing = setTimeout(() => this._clear(hs, id, k), this.handshakeClearWait)\n  }\n\n  _clear(hs, id, k) {\n    if (id >= this._holepunches.length || this._holepunches[id] !== hs) return\n    if (hs.clearing) clearTimeout(hs.clearing)\n\n    this._holepunches[id] = null\n    while (\n      this._holepunches.length > 0 &&\n      this._holepunches[this._holepunches.length - 1] === null\n    ) {\n      this._holepunches.pop()\n    }\n    this._connects.delete(k)\n  }\n\n  async _onpeerhandshake({ noise, peerAddress }, req) {\n    const k = b4a.toString(noise, 'hex')\n\n    // The next couple of statements MUST run within the same tick to prevent\n    // a malicious peer from flooding us with handshakes.\n    let p = this._connects.get(k)\n    if (!p) {\n      p = this._addHandshake(k, noise, peerAddress || req.from, req, !peerAddress)\n      this._connects.set(k, p)\n    }\n\n    const h = await p\n    if (!h) return null\n\n    if (this._closing !== null || this.suspended) return null\n\n    return { socket: h.puncher && h.puncher.socket, noise: h.reply }\n  }\n\n  async _onpeerholepunch({ id, peerAddress, payload }, req) {\n    const h = id < this._holepunches.length ? this._holepunches[id] : null\n    if (!h) return null\n\n    if (!peerAddress || this._closing !== null || this.suspended) return null\n\n    const p = h.puncher\n    if (!p || !p.socket) return this._abort(h) // not opened\n\n    const remotePayload = h.payload.decrypt(payload)\n    if (!remotePayload) return null\n\n    const isServerRelay = this._announcer.isRelay(req.from)\n    const { error, firewall, round, punching, addresses, remoteAddress, remoteToken } =\n      remotePayload\n\n    if (error !== ERROR.NONE) {\n      // We actually do not need to set the round here, but just do it for consistency.\n      if (round >= h.round) h.round = round\n      return this._abort(h)\n    }\n\n    const token = h.payload.token(peerAddress)\n    const echoed = isServerRelay && !!remoteToken && b4a.equals(token, remoteToken)\n\n    // Update our heuristics here\n    if (req.socket === p.socket) {\n      p.nat.add(req.to, req.from)\n    }\n\n    if (round >= h.round) {\n      h.round = round\n      p.updateRemote({ punching, firewall, addresses, verified: echoed ? peerAddress.host : null })\n    }\n\n    // Wait for the analyzer to reach a conclusion...\n    let stable = await p.analyze(false)\n    if (p.destroyed) return null\n\n    if (!p.remoteHolepunching && !stable) {\n      stable = await p.analyze(true)\n      if (p.destroyed) return null\n      if (!stable) return this._abort(h)\n    }\n\n    // Fast mode! If we are consistent and the remote has opened a session to us (remoteAddress)\n    // then fire a quick punch back. Note the await here just waits for the udp socket to flush.\n    if (\n      isConsistent(p.nat.firewall) &&\n      remoteAddress &&\n      hasSameAddr(p.nat.addresses, remoteAddress)\n    ) {\n      await p.ping(peerAddress)\n      if (p.destroyed) return null\n    }\n\n    // Remote said they are punching (or willing to), so we will punch as well.\n    // Note that this returns when the punching has STARTED, so no guarantee\n    // we will have a connection after this promise etc.\n    if (p.remoteHolepunching) {\n      // TODO: still continue here if a local connection might work, but then do not holepunch...\n      if (!this.holepunch(p.remoteFirewall, p.nat.firewall, p.remoteAddresses, p.nat.addresses)) {\n        return p.destroyed ? null : this._abort(h)\n      }\n\n      if (h.prepunching) {\n        clearTimeout(h.prepunching)\n        h.prepunching = null\n      }\n\n      if (p.remoteFirewall >= FIREWALL.RANDOM || p.nat.firewall >= FIREWALL.RANDOM) {\n        if (\n          this.dht._randomPunches >= this.dht._randomPunchLimit ||\n          Date.now() - this.dht._lastRandomPunch < this.dht._randomPunchInterval\n        ) {\n          if (!h.relayToken) return this._abort(h, ERROR.TRY_LATER)\n          return {\n            socket: p.socket,\n            payload: h.payload.encrypt({\n              error: ERROR.TRY_LATER,\n              firewall: p.nat.firewall,\n              round: h.round,\n              connected: p.connected,\n              punching: p.punching,\n              addresses: p.nat.addresses,\n              remoteAddress: null,\n              token: isServerRelay ? token : null,\n              remoteToken: remotePayload.token\n            })\n          }\n        }\n      }\n\n      const punching = await p.punch()\n      if (p.destroyed) return null\n      if (!punching) return this._abort(h)\n    }\n\n    // Freeze that analysis as soon as we have a result we are giving to the other peer\n    if (p.nat.firewall !== FIREWALL.UNKNOWN) {\n      p.nat.freeze()\n    }\n\n    return {\n      socket: p.socket,\n      payload: h.payload.encrypt({\n        error: ERROR.NONE,\n        firewall: p.nat.firewall,\n        round: h.round,\n        connected: p.connected,\n        punching: p.punching,\n        addresses: p.nat.addresses,\n        remoteAddress: null,\n        token: isServerRelay ? token : null,\n        remoteToken: remotePayload.token\n      })\n    }\n  }\n\n  _abort(h, error = ERROR.ABORTED) {\n    if (!h.payload) {\n      if (h.puncher) h.puncher.destroy()\n      return null\n    }\n\n    const payload = h.payload.encrypt({\n      error,\n      firewall: FIREWALL.UNKNOWN,\n      round: h.round,\n      connected: false,\n      punching: false,\n      addresses: null,\n      remoteAddress: null,\n      token: null,\n      remoteToken: null\n    })\n\n    h.puncher.destroy()\n\n    return { socket: this.dht.socket, payload }\n  }\n\n  _relayConnection(hs, relayThrough, remotePayload, h) {\n    this.dht.stats.relaying.attempts++\n\n    let isInitiator\n    let publicKey\n    let token\n\n    if (relayThrough) {\n      isInitiator = true\n      publicKey = relayThrough\n      token = hs.relayToken\n    } else {\n      isInitiator = false\n      publicKey = remotePayload.relayThrough.publicKey\n      token = remotePayload.relayThrough.token\n    }\n\n    hs.relayToken = token\n    hs.relaySocket = this.dht.connect(publicKey)\n    hs.relaySocket.setKeepAlive(this.relayKeepAlive)\n    hs.relayClient = relay.Client.from(hs.relaySocket, { id: hs.relaySocket.publicKey })\n    hs.relayTimeout = setTimeout(onabort, 15000)\n\n    hs.relayClient\n      .pair(isInitiator, token, hs.rawStream)\n      .on('error', onabort)\n      .on('data', (remoteId) => {\n        if (hs.relayTimeout) clearRelayTimeout(hs)\n        if (hs.rawStream === null) {\n          onabort(null)\n          return\n        }\n\n        hs.relayPaired = true\n        this.dht.stats.relaying.successes++\n\n        if (hs.prepunching) clearTimeout(hs.prepunching)\n        hs.prepunching = null\n\n        const { remotePort, remoteHost, socket } = hs.relaySocket.rawStream\n\n        hs.rawStream\n          .on('close', () => hs.relaySocket.destroy())\n          .connect(socket, remoteId, remotePort, remoteHost)\n\n        hs.encryptedSocket = this.createSecretStream(false, hs.rawStream, { handshake: h })\n\n        this.onconnection(hs.encryptedSocket)\n      })\n\n    const dht = this.dht\n    function onabort() {\n      if (!hs.relayPaired) dht.stats.relaying.aborts++\n      if (hs.relayTimeout) clearRelayTimeout(hs)\n      const socket = hs.relaySocket\n      hs.relayToken = null\n      hs.relaySocket = null\n      if (socket) socket.destroy()\n      if (hs.aborted && hs.rawStream) hs.rawStream.destroy()\n    }\n  }\n}\n\nfunction clearRelayTimeout(hs) {\n  clearTimeout(hs.relayTimeout)\n  hs.relayTimeout = null\n}\n\nfunction isConsistent(fw) {\n  return fw === FIREWALL.OPEN || fw === FIREWALL.CONSISTENT\n}\n\nfunction hasSameAddr(addrs, other) {\n  if (addrs === null) return false\n\n  for (const addr of addrs) {\n    if (addr.port === other.port && addr.host === other.host) return true\n  }\n  return false\n}\n\nfunction defaultCreateHandshake(keyPair, remotePublicKey) {\n  return new NoiseWrap(keyPair, remotePublicKey)\n}\n\nfunction defaultCreateSecretStream(isInitiator, rawStream, opts) {\n  return new NoiseSecretStream(isInitiator, rawStream, opts)\n}\n\nfunction onlyPrivateHosts(addr) {\n  return isPrivate(addr.host)\n}\n\nfunction isRelay(relaySocket, socket, port, host) {\n  const stream = relaySocket.rawStream\n  if (!stream) return false\n  if (stream.socket !== socket) return false\n  return port === stream.remotePort && host === stream.remoteHost\n}\n\nfunction selectRelay(relayThrough) {\n  if (typeof relayThrough === 'function') relayThrough = relayThrough()\n  if (relayThrough === null) return null\n  if (Array.isArray(relayThrough)) {\n    return relayThrough[Math.floor(Math.random() * relayThrough.length)]\n  }\n  return relayThrough\n}\n\nfunction noop() {}\nmodule.exports = class Sleeper {\n  constructor() {\n    this._timeout = null\n    this._resolve = null\n\n    this._start = (resolve) => {\n      this._resolve = resolve\n    }\n\n    this._trigger = () => {\n      if (this._resolve === null) return\n      const resolve = this._resolve\n      this._timeout = null\n      this._resolve = null\n      resolve()\n    }\n  }\n\n  pause(ms) {\n    const p = new Promise(this._start)\n    if (this._timeout !== null) {\n      clearTimeout(this._timeout)\n      this._trigger()\n    }\n    this._timeout = setTimeout(this._trigger, ms)\n    return p\n  }\n\n  resume() {\n    if (this._timeout !== null) {\n      clearTimeout(this._timeout)\n      this._trigger()\n    }\n  }\n}\nconst b4a = require('b4a')\n\nconst LINGER_TIME = 3000\n\nmodule.exports = class SocketPool {\n  constructor(dht, host) {\n    this._dht = dht\n    this._sockets = new Map()\n    this._lingering = new Set() // updated by the ref\n    this._host = host\n\n    this.routes = new SocketRoutes(this)\n  }\n\n  _onmessage(ref, data, address) {\n    this._dht.onmessage(ref.socket, data, address)\n  }\n\n  _add(ref) {\n    this._sockets.set(ref.socket, ref)\n  }\n\n  _remove(ref) {\n    this._sockets.delete(ref.socket)\n    this._lingering.delete(ref)\n  }\n\n  lookup(socket) {\n    return this._sockets.get(socket) || null\n  }\n\n  setReusable(socket, bool) {\n    const ref = this.lookup(socket)\n    if (ref) ref.reusable = bool\n  }\n\n  acquire() {\n    // TODO: Enable socket reuse\n    return new SocketRef(this)\n  }\n\n  async destroy() {\n    const closing = []\n\n    for (const ref of this._sockets.values()) {\n      ref._unlinger()\n      closing.push(ref.socket.close())\n    }\n\n    await Promise.allSettled(closing)\n  }\n}\n\nclass SocketRoutes {\n  constructor(pool) {\n    this._pool = pool\n    this._routes = new Map()\n  }\n\n  add(publicKey, rawStream) {\n    if (rawStream.socket) this._onconnect(publicKey, rawStream)\n    else rawStream.on('connect', this._onconnect.bind(this, publicKey, rawStream))\n  }\n\n  get(publicKey) {\n    const id = b4a.toString(publicKey, 'hex')\n    const route = this._routes.get(id)\n    if (!route) return null\n    return route\n  }\n\n  _onconnect(publicKey, rawStream) {\n    const id = b4a.toString(publicKey, 'hex')\n    const socket = rawStream.socket\n\n    let route = this._routes.get(id)\n\n    if (!route) {\n      const gc = () => {\n        if (this._routes.get(id) === route) this._routes.delete(id)\n        socket.removeListener('close', gc)\n      }\n\n      route = {\n        socket,\n        address: { host: rawStream.remoteHost, port: rawStream.remotePort },\n        gc\n      }\n\n      this._routes.set(id, route)\n      socket.on('close', gc)\n    }\n\n    this._pool.setReusable(socket, true)\n\n    rawStream.on('error', () => {\n      this._pool.setReusable(socket, false)\n      if (!route) route = this._routes.get(id)\n      if (route && route.socket === socket) route.gc()\n    })\n  }\n}\n\n// TODO: we should just make some \"user data\" object on udx to allow to attach this info\nclass SocketRef {\n  constructor(pool) {\n    this._pool = pool\n\n    // Events\n    this.onholepunchmessage = noop\n\n    // Whether it should teardown immediately or wait a bit\n    this.reusable = false\n\n    this.socket = pool._dht.udx.createSocket()\n    this.socket\n      .on('close', this._onclose.bind(this))\n      .on('message', this._onmessage.bind(this))\n      .on('idle', this._onidle.bind(this))\n      .on('busy', this._onbusy.bind(this))\n      .bind(0, this._pool._host)\n\n    this._refs = 1\n    this._released = false\n    this._closed = false\n\n    this._timeout = null\n    this._wasBusy = false\n\n    this._pool._add(this)\n  }\n\n  _onclose() {\n    this._pool._remove(this)\n  }\n\n  _onmessage(data, address) {\n    if (data.byteLength > 1) {\n      this._pool._onmessage(this, data, address)\n    } else {\n      this.onholepunchmessage(data, address, this)\n    }\n  }\n\n  _onidle() {\n    this._closeMaybe()\n  }\n\n  _onbusy() {\n    this._wasBusy = true\n    this._unlinger()\n  }\n\n  _reset() {\n    this.onholepunchmessage = noop\n  }\n\n  _closeMaybe() {\n    if (this._refs === 0 && this.socket.idle && !this._timeout) this._close()\n  }\n\n  _lingeringClose() {\n    this._pool._lingering.delete(this)\n    this._timeout = null\n    this._closeMaybe()\n  }\n\n  _close() {\n    this._unlinger()\n\n    if (this.reusable && this._wasBusy) {\n      this._wasBusy = false\n      this._pool._lingering.add(this)\n      this._timeout = setTimeout(this._lingeringClose.bind(this), LINGER_TIME)\n      return\n    }\n\n    this._closed = true\n    this.socket.close()\n  }\n\n  _unlinger() {\n    if (this._timeout !== null) {\n      clearTimeout(this._timeout)\n      this._pool._lingering.delete(this)\n      this._timeout = null\n    }\n  }\n\n  get free() {\n    return this._refs === 0\n  }\n\n  active() {\n    this._refs++\n    this._unlinger()\n  }\n\n  inactive() {\n    this._refs--\n    this._closeMaybe()\n  }\n\n  address() {\n    return this.socket.address()\n  }\n\n  release() {\n    if (this._released) return\n\n    this._released = true\n    this._reset()\n\n    this._refs--\n    this._closeMaybe()\n  }\n}\n\nfunction noop() {}\n{\n  \"name\": \"hyperdht\",\n  \"version\": \"6.29.0\",\n  \"description\": \"The DHT powering Hyperswarm\",\n  \"main\": \"index.js\",\n  \"browser\": \"browser.js\",\n  \"bin\": {\n    \"hyperdht\": \"./bin.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"browser.js\",\n    \"testnet.js\",\n    \"bin.js\",\n    \"lib/**.js\"\n  ],\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    },\n    \"child_process\": {\n      \"bare\": \"bare-node-child-process\",\n      \"default\": \"child_process\"\n    }\n  },\n  \"dependencies\": {\n    \"@hyperswarm/secret-stream\": \"^6.6.2\",\n    \"b4a\": \"^1.3.1\",\n    \"bare-events\": \"^2.2.0\",\n    \"blind-relay\": \"^1.3.0\",\n    \"bogon\": \"^1.0.0\",\n    \"compact-encoding\": \"^2.4.1\",\n    \"compact-encoding-net\": \"^1.0.1\",\n    \"dht-rpc\": \"^6.15.1\",\n    \"hypercore-crypto\": \"^3.3.0\",\n    \"hypercore-id-encoding\": \"^1.2.0\",\n    \"noise-curve-ed\": \"^2.0.0\",\n    \"noise-handshake\": \"^4.0.0\",\n    \"record-cache\": \"^1.1.1\",\n    \"safety-catch\": \"^1.0.1\",\n    \"signal-promise\": \"^1.0.3\",\n    \"sodium-universal\": \"^5.0.1\",\n    \"streamx\": \"^2.16.1\",\n    \"unslab\": \"^1.3.0\",\n    \"xache\": \"^1.1.0\"\n  },\n  \"devDependencies\": {\n    \"bare-node-child-process\": \"^1.0.1\",\n    \"brittle\": \"^3.0.0\",\n    \"graceful-goodbye\": \"^1.3.0\",\n    \"newline-decoder\": \"^1.0.2\",\n    \"prettier\": \"^3.6.2\",\n    \"prettier-config-holepunch\": \"^2.0.0\"\n  },\n  \"scripts\": {\n    \"format\": \"prettier --write .\",\n    \"test\": \"prettier --check . && node test/all.js\",\n    \"test:bare\": \"bare test/all.js\",\n    \"test:generate\": \"brittle -r test/all.js test/*.js\",\n    \"integration\": \"brittle test/integration/*.js\",\n    \"end-to-end\": \"brittle test/end-to-end/*.js\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"directories\": {\n    \"lib\": \"lib\",\n    \"test\": \"test\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/hyperdht.git\"\n  },\n  \"keywords\": [],\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/hyperdht/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/hyperdht#readme\"\n}\nconst { EventEmitter } = require('events')\nconst { getStreamError } = require('streamx')\nconst DHT = require('hyperdht')\nconst spq = require('shuffled-priority-queue')\nconst b4a = require('b4a')\nconst unslab = require('unslab')\n\nconst PeerInfo = require('./lib/peer-info')\nconst RetryTimer = require('./lib/retry-timer')\nconst ConnectionSet = require('./lib/connection-set')\nconst PeerDiscovery = require('./lib/peer-discovery')\n\nconst MAX_PEERS = 64\nconst MAX_PARALLEL = 3\nconst MAX_CLIENT_CONNECTIONS = Infinity // TODO: Change\nconst MAX_SERVER_CONNECTIONS = Infinity\n\nconst ERR_MISSING_TOPIC = 'Topic is required and must be a 32-byte buffer'\nconst ERR_DESTROYED = 'Swarm has been destroyed'\nconst ERR_DUPLICATE = 'Duplicate connection'\nconst ERR_FIREWALL = 'Peer is firewalled'\n\nmodule.exports = class Hyperswarm extends EventEmitter {\n  constructor(opts = {}) {\n    super()\n    const {\n      seed,\n      relayThrough,\n      keyPair = DHT.keyPair(seed),\n      maxPeers = MAX_PEERS,\n      maxClientConnections = MAX_CLIENT_CONNECTIONS,\n      maxServerConnections = MAX_SERVER_CONNECTIONS,\n      maxParallel = MAX_PARALLEL,\n      firewall = allowAll\n    } = opts\n    this.keyPair = keyPair\n\n    this.dht =\n      opts.dht ||\n      new DHT({\n        bootstrap: opts.bootstrap,\n        nodes: opts.nodes,\n        port: opts.port,\n        deferRandomPunch: opts.deferRandomPunch,\n        randomPunchInterval: opts.randomPunchInterval\n      })\n    this.server = this.dht.createServer(\n      {\n        firewall: this._handleFirewall.bind(this),\n        relayThrough: this._maybeRelayConnection.bind(this),\n        handshakeClearWait: opts.handshakeClearWait\n      },\n      this._handleServerConnection.bind(this)\n    )\n\n    this.destroyed = false\n    this.suspended = false\n    this.maxPeers = maxPeers\n    this.maxClientConnections = maxClientConnections\n    this.maxServerConnections = maxServerConnections\n    this.maxParallel = maxParallel\n    this.relayThrough = relayThrough ? toRelayFunction(relayThrough) : null\n\n    this.connecting = 0\n    this.connections = new Set()\n    this.peers = new Map()\n    this.explicitPeers = new Set()\n    this.listening = null\n    this.stats = {\n      updates: 0,\n      connects: {\n        client: {\n          opened: 0,\n          closed: 0,\n          attempted: 0\n        },\n        server: {\n          // Note: there is no notion of 'attempts' for server connections\n          opened: 0,\n          closed: 0\n        }\n      },\n      bannedPeers: 0\n    }\n\n    this._discovery = new Map()\n    this._timer = new RetryTimer(this._requeue.bind(this), {\n      backoffs: opts.backoffs,\n      jitter: opts.jitter\n    })\n    this._queue = spq()\n\n    this._allConnections = new ConnectionSet()\n    this._pendingFlushes = []\n    this._flushTick = 0\n\n    this._drainingQueue = false\n    this._clientConnections = 0\n    this._serverConnections = 0\n    this._firewall = firewall\n\n    this.dht.on('network-change', this._handleNetworkChange.bind(this))\n    this.dht.on('network-update', this._handleNetworkUpdate.bind(this))\n    this.on('update', this._handleUpdate)\n  }\n\n  _maybeRelayConnection(force) {\n    if (!this.relayThrough) return null\n    return this.relayThrough(force, this)\n  }\n\n  _enqueue(peerInfo) {\n    if (peerInfo.queued) return\n    peerInfo.queued = true\n    peerInfo._flushTick = this._flushTick\n    this._queue.add(peerInfo)\n\n    this._attemptClientConnections()\n  }\n\n  _requeue(batch) {\n    if (this.suspended) return\n    for (const peerInfo of batch) {\n      peerInfo.waiting = false\n\n      if (\n        peerInfo._updatePriority() === false ||\n        this._allConnections.has(peerInfo.publicKey) ||\n        peerInfo.queued\n      )\n        continue\n      peerInfo.queued = true\n      peerInfo._flushTick = this._flushTick\n      this._queue.add(peerInfo)\n    }\n\n    this._attemptClientConnections()\n  }\n\n  _flushMaybe(peerInfo) {\n    for (let i = 0; i < this._pendingFlushes.length; i++) {\n      const flush = this._pendingFlushes[i]\n      if (peerInfo._flushTick > flush.tick) continue\n      if (--flush.missing > 0) continue\n      flush.onflush(true)\n      this._pendingFlushes.splice(i--, 1)\n    }\n  }\n\n  _flushAllMaybe() {\n    if (\n      this.connecting > 0 ||\n      (this._allConnections.size < this.maxPeers &&\n        this._clientConnections < this.maxClientConnections)\n    ) {\n      return false\n    }\n\n    while (this._pendingFlushes.length) {\n      const flush = this._pendingFlushes.pop()\n      flush.onflush(true)\n    }\n\n    return true\n  }\n\n  _shouldConnectExplicit() {\n    return !this.destroyed && !this.suspended && this.connecting < this.maxParallel\n  }\n\n  _shouldConnect() {\n    return (\n      !this.destroyed &&\n      !this.suspended &&\n      this.connecting < this.maxParallel &&\n      this._allConnections.size < this.maxPeers &&\n      this._clientConnections < this.maxClientConnections\n    )\n  }\n\n  _shouldRequeue(peerInfo) {\n    if (this.suspended) return false\n    if (peerInfo.explicit) return true\n    for (const topic of peerInfo.topics) {\n      if (this._discovery.has(b4a.toString(topic, 'hex')) && !this.destroyed) {\n        return true\n      }\n    }\n    return false\n  }\n\n  _connect(peerInfo, queued) {\n    if (peerInfo.banned || this._allConnections.has(peerInfo.publicKey)) {\n      if (queued) this._flushMaybe(peerInfo)\n      return\n    }\n\n    // TODO: Support async firewalling at some point.\n    if (this._handleFirewall(peerInfo.publicKey, null)) {\n      if (queued) this._flushMaybe(peerInfo)\n      return\n    }\n\n    const relayThrough = this._maybeRelayConnection(peerInfo.forceRelaying)\n    const conn = this.dht.connect(peerInfo.publicKey, {\n      relayAddresses: peerInfo.relayAddresses,\n      keyPair: this.keyPair,\n      relayThrough\n    })\n    this._allConnections.add(conn)\n\n    this.stats.connects.client.attempted++\n\n    this.connecting++\n    this._clientConnections++\n    let opened = false\n\n    const onerror = (err) => {\n      if (this.relayThrough && shouldForceRelaying(err.code)) {\n        peerInfo.forceRelaying = true\n        // Reset the attempts in order to fast connect to relay\n        peerInfo.attempts = 0\n      }\n    }\n\n    // Removed once a connection is opened\n    conn.on('error', onerror)\n\n    conn.on('open', () => {\n      opened = true\n      this.stats.connects.client.opened++\n\n      this._connectDone()\n      this.connections.add(conn)\n      conn.removeListener('error', onerror)\n      peerInfo._connected()\n      peerInfo.client = true\n      this.emit('connection', conn, peerInfo)\n      if (queued) this._flushMaybe(peerInfo)\n\n      this.emit('update')\n    })\n    conn.on('close', () => {\n      if (!opened) this._connectDone()\n      this.stats.connects.client.closed++\n\n      const err = getStreamError(conn)\n      if (shouldBan(err)) {\n        this._banPeer(peerInfo, true, err)\n      }\n\n      this.connections.delete(conn)\n      this._allConnections.delete(conn)\n      this._clientConnections--\n      peerInfo._disconnected()\n\n      peerInfo.waiting = this._shouldRequeue(peerInfo) && this._timer.add(peerInfo)\n      this._maybeDeletePeer(peerInfo)\n\n      if (!opened && queued) this._flushMaybe(peerInfo)\n\n      this._attemptClientConnections()\n\n      this.emit('update')\n    })\n\n    this.emit('update')\n  }\n\n  _connectDone() {\n    this.connecting--\n\n    if (this.connecting < this.maxParallel) this._attemptClientConnections()\n    if (this.connecting === 0) this._flushAllMaybe()\n  }\n\n  // Called when the PeerQueue indicates a connection should be attempted.\n  _attemptClientConnections() {\n    // Guard against re-entries - unsure if it still needed but doesn't hurt\n    if (this._drainingQueue || this.suspended) return\n    this._drainingQueue = true\n\n    for (const peerInfo of this.explicitPeers) {\n      if (!this._shouldConnectExplicit()) break\n      if (\n        peerInfo.attempts >= 5 ||\n        Date.now() - peerInfo.disconnectedTime < peerInfo.attempts * 1000\n      )\n        continue\n      this._connect(peerInfo, false)\n    }\n\n    while (this._queue.length && this._shouldConnect()) {\n      const peerInfo = this._queue.shift()\n      peerInfo.queued = false\n      this._connect(peerInfo, true)\n    }\n    this._drainingQueue = false\n    if (this.connecting === 0) this._flushAllMaybe()\n  }\n\n  _handleFirewall(remotePublicKey, payload) {\n    if (b4a.equals(remotePublicKey, this.keyPair.publicKey)) return true\n\n    let peerInfo = this.peers.get(b4a.toString(remotePublicKey, 'hex'))\n    if (peerInfo && peerInfo.banned) return true\n\n    const firewalled = this._firewall(remotePublicKey, payload)\n    if (firewalled) {\n      if (!peerInfo) peerInfo = this._upsertPeer(remotePublicKey)\n      this._banPeer(peerInfo, true, new Error(ERR_FIREWALL))\n    }\n\n    return firewalled\n  }\n\n  _handleServerConnectionSwap(existing, conn) {\n    let closed = false\n\n    existing.on('close', () => {\n      if (closed) return\n\n      conn.removeListener('error', noop)\n      conn.removeListener('close', onclose)\n\n      this._handleServerConnection(conn)\n    })\n\n    conn.on('error', noop)\n    conn.on('close', onclose)\n\n    function onclose() {\n      closed = true\n    }\n  }\n\n  // Called when the DHT receives a new server connection.\n  _handleServerConnection(conn) {\n    if (this.destroyed || this.suspended) {\n      // TODO: Investigate why a final server connection can be received after close\n      conn.on('error', noop)\n      return conn.destroy(ERR_DESTROYED)\n    }\n\n    const existing = this._allConnections.get(conn.remotePublicKey)\n\n    if (existing) {\n      // If both connections are from the same peer,\n      // - pick the new one if the existing stream is already established (has sent and received bytes),\n      //   because the other client must have lost that connection and be reconnecting\n      // - otherwise, pick the one thats expected to initiate in a tie break\n      const existingIsOutdated = existing.rawBytesRead > 0 && existing.rawBytesWritten > 0\n      const expectedInitiator = b4a.compare(conn.publicKey, conn.remotePublicKey) > 0\n      const keepNew = existingIsOutdated || expectedInitiator === conn.isInitiator\n\n      if (keepNew === false) {\n        existing.sendKeepAlive()\n        conn.on('error', noop)\n        conn.destroy(new Error(ERR_DUPLICATE))\n        return\n      }\n\n      existing.on('error', noop)\n      existing.destroy(new Error(ERR_DUPLICATE))\n      this._handleServerConnectionSwap(existing, conn)\n      return\n    }\n\n    // When reaching here, the connection will always be 'opened' next tick\n    this.stats.connects.server.opened++\n\n    const peerInfo = this._upsertPeer(conn.remotePublicKey, null)\n\n    this.connections.add(conn)\n    this._allConnections.add(conn)\n    this._serverConnections++\n\n    conn.on('close', () => {\n      const err = getStreamError(conn)\n      if (shouldBan(err)) {\n        this._banPeer(peerInfo, true, err)\n      }\n\n      this.connections.delete(conn)\n      this._allConnections.delete(conn)\n      this._serverConnections--\n      this.stats.connects.server.closed++\n\n      this._maybeDeletePeer(peerInfo)\n\n      this._attemptClientConnections()\n\n      this.emit('update')\n    })\n    peerInfo.client = false\n    this.emit('connection', conn, peerInfo)\n\n    this.emit('update')\n  }\n\n  _upsertPeer(publicKey, relayAddresses) {\n    if (b4a.equals(publicKey, this.keyPair.publicKey)) return null\n    const keyString = b4a.toString(publicKey, 'hex')\n    let peerInfo = this.peers.get(keyString)\n\n    if (peerInfo) {\n      peerInfo.relayAddresses = relayAddresses // new is always better\n      return peerInfo\n    }\n\n    peerInfo = new PeerInfo({\n      publicKey,\n      relayAddresses\n    })\n\n    this.peers.set(keyString, peerInfo)\n    return peerInfo\n  }\n\n  _handleUpdate() {\n    this.stats.updates++\n  }\n\n  _maybeDeletePeer(peerInfo) {\n    if (!peerInfo.shouldGC()) return\n\n    const hasActiveConn = this._allConnections.has(peerInfo.publicKey)\n    if (hasActiveConn) return\n\n    const keyString = b4a.toString(peerInfo.publicKey, 'hex')\n    this.peers.delete(keyString)\n  }\n\n  /*\n   * Called when a peer is actively discovered during a lookup.\n   *\n   * Three conditions:\n   *  1. Not a known peer -- insert into queue\n   *  2. A known peer with normal priority -- do nothing\n   *  3. A known peer with low priority -- bump priority, because it's been rediscovered\n   */\n  _handlePeer(peer, topic) {\n    const peerInfo = this._upsertPeer(peer.publicKey, peer.relayAddresses)\n    if (peerInfo) peerInfo._topic(topic)\n    if (!peerInfo || this._allConnections.has(peer.publicKey)) return\n    if (!peerInfo.prioritized || peerInfo.server) peerInfo._reset()\n    if (peerInfo._updatePriority()) {\n      this._enqueue(peerInfo)\n    }\n  }\n\n  async _handleNetworkUpdate() {\n    if (!this.online) return\n    this._handleNetworkChange()\n  }\n\n  async _handleNetworkChange() {\n    if (this.suspended) return\n\n    // prioritize figuring out if existing connections are dead\n    for (const conn of this._allConnections) {\n      conn.sendKeepAlive()\n    }\n\n    const refreshes = []\n\n    for (const discovery of this._discovery.values()) {\n      refreshes.push(discovery.refresh())\n    }\n\n    await Promise.allSettled(refreshes)\n  }\n\n  _banPeer(peerInfo, banned, err) {\n    peerInfo.ban(banned)\n    this.stats.bannedPeers++\n    this.emit('ban', peerInfo, err)\n  }\n\n  status(key) {\n    return this._discovery.get(b4a.toString(key, 'hex')) || null\n  }\n\n  listen() {\n    if (!this.listening) {\n      if (this.destroyed) throw new Error('Swarm destroyed')\n      this.listening = this.server.listen(this.keyPair)\n    }\n    return this.listening\n  }\n\n  // Object that exposes a cancellation method (destroy)\n  // TODO: When you rejoin, it should reannounce + bump lookup priority\n  join(topic, opts = {}) {\n    if (this.destroyed) throw new Error('Swarm destroyed')\n    if (!topic) throw new Error(ERR_MISSING_TOPIC)\n    topic = unslab(topic)\n\n    const topicString = b4a.toString(topic, 'hex')\n\n    let discovery = this._discovery.get(topicString)\n\n    if (discovery && !discovery.destroyed) {\n      return discovery.session(opts)\n    }\n\n    discovery = new PeerDiscovery(this, topic, {\n      limit: opts.limit,\n      wait: discovery ? discovery.destroy() : null,\n      suspended: this.suspended,\n      onpeer: (peer) => this._handlePeer(peer, topic)\n    })\n    this._discovery.set(topicString, discovery)\n    return discovery.session(opts)\n  }\n\n  // Returns a promise\n  async leave(topic) {\n    if (!topic) throw new Error(ERR_MISSING_TOPIC)\n    const topicString = b4a.toString(topic, 'hex')\n    if (!this._discovery.has(topicString)) return Promise.resolve()\n\n    const discovery = this._discovery.get(topicString)\n\n    try {\n      await discovery.destroy()\n    } catch {\n      // ignore, prop network\n    }\n\n    if (this._discovery.get(topicString) === discovery) {\n      this._discovery.delete(topicString)\n    }\n  }\n\n  joinPeer(publicKey) {\n    const peerInfo = this._upsertPeer(publicKey, null)\n    if (!peerInfo) return\n    if (!this.explicitPeers.has(peerInfo)) {\n      peerInfo.explicit = true\n      this.explicitPeers.add(peerInfo)\n    }\n    if (this._allConnections.has(publicKey)) return\n    if (peerInfo._updatePriority()) {\n      this._enqueue(peerInfo)\n    }\n  }\n\n  leavePeer(publicKey) {\n    const keyString = b4a.toString(publicKey, 'hex')\n    if (!this.peers.has(keyString)) return\n\n    const peerInfo = this.peers.get(keyString)\n    peerInfo.explicit = false\n    this.explicitPeers.delete(peerInfo)\n    this._maybeDeletePeer(peerInfo)\n  }\n\n  // Returns a promise\n  async flush() {\n    const allFlushed = [...this._discovery.values()].map((v) => v.flushed())\n    await Promise.all(allFlushed)\n    if (this._flushAllMaybe()) return true\n    const pendingSize = this._allConnections.size - this.connections.size\n    if (!this._queue.length && !pendingSize) return true\n    return new Promise((resolve) => {\n      this._pendingFlushes.push({\n        onflush: resolve,\n        missing: this._queue.length + pendingSize,\n        tick: this._flushTick++\n      })\n    })\n  }\n\n  async clear() {\n    const cleared = Promise.allSettled([...this._discovery.values()].map((d) => d.destroy()))\n    this._discovery.clear()\n    return cleared\n  }\n\n  async destroy({ force } = {}) {\n    if (this.destroyed && !force) return\n    this.destroyed = true\n\n    this._timer.destroy()\n\n    if (!force) await this.clear()\n\n    await this.server.close()\n\n    while (this._pendingFlushes.length) {\n      const flush = this._pendingFlushes.pop()\n      flush.onflush(false)\n    }\n\n    await this.dht.destroy({ force })\n  }\n\n  async suspend({ log = noop } = {}) {\n    if (this.suspended) return\n\n    const promises = []\n\n    promises.push(this.server.suspend({ log }))\n\n    for (const discovery of this._discovery.values()) {\n      promises.push(discovery.suspend({ log }))\n    }\n\n    const pending = []\n    for (const connection of this._allConnections) {\n      connection.destroy()\n      pending.push(new Promise((resolve) => connection.on('close', resolve)))\n    }\n\n    this.suspended = true\n\n    log('Suspending server and discovery... (' + promises.length + ')')\n    await Promise.allSettled(promises)\n    log('Done, suspending the dht...')\n    await this.dht.suspend({ log })\n    log('Done, swarm fully suspended')\n\n    await Promise.all(pending)\n\n    // reset queue\n    this._timer.destroy()\n    this._timer = new RetryTimer(this._requeue.bind(this), {\n      backoffs: this._timer.backoffs,\n      jitter: this._timer.jitter\n    })\n    this._queue = spq()\n  }\n\n  async resume({ log = noop } = {}) {\n    if (!this.suspended) return\n\n    log('Resuming the dht')\n    await this.dht.resume()\n    log('Done, resuming the server')\n    await this.server.resume()\n    log('Done, all discovery')\n\n    for (const discovery of this._discovery.values()) {\n      discovery.resume()\n    }\n\n    this.suspended = false\n    this._attemptClientConnections()\n  }\n\n  topics() {\n    return this._discovery.values()\n  }\n}\n\nfunction noop() {}\n\nfunction allowAll() {\n  return false\n}\n\nfunction shouldForceRelaying(code) {\n  return (\n    code === 'HOLEPUNCH_ABORTED' ||\n    code === 'HOLEPUNCH_DOUBLE_RANDOMIZED_NATS' ||\n    code === 'REMOTE_NOT_HOLEPUNCHABLE'\n  )\n}\n\nfunction shouldBan() {\n  // return !!err && err.name === 'HypercoreError' && err.code === 'INVALID_OPERATION'\n  return false\n}\n\nfunction toRelayFunction(relayThrough) {\n  return typeof relayThrough === 'function'\n    ? relayThrough\n    : (force, swarm) => (force || swarm.dht.randomized ? relayThrough : null)\n}\nmodule.exports = class BulkTimer {\n  constructor(time, fn) {\n    this._time = time\n    this._fn = fn\n    this._interval = null\n    this._next = []\n    this._pending = []\n    this._destroyed = false\n  }\n\n  destroy() {\n    if (this._destroyed) return\n    this._destroyed = true\n    clearInterval(this._interval)\n    this._interval = null\n  }\n\n  _ontick() {\n    if (!this._next.length && !this._pending.length) return\n    if (this._next.length) this._fn(this._next)\n    this._next = this._pending\n    this._pending = []\n  }\n\n  add(info) {\n    if (this._destroyed) return\n    if (!this._interval) {\n      this._interval = setInterval(this._ontick.bind(this), Math.floor(this._time * 0.66))\n    }\n\n    this._pending.push(info)\n  }\n}\nconst b4a = require('b4a')\n\nmodule.exports = class ConnectionSet {\n  constructor() {\n    this._byPublicKey = new Map()\n  }\n\n  [Symbol.iterator]() {\n    return this._byPublicKey.values()\n  }\n\n  get size() {\n    return this._byPublicKey.size\n  }\n\n  has(publicKey) {\n    return this._byPublicKey.has(toHex(publicKey))\n  }\n\n  get(publicKey) {\n    return this._byPublicKey.get(toHex(publicKey))\n  }\n\n  add(connection) {\n    this._byPublicKey.set(b4a.toString(connection.remotePublicKey, 'hex'), connection)\n  }\n\n  delete(connection) {\n    const keyString = b4a.toString(connection.remotePublicKey, 'hex')\n    const existing = this._byPublicKey.get(keyString)\n    if (existing !== connection) return\n    this._byPublicKey.delete(keyString)\n  }\n}\n\nfunction toHex(b) {\n  return typeof b === 'string' ? b : b4a.toString(b, 'hex')\n}\nconst safetyCatch = require('safety-catch')\nconst b4a = require('b4a')\n\nconst REFRESH_INTERVAL = 1000 * 60 * 10 // 10 min\nconst RANDOM_JITTER = 1000 * 60 * 2 // 2 min\nconst DELAY_GRACE_PERIOD = 1000 * 30 // 30s\n\nconst MAX_DISCOVERY_CACHE = 64\n\nmodule.exports = class PeerDiscovery {\n  constructor(\n    swarm,\n    topic,\n    { limit = Infinity, wait = null, suspended = false, onpeer = noop, onerror = safetyCatch }\n  ) {\n    this.limit = limit\n    this.swarm = swarm\n    this.topic = topic\n    this.isClient = false\n    this.isServer = false\n    this.destroyed = false\n    this.destroying = null\n    this.suspended = suspended\n\n    this._sessions = []\n    this._clientSessions = 0\n    this._serverSessions = 0\n\n    this._onpeer = onpeer\n    this._onerror = onerror\n\n    this._discovered = new Set()\n    this._activeQuery = null\n    this._timer = null\n    this._currentRefresh = null\n    this._closestNodes = null\n    this._firstAnnounce = true\n    this._needsUnannounce = false\n    this._refreshes = 0\n    this._wait = wait\n  }\n\n  session({ server = true, client = true, limit = Infinity, onerror = safetyCatch }) {\n    if (this.destroyed) throw new Error('PeerDiscovery is destroyed')\n    const session = new PeerDiscoverySession(this)\n    session.refresh({ server, client, limit }).catch(onerror)\n    this._sessions.push(session)\n    return session\n  }\n\n  _refreshLater(eager) {\n    const jitter = Math.round(Math.random() * RANDOM_JITTER)\n    const delay = !eager ? REFRESH_INTERVAL + jitter : jitter\n\n    if (this._timer) clearTimeout(this._timer)\n\n    const startTime = Date.now()\n    this._timer = setTimeout(() => {\n      // If your laptop went to sleep, and is coming back online...\n      const overdue = Date.now() - startTime > delay + DELAY_GRACE_PERIOD\n      if (overdue) this._refreshLater(true)\n      else this.refresh().catch(this._onerror)\n    }, delay)\n  }\n\n  _isActive() {\n    return !this.destroyed && !this.suspended\n  }\n\n  // TODO: Allow announce to be an argument to this\n  // TODO: Maybe announce should be a setter?\n  async _refresh() {\n    if (this.suspended) return\n    const clock = ++this._refreshes\n\n    if (this._wait) {\n      await this._wait\n      this._wait = null\n      if (clock !== this._refreshes || !this._isActive()) return\n    }\n\n    const clear = this.isServer && this._firstAnnounce\n    if (clear) this._firstAnnounce = false\n\n    const opts = {\n      clear,\n      closestNodes: this._closestNodes\n    }\n\n    if (this.isServer) {\n      await this.swarm.listen()\n      // if a parallel refresh is happening, yield to the new one\n      if (clock !== this._refreshes || !this._isActive()) return\n      this._needsUnannounce = true\n    }\n\n    let limit = this.limit\n\n    if (limit < Infinity && limit > 0) {\n      for (const id of this._discovered) {\n        if (!this.swarm.connections.has(id)) continue\n        if (--limit === 0) break\n      }\n    }\n\n    this._discovered.clear()\n\n    const announcing = this.isServer\n    const query = (this._activeQuery = announcing\n      ? this.swarm.dht.announce(\n          this.topic,\n          this.swarm.keyPair,\n          this.swarm.server.relayAddresses,\n          opts\n        )\n      : this._needsUnannounce\n        ? this.swarm.dht.lookupAndUnannounce(this.topic, this.swarm.keyPair, opts)\n        : this.swarm.dht.lookup(this.topic, opts))\n\n    try {\n      for await (const data of this._activeQuery) {\n        if (!this.isClient || !this._isActive()) continue\n        for (const peer of data.peers) {\n          if (limit < Infinity) {\n            const id = b4a.toString(peer.publicKey, 'hex')\n\n            if (this._discovered.size < MAX_DISCOVERY_CACHE) {\n              this._discovered.add(id)\n            }\n\n            if (limit === 0) continue\n\n            // there is a chance it has updated a connection during discovery and we go over\n            // the limit - thats acceptable to avoid a complexity spiral here.\n            if (!this.swarm.connections.has(id)) limit--\n          }\n\n          this._onpeer(peer, data)\n        }\n      }\n    } catch (err) {\n      if (this._isActive()) throw err\n    } finally {\n      if (this._activeQuery === query) {\n        this._activeQuery = null\n        if (!this.destroyed && !this.suspended) this._refreshLater(false)\n      }\n    }\n\n    // This is set at the very end, when the query completes successfully.\n    this._closestNodes = query.closestNodes\n\n    if (clock !== this._refreshes) return\n\n    // In this is the latest query, unannounce has been fulfilled as well\n    if (!announcing) this._needsUnannounce = false\n  }\n\n  async refresh() {\n    if (this.destroyed) throw new Error('PeerDiscovery is destroyed')\n\n    const server = this._serverSessions > 0\n    const client = this._clientSessions > 0\n\n    if (this.suspended) return\n\n    if (server === this.isServer && client === this.isClient) {\n      if (this._currentRefresh) return this._currentRefresh\n      this._currentRefresh = this._refresh()\n    } else {\n      if (this._activeQuery) this._activeQuery.destroy()\n      this.isServer = server\n      this.isClient = client\n      this._currentRefresh = this._refresh()\n    }\n\n    const refresh = this._currentRefresh\n    try {\n      await refresh\n    } catch {\n      return false\n    } finally {\n      if (refresh === this._currentRefresh) {\n        this._currentRefresh = null\n      }\n    }\n\n    return true\n  }\n\n  async flushed() {\n    if (this.swarm.listening) await this.swarm.listening\n\n    try {\n      await this._currentRefresh\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  async _destroyMaybe() {\n    if (this.destroyed) return\n\n    try {\n      if (this._sessions.length === 0) await this.swarm.leave(this.topic)\n      else if (this._serverSessions === 0 && this._needsUnannounce) await this.refresh()\n    } catch (err) {\n      // ignore network failures here, as we are tearing down\n      safetyCatch(err)\n    }\n  }\n\n  destroy() {\n    if (this.destroying) return this.destroying\n    this.destroying = this._destroy()\n    return this.destroying\n  }\n\n  async _abort(log) {\n    const id = log === noop ? '' : b4a.toString(this.topic, 'hex')\n\n    log('Aborting discovery', id)\n    if (this._wait) await this._wait\n    log('Aborting discovery (post wait)', id)\n\n    if (this._activeQuery) {\n      this._activeQuery.destroy()\n      this._activeQuery = null\n    }\n    if (this._timer) {\n      clearTimeout(this._timer)\n      this._timer = null\n    }\n\n    let nodes = this._closestNodes\n\n    if (this._currentRefresh) {\n      try {\n        await this._currentRefresh\n      } catch {\n        // If the destroy causes the refresh to fail, suppress it.\n      }\n    }\n\n    log('Aborting discovery (post refresh)', id)\n    if (this._isActive()) return\n\n    if (!nodes) nodes = this._closestNodes\n    else if (this._closestNodes !== nodes) {\n      const len = nodes.length\n      for (const newer of this._closestNodes) {\n        if (newer.id && !hasNode(nodes, len, newer)) nodes.push(newer)\n      }\n    }\n\n    if (this._needsUnannounce) {\n      log('Unannouncing discovery', id)\n      if (nodes && nodes.length)\n        await this.swarm.dht.unannounce(this.topic, this.swarm.keyPair, {\n          closestNodes: nodes,\n          onlyClosestNodes: true,\n          force: true\n        })\n      this._needsUnannounce = false\n      log('Unannouncing discovery (done)', id)\n    }\n  }\n\n  _destroy() {\n    if (this.destroyed) return\n    this.destroyed = true\n    return this._abort(noop)\n  }\n\n  async suspend({ log = noop } = {}) {\n    if (this.suspended) return\n    this.suspended = true\n    try {\n      await this._abort(log)\n    } catch {\n      // ignore\n    }\n  }\n\n  resume() {\n    if (!this.suspended) return\n    this.suspended = false\n    this.refresh().catch(noop)\n  }\n}\n\nclass PeerDiscoverySession {\n  constructor(discovery) {\n    this.discovery = discovery\n    this.isClient = false\n    this.isServer = false\n    this.destroyed = false\n  }\n\n  get swarm() {\n    return this.discovery.swarm\n  }\n\n  get topic() {\n    return this.discovery.topic\n  }\n\n  async refresh({ client = this.isClient, server = this.isServer, limit = Infinity } = {}) {\n    if (this.destroyed) throw new Error('PeerDiscovery is destroyed')\n    if (!client && !server) throw new Error('Cannot refresh with neither client nor server option')\n\n    if (client !== this.isClient) {\n      this.isClient = client\n      this.discovery._clientSessions += client ? 1 : -1\n    }\n\n    if (server !== this.isServer) {\n      this.isServer = server\n      this.discovery._serverSessions += server ? 1 : -1\n    }\n\n    this.discovery.limit = limit\n\n    return this.discovery.refresh()\n  }\n\n  async flushed() {\n    return this.discovery.flushed()\n  }\n\n  async destroy() {\n    if (this.destroyed) return\n    this.destroyed = true\n\n    if (this.isClient) this.discovery._clientSessions--\n    if (this.isServer) this.discovery._serverSessions--\n\n    const index = this.discovery._sessions.indexOf(this)\n    const head = this.discovery._sessions.pop()\n\n    if (head !== this) this.discovery._sessions[index] = head\n\n    return this.discovery._destroyMaybe()\n  }\n}\n\nfunction hasNode(nodes, len, node) {\n  for (let i = 0; i < len; i++) {\n    const existing = nodes[i]\n    if (existing.id && b4a.equals(existing.id, node.id)) return true\n  }\n\n  return false\n}\n\nfunction noop() {}\nconst { EventEmitter } = require('events')\nconst b4a = require('b4a')\nconst unslab = require('unslab')\n\nconst MIN_CONNECTION_TIME = 15000\n\nconst VERY_LOW_PRIORITY = 0\nconst LOW_PRIORITY = 1\nconst NORMAL_PRIORITY = 2\nconst HIGH_PRIORITY = 3\nconst VERY_HIGH_PRIORITY = 4\n\nmodule.exports = class PeerInfo extends EventEmitter {\n  constructor({ publicKey, relayAddresses }) {\n    super()\n\n    this.publicKey = unslab(publicKey)\n    this.relayAddresses = relayAddresses\n\n    this.reconnecting = true\n    this.proven = false\n    this.connectedTime = -1\n    this.disconnectedTime = 0\n    this.banned = false\n    this.tried = false\n    this.explicit = false\n    this.waiting = false\n    this.forceRelaying = false\n\n    // Set by the Swarm\n    this.queued = false\n    this.client = false\n    this.topics = [] // TODO: remove on next major (check with mafintosh for context)\n\n    this.attempts = 0\n    this.priority = NORMAL_PRIORITY\n\n    // Used by shuffled-priority-queue\n    this._index = 0\n\n    // Used for flush management\n    this._flushTick = 0\n\n    // Used for topic multiplexing\n    this._seenTopics = new Set()\n  }\n\n  get server() {\n    return !this.client\n  }\n\n  get prioritized() {\n    return this.priority >= NORMAL_PRIORITY\n  }\n\n  _getPriority() {\n    const peerIsStale = this.tried && !this.proven\n    if (peerIsStale || this.attempts > 3) return VERY_LOW_PRIORITY\n    if (this.attempts === 3) return LOW_PRIORITY\n    if (this.attempts === 2) return HIGH_PRIORITY\n    if (this.attempts === 1) return VERY_HIGH_PRIORITY\n    return NORMAL_PRIORITY\n  }\n\n  _connected() {\n    this.proven = true\n    this.connectedTime = Date.now()\n  }\n\n  _disconnected() {\n    this.disconnectedTime = Date.now()\n    if (this.connectedTime > -1) {\n      if (this.disconnectedTime - this.connectedTime >= MIN_CONNECTION_TIME) this.attempts = 0 // fast retry\n      this.connectedTime = -1\n    }\n    this.attempts++\n  }\n\n  _deprioritize() {\n    this.attempts = 3\n  }\n\n  _reset() {\n    this.client = false\n    this.proven = false\n    this.tried = false\n    this.attempts = 0\n  }\n\n  _updatePriority() {\n    if (this.explicit && this.attempts > 3) this._deprioritize()\n    if (this.banned || this.queued || this.attempts > 3) return false\n    this.priority = this._getPriority()\n    return true\n  }\n\n  _topic(topic) {\n    const topicString = b4a.toString(topic, 'hex')\n    if (this._seenTopics.has(topicString)) return\n    this._seenTopics.add(topicString)\n    this.topics.push(topic)\n    this.emit('topic', topic)\n  }\n\n  reconnect(val) {\n    this.reconnecting = !!val\n  }\n\n  ban(val) {\n    this.banned = !!val\n  }\n\n  shouldGC() {\n    return !(this.banned || this.queued || this.explicit || this.waiting)\n  }\n}\nconst BulkTimer = require('./bulk-timer')\n\nconst BACKOFF_JITTER = 500\nconst BACKOFF_S = 1000 + Math.round(BACKOFF_JITTER * Math.random())\nconst BACKOFF_M = 5000 + Math.round(2 * BACKOFF_JITTER * Math.random())\nconst BACKOFF_L = 15000 + Math.round(4 * BACKOFF_JITTER * Math.random())\nconst BACKOFF_X = 1000 * 60 * 10 + Math.round(240 * BACKOFF_JITTER * Math.random())\n\nmodule.exports = class RetryTimer {\n  constructor(\n    push,\n    { backoffs = [BACKOFF_S, BACKOFF_M, BACKOFF_L, BACKOFF_X], jitter = BACKOFF_JITTER } = {}\n  ) {\n    this.jitter = jitter\n    this.backoffs = backoffs\n\n    this._sTimer = new BulkTimer(backoffs[0] + Math.round(jitter * Math.random()), push)\n    this._mTimer = new BulkTimer(backoffs[1] + Math.round(jitter * Math.random()), push)\n    this._lTimer = new BulkTimer(backoffs[2] + Math.round(jitter * Math.random()), push)\n    this._xTimer = new BulkTimer(backoffs[3] + Math.round(jitter * Math.random()), push)\n  }\n\n  _selectRetryTimer(peerInfo) {\n    if (peerInfo.banned || !peerInfo.reconnecting) return null\n\n    if (peerInfo.attempts > 3) {\n      return peerInfo.explicit ? this._xTimer : null\n    }\n\n    if (peerInfo.attempts === 0) return this._sTimer\n    if (peerInfo.proven) {\n      switch (peerInfo.attempts) {\n        case 1:\n          return this._sTimer\n        case 2:\n          return this._mTimer\n        case 3:\n          return this._lTimer\n      }\n    } else {\n      switch (peerInfo.attempts) {\n        case 1:\n          return this._mTimer\n        case 2:\n          return this._lTimer\n        case 3:\n          return this._lTimer\n      }\n    }\n\n    return null\n  }\n\n  add(peerInfo) {\n    const timer = this._selectRetryTimer(peerInfo)\n    if (!timer) return false\n\n    timer.add(peerInfo)\n    return true\n  }\n\n  destroy() {\n    this._sTimer.destroy()\n    this._mTimer.destroy()\n    this._lTimer.destroy()\n    this._xTimer.destroy()\n  }\n}\n{\n  \"name\": \"hyperswarm\",\n  \"version\": \"4.16.0\",\n  \"description\": \"A distributed networking stack for connecting peers\",\n  \"files\": [\n    \"index.js\",\n    \"lib/**.js\"\n  ],\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"dependencies\": {\n    \"b4a\": \"^1.3.1\",\n    \"bare-events\": \"^2.2.0\",\n    \"hyperdht\": \"^6.21.0\",\n    \"safety-catch\": \"^1.0.2\",\n    \"shuffled-priority-queue\": \"^2.1.0\",\n    \"streamx\": \"^2.22.1\",\n    \"unslab\": \"^1.3.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.0.2\",\n    \"hypercore-crypto\": \"^3.4.0\",\n    \"prettier\": \"^3.6.2\",\n    \"prettier-config-holepunch\": \"^2.0.0\"\n  },\n  \"scripts\": {\n    \"format\": \"prettier --write .\",\n    \"lint\": \"prettier --check .\",\n    \"test\": \"node test/all.js\",\n    \"test:generate\": \"brittle -r test/all.js test/*.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/holepunchto/hyperswarm.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"contributors\": [\n    \"David Mark Clements (@davidmarkclem)\",\n    \"Andrew Osheroff (@andrewosh)\"\n  ],\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/hyperswarm/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/hyperswarm\"\n}\nconst { EventEmitter } = require('events')\n\nmodule.exports = class RoutingTable extends EventEmitter {\n  constructor (id, opts) {\n    if (!opts) opts = {}\n\n    super()\n\n    this.id = id\n    this.k = opts.k || 20\n    this.size = 0\n    this.rows = new Array(id.length * 8)\n  }\n\n  add (node) {\n    const i = this._diff(node.id)\n\n    let row = this.rows[i]\n\n    if (!row) {\n      row = this.rows[i] = new Row(this, i)\n      this.emit('row', row)\n    }\n\n    const len = row.nodes.length\n    if (!row.add(node, this.k)) return false\n\n    this.size += row.nodes.length - len\n    return true\n  }\n\n  remove (id) {\n    const i = this._diff(id)\n    const row = this.rows[i]\n    if (!row) return false\n    if (!row.remove(id)) return false\n    this.size--\n    return true\n  }\n\n  get (id) {\n    const i = this._diff(id)\n    const row = this.rows[i]\n    if (!row) return null\n    return row.get(id)\n  }\n\n  has (id) {\n    return this.get(id) !== null\n  }\n\n  random () {\n    let n = (Math.random() * this.size) | 0\n\n    for (let i = 0; i < this.rows.length; i++) {\n      const r = this.rows[i]\n      if (!r) continue\n      if (n < r.nodes.length) return r.nodes[n]\n      n -= r.nodes.length\n    }\n\n    return null\n  }\n\n  closest (id, k) {\n    if (!k) k = this.k\n\n    const result = []\n    const d = this._diff(id)\n\n    // push close nodes\n    for (let i = d; i >= 0 && result.length < k; i--) this._pushNodes(i, k, result)\n\n    // if we don't have enough close nodes, populate from other rows, re the paper\n    for (let i = d + 1; i < this.rows.length && result.length < k; i++) this._pushNodes(i, k, result)\n\n    return result\n  }\n\n  _pushNodes (i, k, result) {\n    const row = this.rows[i]\n    if (!row) return\n\n    const missing = Math.min(k - result.length, row.nodes.length)\n    for (let j = 0; j < missing; j++) result.push(row.nodes[j])\n  }\n\n  toArray () {\n    return this.closest(this.id, Infinity)\n  }\n\n  _diff (id) {\n    for (let i = 0; i < id.length; i++) {\n      const a = id[i]\n      const b = this.id[i]\n\n      if (a !== b) return i * 8 + Math.clz32(a ^ b) - 24\n    }\n\n    return this.rows.length - 1\n  }\n}\n\nclass Row extends EventEmitter {\n  constructor (table, index) {\n    super()\n\n    this.data = null // can be used be upstream for whatevs\n    this.byteOffset = index >> 3\n    this.index = index\n    this.table = table\n    this.nodes = []\n  }\n\n  add (node) {\n    const id = node.id\n\n    let l = 0\n    let r = this.nodes.length - 1\n\n    while (l <= r) {\n      const m = (l + r) >> 1\n      const c = this.compare(id, this.nodes[m].id)\n\n      if (c === 0) {\n        this.nodes[m] = node\n        return true\n      }\n\n      if (c < 0) r = m - 1\n      else l = m + 1\n    }\n\n    if (this.nodes.length >= this.table.k) {\n      this.emit('full', node)\n      return false\n    }\n\n    this.insert(l, node)\n    return true\n  }\n\n  remove (id) {\n    let l = 0\n    let r = this.nodes.length - 1\n\n    while (l <= r) {\n      const m = (l + r) >> 1\n      const c = this.compare(id, this.nodes[m].id)\n\n      if (c === 0) {\n        this.splice(m)\n        return true\n      }\n\n      if (c < 0) r = m - 1\n      else l = m + 1\n    }\n\n    return false\n  }\n\n  get (id) {\n    let l = 0\n    let r = this.nodes.length - 1\n\n    while (l <= r) {\n      const m = (l + r) >> 1\n      const node = this.nodes[m]\n      const c = this.compare(id, node.id)\n\n      if (c === 0) return node\n      if (c < 0) r = m - 1\n      else l = m + 1\n    }\n\n    return null\n  }\n\n  insert (i, node) {\n    this.nodes.push(node) // push node or null or whatevs, just trying to not be polymorphic\n    for (let j = this.nodes.length - 1; j > i; j--) this.nodes[j] = this.nodes[j - 1]\n    this.nodes[i] = node\n    this.emit('add', node)\n  }\n\n  splice (i) {\n    for (; i < this.nodes.length - 1; i++) this.nodes[i] = this.nodes[i + 1]\n    this.emit('remove', this.nodes.pop())\n  }\n\n  // very likely they diverge after a couple of bytes so a simple impl, like this is prop fastest vs Buffer.compare\n  compare (a, b) {\n    for (let i = this.byteOffset; i < a.length; i++) {\n      const ai = a[i]\n      const bi = b[i]\n      if (ai === bi) continue\n      return ai < bi ? -1 : 1\n    }\n    return 0\n  }\n}\n{\n  \"name\": \"kademlia-routing-table\",\n  \"version\": \"1.0.6\",\n  \"description\": \"XOR based routing table used for P2P networks such as a Kademlia DHT.\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"dependencies\": {\n    \"bare-events\": \"^2.2.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"standard\": \"^17.1.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"keywords\": [\n    \"kademlia\",\n    \"p2p\",\n    \"k-bucket\",\n    \"k-buckets\",\n    \"xor\",\n    \"routing\",\n    \"distributed\",\n    \"systems\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/kademlia-routing-table.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/kademlia-routing-table/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/kademlia-routing-table\"\n}\nmodule.exports = assert\n\nclass AssertionError extends Error {}\nAssertionError.prototype.name = 'AssertionError'\n\n/**\n * Minimal assert function\n * @param  {any} t Value to check if falsy\n * @param  {string=} m Optional assertion error message\n * @throws {AssertionError}\n */\nfunction assert (t, m) {\n  if (!t) {\n    var err = new AssertionError(m)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, assert)\n    throw err\n  }\n}\n{\n  \"name\": \"nanoassert\",\n  \"version\": \"2.0.0\",\n  \"description\": \"Nanoscale assertion module\",\n  \"main\": \"index.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"tape\": \"^4.9.1\"\n  },\n  \"scripts\": {\n    \"test\": \"tape test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/emilbayes/nanoassert.git\"\n  },\n  \"keywords\": [\n    \"assert\",\n    \"unassert\",\n    \"power-assert\",\n    \"tiny\",\n    \"nano\",\n    \"pico\"\n  ],\n  \"author\": \"Emil Bay <github@tixz.dk>\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/emilbayes/nanoassert/issues\"\n  },\n  \"homepage\": \"https://github.com/emilbayes/nanoassert#readme\"\n}\nmodule.exports = class NatSampler {\n  constructor () {\n    this.host = null\n    this.port = 0\n    this.size = 0\n\n    this._a = null\n    this._b = null\n    this._threshold = 0\n    this._top = 0\n    this._samples = []\n  }\n\n  add (host, port) {\n    const a = this._bump(host, port, 2)\n    const b = this._bump(host, 0, 1)\n\n    if (this._samples.length < 32) {\n      this.size++\n      this._threshold = this.size - (this.size < 4 ? 0 : this.size < 8 ? 1 : this.size < 12 ? 2 : 3)\n      this._samples.push(a, b)\n      this._top += 2\n    } else {\n      if (this._top === 32) this._top = 0\n\n      const oa = this._samples[this._top]\n      this._samples[this._top++] = a\n      oa.hits--\n\n      const ob = this._samples[this._top]\n      this._samples[this._top++] = b\n      ob.hits--\n    }\n\n    if (this._a === null || this._a.hits < a.hits) this._a = a\n    if (this._b === null || this._b.hits < b.hits) this._b = b\n\n    if (this._a.hits >= this._threshold) {\n      this.host = this._a.host\n      this.port = this._a.port\n    } else if (this._b.hits >= this._threshold) {\n      this.host = this._b.host\n      this.port = 0\n    } else {\n      this.host = null\n      this.port = 0\n    }\n\n    return a.hits\n  }\n\n  _bump (host, port, inc) {\n    for (let i = 0; i < 4; i++) {\n      const j = (this._top - inc - (2 * i)) & 31\n      if (j >= this._samples.length) return { host, port, hits: 1 }\n      const s = this._samples[j]\n      if (s.port === port && s.host === host) {\n        s.hits++\n        return s\n      }\n    }\n    return { host, port, hits: 1 }\n  }\n}\n{\n  \"name\": \"nat-sampler\",\n  \"version\": \"1.0.1\",\n  \"description\": \"Sample addresses to figure out if a host + port is consistent\",\n  \"main\": \"index.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"standard\": \"^16.0.3\",\n    \"tape\": \"^5.2.2\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/nat-sampler.git\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && tape test.js\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/nat-sampler/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/nat-sampler\"\n}\n/* eslint-disable camelcase */\nconst sodium = require('sodium-universal')\nconst assert = require('nanoassert')\nconst b4a = require('b4a')\n\nconst DHLEN = sodium.crypto_scalarmult_ed25519_BYTES\nconst PKLEN = sodium.crypto_scalarmult_ed25519_BYTES\nconst SCALARLEN = sodium.crypto_scalarmult_ed25519_BYTES\nconst SKLEN = sodium.crypto_sign_SECRETKEYBYTES\nconst ALG = 'Ed25519'\n\nmodule.exports = {\n  DHLEN,\n  PKLEN,\n  SCALARLEN,\n  SKLEN,\n  ALG,\n  name: ALG,\n  generateKeyPair,\n  dh\n}\n\nfunction generateKeyPair (privKey) {\n  if (privKey) return generateSeedKeyPair(privKey.subarray(0, 32))\n\n  const keyPair = {}\n  keyPair.secretKey = b4a.alloc(SKLEN)\n  keyPair.publicKey = b4a.alloc(PKLEN)\n\n  sodium.crypto_sign_keypair(keyPair.publicKey, keyPair.secretKey)\n  return keyPair\n}\n\nfunction generateSeedKeyPair (seed) {\n  const keyPair = {}\n  keyPair.secretKey = b4a.alloc(SKLEN)\n  keyPair.publicKey = b4a.alloc(PKLEN)\n\n  sodium.crypto_sign_seed_keypair(keyPair.publicKey, keyPair.secretKey, seed)\n  return keyPair\n}\n\nfunction dh (publicKey, { scalar, secretKey }) {\n  // tweaked keys expose scalar directly\n  if (!scalar) {\n    assert(secretKey.byteLength === SKLEN)\n\n    // libsodium stores seed not actual scalar\n    const sk = b4a.alloc(64)\n    sodium.crypto_hash_sha512(sk, secretKey.subarray(0, 32))\n    sk[0] &= 248\n    sk[31] &= 127\n    sk[31] |= 64\n\n    scalar = sk.subarray(0, 32)\n  }\n\n  assert(scalar.byteLength === SCALARLEN)\n  assert(publicKey.byteLength === PKLEN)\n\n  const output = b4a.alloc(DHLEN)\n\n  // we clamp if necessary above\n  sodium.crypto_scalarmult_ed25519_noclamp(\n    output,\n    scalar,\n    publicKey\n  )\n\n  return output\n}\n{\n  \"name\": \"noise-curve-ed\",\n  \"version\": \"2.1.0\",\n  \"description\": \"Ed25519 elliptic curve operations for [`noise-handshake`](https://github.com/chm-diederichs/noise-handshake)\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"npx standard && tape test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/chm-diederichs/noise-curve-ed.git\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/chm-diederichs/noise-curve-ed/issues\"\n  },\n  \"homepage\": \"https://github.com/chm-diederichs/noise-curve-ed#readme\",\n  \"dependencies\": {\n    \"b4a\": \"^1.1.0\",\n    \"nanoassert\": \"^2.0.0\",\n    \"sodium-universal\": \"^5.0.0\"\n  },\n  \"devDependencies\": {\n    \"noise-handshake\": \"^3.0.0\",\n    \"standard\": \"^16.0.3\",\n    \"tape\": \"^5.2.2\"\n  }\n}\nconst sodium = require('sodium-universal')\nconst b4a = require('b4a')\n\nmodule.exports = class CipherState {\n  constructor (key) {\n    this.key = key || null\n    this.nonce = 0\n    this.CIPHER_ALG = 'ChaChaPoly'\n  }\n\n  initialiseKey (key) {\n    this.key = key\n    this.nonce = 0\n  }\n\n  setNonce (nonce) {\n    this.nonce = nonce\n  }\n\n  encrypt (plaintext, ad) {\n    if (!this.hasKey) return plaintext\n    if (!ad) ad = b4a.alloc(0)\n\n    const ciphertext = encryptWithAD(this.key, this.nonce, ad, plaintext)\n    if (ciphertext.length > 65535) throw new Error(`ciphertext length of ${ciphertext.length} exceeds maximum Noise message length of 65535`)\n    this.nonce++\n\n    return ciphertext\n  }\n\n  decrypt (ciphertext, ad) {\n    if (!this.hasKey) return ciphertext\n    if (!ad) ad = b4a.alloc(0)\n    if (ciphertext.length > 65535) throw new Error(`ciphertext length of ${ciphertext.length} exceeds maximum Noise message length of 65535`)\n\n    const plaintext = decryptWithAD(this.key, this.nonce, ad, ciphertext)\n    this.nonce++\n\n    return plaintext\n  }\n\n  get hasKey () {\n    return this.key !== null\n  }\n\n  _clear () {\n    sodium.sodium_memzero(this.key)\n    this.key = null\n    this.nonce = null\n  }\n\n  static get MACBYTES () {\n    return 16\n  }\n\n  static get NONCEBYTES () {\n    return 8\n  }\n\n  static get KEYBYTES () {\n    return 32\n  }\n}\n\nfunction encryptWithAD (key, counter, additionalData, plaintext) {\n  // for our purposes, additionalData will always be a pubkey so we encode from hex\n  if (!b4a.isBuffer(additionalData)) additionalData = b4a.from(additionalData, 'hex')\n  if (!b4a.isBuffer(plaintext)) plaintext = b4a.from(plaintext, 'hex')\n\n  const nonce = b4a.alloc(sodium.crypto_aead_chacha20poly1305_ietf_NPUBBYTES)\n  const view = new DataView(nonce.buffer, nonce.byteOffset, nonce.byteLength)\n  view.setUint32(4, counter, true)\n\n  const ciphertext = b4a.alloc(plaintext.byteLength + sodium.crypto_aead_chacha20poly1305_ietf_ABYTES)\n\n  sodium.crypto_aead_chacha20poly1305_ietf_encrypt(ciphertext, plaintext, additionalData, null, nonce, key)\n  return ciphertext\n}\n\nfunction decryptWithAD (key, counter, additionalData, ciphertext) {\n  // for our purposes, additionalData will always be a pubkey so we encode from hex\n  if (!b4a.isBuffer(additionalData)) additionalData = b4a.from(additionalData, 'hex')\n  if (!b4a.isBuffer(ciphertext)) ciphertext = b4a.from(ciphertext, 'hex')\n\n  const nonce = b4a.alloc(sodium.crypto_aead_chacha20poly1305_ietf_NPUBBYTES)\n  const view = new DataView(nonce.buffer, nonce.byteOffset, nonce.byteLength)\n  view.setUint32(4, counter, true)\n\n  const plaintext = b4a.alloc(ciphertext.byteLength - sodium.crypto_aead_chacha20poly1305_ietf_ABYTES)\n\n  sodium.crypto_aead_chacha20poly1305_ietf_decrypt(plaintext, null, ciphertext, additionalData, nonce, key)\n  return plaintext\n}\n/* eslint-disable camelcase */\nconst {\n  crypto_kx_SEEDBYTES,\n  crypto_kx_keypair,\n  crypto_kx_seed_keypair,\n  crypto_scalarmult_BYTES,\n  crypto_scalarmult_SCALARBYTES,\n  crypto_scalarmult,\n  crypto_scalarmult_base\n} = require('sodium-universal')\n\nconst assert = require('nanoassert')\nconst b4a = require('b4a')\n\nconst DHLEN = crypto_scalarmult_BYTES\nconst PKLEN = crypto_scalarmult_BYTES\nconst SKLEN = crypto_scalarmult_SCALARBYTES\nconst SEEDLEN = crypto_kx_SEEDBYTES\nconst ALG = '25519'\n\nmodule.exports = {\n  DHLEN,\n  PKLEN,\n  SKLEN,\n  SEEDLEN,\n  ALG,\n  generateKeyPair,\n  generateSeedKeyPair,\n  dh\n}\n\nfunction generateKeyPair (privKey) {\n  const keyPair = {}\n\n  keyPair.secretKey = privKey || b4a.alloc(SKLEN)\n  keyPair.publicKey = b4a.alloc(PKLEN)\n\n  if (privKey) {\n    crypto_scalarmult_base(keyPair.publicKey, keyPair.secretKey)\n  } else {\n    crypto_kx_keypair(keyPair.publicKey, keyPair.secretKey)\n  }\n\n  return keyPair\n}\n\nfunction generateSeedKeyPair (seed) {\n  assert(seed.byteLength === SKLEN)\n\n  const keyPair = {}\n  keyPair.secretKey = b4a.alloc(SKLEN)\n  keyPair.publicKey = b4a.alloc(PKLEN)\n\n  crypto_kx_seed_keypair(keyPair.publicKey, keyPair.secretKey, seed)\n  return keyPair\n}\n\nfunction dh (publicKey, { secretKey }) {\n  assert(secretKey.byteLength === SKLEN)\n  assert(publicKey.byteLength === PKLEN)\n\n  const output = b4a.alloc(DHLEN)\n\n  crypto_scalarmult(\n    output,\n    secretKey,\n    publicKey\n  )\n\n  return output\n}\nconst hmacBlake2b = require('./hmac')\nconst b4a = require('b4a')\n\nconst HASHLEN = 64\n\nmodule.exports = {\n  hkdf,\n  HASHLEN\n}\n\n// HMAC-based Extract-and-Expand KDF\n// https://www.ietf.org/rfc/rfc5869.txt\n\nfunction hkdf (salt, inputKeyMaterial, info = '', length = 2 * HASHLEN) {\n  const pseudoRandomKey = hkdfExtract(salt, inputKeyMaterial)\n  return hkdfExpand(pseudoRandomKey, info, length)\n}\n\nfunction hkdfExtract (salt, inputKeyMaterial) {\n  const hmac = b4a.alloc(HASHLEN)\n  return hmacDigest(hmac, salt, inputKeyMaterial)\n}\n\nfunction hkdfExpand (key, info, length) {\n  // Put in dedicated slab to avoid keeping shared slab from being gc'ed\n  const buffer = b4a.allocUnsafeSlow(length)\n\n  const infoBuf = b4a.from(info)\n  let prev = infoBuf\n\n  const result = []\n  for (let i = 0; i < length; i += HASHLEN) {\n    const pos = b4a.from([(i / HASHLEN) + 1])\n\n    const out = buffer.subarray(i, i + HASHLEN)\n    result.push(out)\n\n    prev = hmacDigest(out, key, [prev, infoBuf, pos])\n  }\n\n  return result\n}\n\nfunction hmacDigest (out, key, input) {\n  hmacBlake2b(out, input, key)\n  return out\n}\n/* eslint-disable camelcase */\nconst b4a = require('b4a')\nconst { sodium_memzero, crypto_generichash, crypto_generichash_batch } = require('sodium-universal')\n\nconst HASHLEN = 64\nconst BLOCKLEN = 128\nconst scratch = b4a.alloc(BLOCKLEN * 3)\nconst HMACKey = scratch.subarray(BLOCKLEN * 0, BLOCKLEN * 1)\nconst OuterKeyPad = scratch.subarray(BLOCKLEN * 1, BLOCKLEN * 2)\nconst InnerKeyPad = scratch.subarray(BLOCKLEN * 2, BLOCKLEN * 3)\n\n// Post-fill is done in the cases where someone caught an exception that\n// happened before we were able to clear data at the end\n\nmodule.exports = function hmac (out, batch, key) {\n  if (key.byteLength > BLOCKLEN) {\n    crypto_generichash(HMACKey.subarray(0, HASHLEN), key)\n    sodium_memzero(HMACKey.subarray(HASHLEN))\n  } else {\n    // Covers key <= BLOCKLEN\n    HMACKey.set(key)\n    sodium_memzero(HMACKey.subarray(key.byteLength))\n  }\n\n  for (let i = 0; i < HMACKey.byteLength; i++) {\n    OuterKeyPad[i] = 0x5c ^ HMACKey[i]\n    InnerKeyPad[i] = 0x36 ^ HMACKey[i]\n  }\n  sodium_memzero(HMACKey)\n\n  crypto_generichash_batch(out, [InnerKeyPad].concat(batch))\n  sodium_memzero(InnerKeyPad)\n  crypto_generichash_batch(out, [OuterKeyPad, out])\n  sodium_memzero(OuterKeyPad)\n}\n\nmodule.exports.BYTES = HASHLEN\nmodule.exports.KEYBYTES = BLOCKLEN\nconst assert = require('nanoassert')\nconst b4a = require('b4a')\n\nconst SymmetricState = require('./symmetric-state')\nconst { HASHLEN } = require('./hkdf')\n\nconst PRESHARE_IS = Symbol('initiator static key preshared')\nconst PRESHARE_RS = Symbol('responder static key preshared')\n\nconst TOK_PSK = Symbol('psk')\n\nconst TOK_S = Symbol('s')\nconst TOK_E = Symbol('e')\n\nconst TOK_ES = Symbol('es')\nconst TOK_SE = Symbol('se')\nconst TOK_EE = Symbol('ee')\nconst TOK_SS = Symbol('ss')\n\nconst HANDSHAKES = Object.freeze({\n  NN: [\n    [TOK_E],\n    [TOK_E, TOK_EE]\n  ],\n  NNpsk0: [\n    [TOK_PSK, TOK_E],\n    [TOK_E, TOK_EE]\n  ],\n  XX: [\n    [TOK_E],\n    [TOK_E, TOK_EE, TOK_S, TOK_ES],\n    [TOK_S, TOK_SE]\n  ],\n  XXpsk0: [\n    [TOK_PSK, TOK_E],\n    [TOK_E, TOK_EE, TOK_S, TOK_ES],\n    [TOK_S, TOK_SE]\n  ],\n  IK: [\n    PRESHARE_RS,\n    [TOK_E, TOK_ES, TOK_S, TOK_SS],\n    [TOK_E, TOK_EE, TOK_SE]\n  ],\n  XK: [\n    PRESHARE_RS,\n    [TOK_E, TOK_ES],\n    [TOK_E, TOK_EE],\n    [TOK_S, TOK_SE]\n  ]\n})\n\nclass Writer {\n  constructor () {\n    this.size = 0\n    this.buffers = []\n  }\n\n  push (b) {\n    this.size += b.byteLength\n    this.buffers.push(b)\n  }\n\n  end () {\n    const all = b4a.alloc(this.size)\n    let offset = 0\n    for (const b of this.buffers) {\n      all.set(b, offset)\n      offset += b.byteLength\n    }\n    return all\n  }\n}\n\nclass Reader {\n  constructor (buf) {\n    this.offset = 0\n    this.buffer = buf\n  }\n\n  shift (n) {\n    const start = this.offset\n    const end = this.offset += n\n    if (end > this.buffer.byteLength) throw new Error('Insufficient bytes')\n    return this.buffer.subarray(start, end)\n  }\n\n  end () {\n    return this.shift(this.buffer.byteLength - this.offset)\n  }\n}\n\nmodule.exports = class NoiseState extends SymmetricState {\n  constructor (pattern, initiator, staticKeypair, opts = {}) {\n    super(opts)\n\n    this.s = staticKeypair || this.curve.generateKeyPair()\n    this.e = null\n\n    this.psk = null\n    if (opts && opts.psk) this.psk = opts.psk\n\n    this.re = null\n    this.rs = null\n\n    this.pattern = pattern\n    this.handshake = HANDSHAKES[this.pattern].slice()\n\n    this.isPskHandshake = !!this.psk && hasPskToken(this.handshake)\n\n    this.protocol = b4a.from([\n      'Noise',\n      this.pattern,\n      this.DH_ALG,\n      this.CIPHER_ALG,\n      'BLAKE2b'\n    ].join('_'))\n\n    this.initiator = initiator\n    this.complete = false\n\n    this.rx = null\n    this.tx = null\n    this.hash = null\n  }\n\n  initialise (prologue, remoteStatic) {\n    if (this.protocol.byteLength <= HASHLEN) this.digest.set(this.protocol)\n    else this.mixHash(this.protocol)\n\n    this.chainingKey = b4a.from(this.digest)\n\n    this.mixHash(prologue)\n\n    while (!Array.isArray(this.handshake[0])) {\n      const message = this.handshake.shift()\n\n      // handshake steps should be as arrays, only\n      // preshare tokens are provided otherwise\n      assert(message === PRESHARE_RS || message === PRESHARE_IS,\n        'Unexpected pattern')\n\n      const takeRemoteKey = this.initiator\n        ? message === PRESHARE_RS\n        : message === PRESHARE_IS\n\n      if (takeRemoteKey) this.rs = remoteStatic\n\n      const key = takeRemoteKey ? this.rs : this.s.publicKey\n      assert(key != null, 'Remote pubkey required')\n\n      this.mixHash(key)\n    }\n  }\n\n  final () {\n    const [k1, k2] = this.split()\n\n    this.tx = this.initiator ? k1 : k2\n    this.rx = this.initiator ? k2 : k1\n\n    this.complete = true\n    this.hash = this.getHandshakeHash()\n\n    this._clear()\n  }\n\n  recv (buf) {\n    const r = new Reader(buf)\n\n    for (const pattern of this.handshake.shift()) {\n      switch (pattern) {\n        case TOK_PSK :\n          this.mixKeyAndHash(this.psk)\n          break\n\n        case TOK_E :\n          this.re = r.shift(this.curve.PKLEN)\n          this.mixHash(this.re)\n          if (this.isPskHandshake) this.mixKeyNormal(this.re)\n          break\n\n        case TOK_S : {\n          const klen = this.hasKey ? this.curve.PKLEN + 16 : this.curve.PKLEN\n          this.rs = this.decryptAndHash(r.shift(klen))\n          break\n        }\n\n        case TOK_EE :\n        case TOK_ES :\n        case TOK_SE :\n        case TOK_SS : {\n          const useStatic = keyPattern(pattern, this.initiator)\n\n          const localKey = useStatic.local ? this.s : this.e\n          const remoteKey = useStatic.remote ? this.rs : this.re\n\n          this.mixKey(remoteKey, localKey)\n          break\n        }\n\n        default :\n          throw new Error('Unexpected message')\n      }\n    }\n\n    const payload = this.decryptAndHash(r.end())\n\n    if (!this.handshake.length) this.final()\n    return payload\n  }\n\n  send (payload = b4a.alloc(0)) {\n    const w = new Writer()\n\n    for (const pattern of this.handshake.shift()) {\n      switch (pattern) {\n        case TOK_PSK :\n          this.mixKeyAndHash(this.psk)\n          break\n\n        case TOK_E :\n          if (this.e === null) this.e = this.curve.generateKeyPair()\n          this.mixHash(this.e.publicKey)\n          if (this.isPskHandshake) this.mixKeyNormal(this.e.publicKey)\n          w.push(this.e.publicKey)\n          break\n\n        case TOK_S :\n          w.push(this.encryptAndHash(this.s.publicKey))\n          break\n\n        case TOK_ES :\n        case TOK_SE :\n        case TOK_EE :\n        case TOK_SS : {\n          const useStatic = keyPattern(pattern, this.initiator)\n\n          const localKey = useStatic.local ? this.s : this.e\n          const remoteKey = useStatic.remote ? this.rs : this.re\n\n          this.mixKey(remoteKey, localKey)\n          break\n        }\n\n        default :\n          throw new Error('Unexpected message')\n      }\n    }\n\n    w.push(this.encryptAndHash(payload))\n    const response = w.end()\n\n    if (!this.handshake.length) this.final()\n    return response\n  }\n\n  _clear () {\n    super._clear()\n\n    this.e.secretKey.fill(0)\n    this.e.publicKey.fill(0)\n\n    this.re.fill(0)\n\n    this.e = null\n    this.re = null\n  }\n}\n\nfunction keyPattern (pattern, initiator) {\n  const ret = {\n    local: false,\n    remote: false\n  }\n\n  switch (pattern) {\n    case TOK_EE:\n      return ret\n\n    case TOK_ES:\n      ret.local ^= !initiator\n      ret.remote ^= initiator\n      return ret\n\n    case TOK_SE:\n      ret.local ^= initiator\n      ret.remote ^= !initiator\n      return ret\n\n    case TOK_SS:\n      ret.local ^= 1\n      ret.remote ^= 1\n      return ret\n  }\n}\n\nfunction hasPskToken (handshake) {\n  return handshake.some(x => {\n    return Array.isArray(x) && x.indexOf(TOK_PSK) !== -1\n  })\n}\n{\n  \"name\": \"noise-handshake\",\n  \"version\": \"4.2.0\",\n  \"description\": \"Noise protocol handshake\",\n  \"main\": \"noise.js\",\n  \"files\": [\n    \"*.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && brittle test/*.js\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/noise-handshake.git\"\n  },\n  \"dependencies\": {\n    \"b4a\": \"^1.1.0\",\n    \"nanoassert\": \"^2.0.0\",\n    \"sodium-universal\": \"^5.0.0\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"noise-protocol\": \"chm-diederichs/noise-protocol.git#xx-ephemeral-key\",\n    \"standard\": \"^16.0.3\"\n  }\n}\nconst sodium = require('sodium-universal')\nconst assert = require('nanoassert')\nconst b4a = require('b4a')\nconst CipherState = require('./cipher')\nconst curve = require('./dh')\nconst { HASHLEN, hkdf } = require('./hkdf')\n\nmodule.exports = class SymmetricState extends CipherState {\n  constructor (opts = {}) {\n    super()\n\n    this.curve = opts.curve || curve\n    this.digest = b4a.alloc(HASHLEN)\n    this.chainingKey = null\n    this.offset = 0\n\n    this.DH_ALG = this.curve.ALG\n  }\n\n  mixHash (data) {\n    accumulateDigest(this.digest, data)\n  }\n\n  mixKeyAndHash (key) {\n    const [ck, tempH, tempK] = hkdf(this.chainingKey, key, '', 3 * HASHLEN)\n    this.chainingKey = ck\n    this.mixHash(tempH)\n    this.initialiseKey(tempK.subarray(0, 32))\n  }\n\n  mixKeyNormal (key) {\n    const [ck, tempK] = hkdf(this.chainingKey, key)\n    this.chainingKey = ck\n    this.initialiseKey(tempK.subarray(0, 32))\n  }\n\n  mixKey (remoteKey, localKey) {\n    const dh = this.curve.dh(remoteKey, localKey)\n    const hkdfResult = hkdf(this.chainingKey, dh)\n    this.chainingKey = hkdfResult[0]\n    this.initialiseKey(hkdfResult[1].subarray(0, 32))\n  }\n\n  encryptAndHash (plaintext) {\n    const ciphertext = this.encrypt(plaintext, this.digest)\n    accumulateDigest(this.digest, ciphertext)\n    return ciphertext\n  }\n\n  decryptAndHash (ciphertext) {\n    const plaintext = this.decrypt(ciphertext, this.digest)\n    accumulateDigest(this.digest, ciphertext)\n    return plaintext\n  }\n\n  getHandshakeHash (out) {\n    if (!out) return this.getHandshakeHash(b4a.alloc(HASHLEN))\n    assert(out.byteLength === HASHLEN, `output must be ${HASHLEN} bytes`)\n\n    out.set(this.digest)\n    return out\n  }\n\n  split () {\n    const res = hkdf(this.chainingKey, b4a.alloc(0))\n    return res.map(k => k.subarray(0, 32))\n  }\n\n  _clear () {\n    super._clear()\n\n    sodium.sodium_memzero(this.digest)\n    sodium.sodium_memzero(this.chainingKey)\n\n    this.digest = null\n    this.chainingKey = null\n    this.offset = null\n\n    this.curve = null\n  }\n\n  static get alg () {\n    return CipherState.alg + '_BLAKE2b'\n  }\n}\n\nfunction accumulateDigest (digest, input) {\n  const toHash = b4a.concat([digest, input])\n  sodium.crypto_generichash(digest, toHash)\n}\nconst b4a = require('b4a')\nconst c = require('compact-encoding')\nconst queueTick = require('queue-tick')\nconst safetyCatch = require('safety-catch')\nconst unslab = require('unslab')\n\nconst MAX_BUFFERED = 32768\nconst MAX_BACKLOG = Infinity // TODO: impl \"open\" backpressure\nconst MAX_BATCH = 8 * 1024 * 1024\n\nclass Channel {\n  constructor (mux, info, userData, protocol, aliases, id, handshake, messages, onopen, onclose, ondestroy, ondrain) {\n    this.userData = userData\n    this.protocol = protocol\n    this.aliases = aliases\n    this.id = id\n    this.handshake = null\n    this.messages = []\n\n    this.opened = false\n    this.closed = false\n    this.destroyed = false\n\n    this.onopen = onopen\n    this.onclose = onclose\n    this.ondestroy = ondestroy\n    this.ondrain = ondrain\n\n    this._handshake = handshake\n    this._mux = mux\n    this._info = info\n    this._localId = 0\n    this._remoteId = 0\n    this._active = 0\n    this._extensions = null\n\n    this._decBound = this._dec.bind(this)\n    this._decAndDestroyBound = this._decAndDestroy.bind(this)\n\n    this._openedPromise = null\n    this._openedResolve = null\n\n    this._destroyedPromise = null\n    this._destroyedResolve = null\n\n    for (const m of messages) this.addMessage(m)\n  }\n\n  get drained () {\n    return this._mux.drained\n  }\n\n  fullyOpened () {\n    if (this.opened) return Promise.resolve(true)\n    if (this.closed) return Promise.resolve(false)\n    if (this._openedPromise) return this._openedPromise\n\n    this._openedPromise = new Promise((resolve) => { this._openedResolve = resolve })\n    return this._openedPromise\n  }\n\n  fullyClosed () {\n    if (this.destroyed) return Promise.resolve()\n    if (this._destroyedPromise) return this._destroyedPromise\n\n    this._destroyedPromise = new Promise((resolve) => { this._destroyedResolve = resolve })\n    return this._destroyedPromise\n  }\n\n  open (handshake) {\n    const id = this._mux._free.length > 0\n      ? this._mux._free.pop()\n      : this._mux._local.push(null) - 1\n\n    this._info.opened++\n    this._info.lastChannel = this\n    this._localId = id + 1\n    this._mux._local[id] = this\n\n    if (this._remoteId === 0) {\n      this._info.outgoing.push(this._localId)\n    }\n\n    const state = { buffer: null, start: 2, end: 2 }\n\n    c.uint.preencode(state, this._localId)\n    c.string.preencode(state, this.protocol)\n    c.buffer.preencode(state, this.id)\n    if (this._handshake) this._handshake.preencode(state, handshake)\n\n    state.buffer = this._mux._alloc(state.end)\n\n    state.buffer[0] = 0\n    state.buffer[1] = 1\n    c.uint.encode(state, this._localId)\n    c.string.encode(state, this.protocol)\n    c.buffer.encode(state, this.id)\n    if (this._handshake) this._handshake.encode(state, handshake)\n\n    this._mux._write0(state.buffer)\n  }\n\n  _dec () {\n    if (--this._active === 0 && this.closed === true) this._destroy()\n  }\n\n  _decAndDestroy (err) {\n    this._dec()\n    this._mux._safeDestroy(err)\n  }\n\n  _fullyOpenSoon () {\n    this._mux._remote[this._remoteId - 1].session = this\n    queueTick(this._fullyOpen.bind(this))\n  }\n\n  _fullyOpen () {\n    if (this.opened === true || this.closed === true) return\n\n    const remote = this._mux._remote[this._remoteId - 1]\n\n    this.opened = true\n    this.handshake = this._handshake ? this._handshake.decode(remote.state) : null\n    this._track(this.onopen(this.handshake, this))\n\n    remote.session = this\n    remote.state = null\n    if (remote.pending !== null) this._drain(remote)\n\n    this._resolveOpen(true)\n  }\n\n  _resolveOpen (opened) {\n    if (this._openedResolve !== null) {\n      this._openedResolve(opened)\n      this._openedResolve = this._openedPromise = null\n    }\n  }\n\n  _resolveDestroyed () {\n    if (this._destroyedResolve !== null) {\n      this._destroyedResolve()\n      this._destroyedResolve = this._destroyedPromise = null\n    }\n  }\n\n  _drain (remote) {\n    for (let i = 0; i < remote.pending.length; i++) {\n      const p = remote.pending[i]\n      this._mux._buffered -= byteSize(p.state)\n      this._recv(p.type, p.state)\n    }\n\n    remote.pending = null\n    this._mux._resumeMaybe()\n  }\n\n  _track (p) {\n    if (isPromise(p) === true) {\n      this._active++\n      return p.then(this._decBound, this._decAndDestroyBound)\n    }\n\n    return null\n  }\n\n  _close (isRemote) {\n    if (this.closed === true) return\n    this.closed = true\n\n    this._info.opened--\n    if (this._info.lastChannel === this) this._info.lastChannel = null\n\n    if (this._remoteId > 0) {\n      this._mux._remote[this._remoteId - 1] = null\n      this._remoteId = 0\n      // If remote has acked, we can reuse the local id now\n      // otherwise, we need to wait for the \"ack\" to arrive\n      this._mux._free.push(this._localId - 1)\n    }\n\n    this._mux._local[this._localId - 1] = null\n    this._localId = 0\n\n    this._mux._gc(this._info)\n    this._track(this.onclose(isRemote, this))\n\n    if (this._active === 0) this._destroy()\n\n    this._resolveOpen(false)\n  }\n\n  _destroy () {\n    if (this.destroyed === true) return\n    this.destroyed = true\n    this._track(this.ondestroy(this))\n    this._resolveDestroyed()\n  }\n\n  _recv (type, state) {\n    if (type < this.messages.length) {\n      const m = this.messages[type]\n      const p = m.recv(state, this)\n      if (m.autoBatch === true) return p\n    }\n    return null\n  }\n\n  cork () {\n    this._mux.cork()\n  }\n\n  uncork () {\n    this._mux.uncork()\n  }\n\n  close () {\n    if (this.closed === true) return\n\n    const state = { buffer: null, start: 2, end: 2 }\n\n    c.uint.preencode(state, this._localId)\n\n    state.buffer = this._mux._alloc(state.end)\n\n    state.buffer[0] = 0\n    state.buffer[1] = 3\n    c.uint.encode(state, this._localId)\n\n    this._close(false)\n    this._mux._write0(state.buffer)\n  }\n\n  addMessage (opts) {\n    if (!opts) return this._skipMessage()\n\n    const type = this.messages.length\n    const autoBatch = opts.autoBatch !== false\n    const encoding = opts.encoding || c.raw\n    const onmessage = opts.onmessage || noop\n\n    const s = this\n    const typeLen = encodingLength(c.uint, type)\n\n    const m = {\n      type,\n      autoBatch,\n      encoding,\n      onmessage,\n      recv (state, session) {\n        return session._track(m.onmessage(encoding.decode(state), session))\n      },\n      send (m, session = s) {\n        if (session.closed === true) return false\n\n        const mux = session._mux\n        const state = { buffer: null, start: 0, end: typeLen }\n\n        if (mux._batch !== null) {\n          encoding.preencode(state, m)\n          state.buffer = mux._alloc(state.end)\n\n          c.uint.encode(state, type)\n          encoding.encode(state, m)\n\n          mux._pushBatch(session._localId, state.buffer)\n          return true\n        }\n\n        c.uint.preencode(state, session._localId)\n        encoding.preencode(state, m)\n\n        state.buffer = mux._alloc(state.end)\n\n        c.uint.encode(state, session._localId)\n        c.uint.encode(state, type)\n        encoding.encode(state, m)\n\n        mux.drained = mux.stream.write(state.buffer)\n\n        return mux.drained\n      }\n    }\n\n    this.messages.push(m)\n\n    return m\n  }\n\n  _skipMessage () {\n    const type = this.messages.length\n    const m = {\n      type,\n      encoding: c.raw,\n      onmessage: noop,\n      recv (state, session) {},\n      send (m, session) {}\n    }\n\n    this.messages.push(m)\n    return m\n  }\n}\n\nmodule.exports = class Protomux {\n  constructor (stream, { alloc } = {}) {\n    if (stream.userData === null) stream.userData = this\n\n    this.isProtomux = true\n    this.stream = stream\n    this.corked = 0\n    this.drained = true\n\n    this._alloc = alloc || (typeof stream.alloc === 'function' ? stream.alloc.bind(stream) : b4a.allocUnsafe)\n    this._safeDestroyBound = this._safeDestroy.bind(this)\n    this._uncorkBound = this.uncork.bind(this)\n\n    this._remoteBacklog = 0\n    this._buffered = 0\n    this._paused = false\n    this._remote = []\n    this._local = []\n    this._free = []\n    this._batch = null\n    this._batchState = null\n\n    this._infos = new Map()\n    this._notify = new Map()\n\n    this.stream.on('data', this._ondata.bind(this))\n    this.stream.on('drain', this._ondrain.bind(this))\n    this.stream.on('end', this._onend.bind(this))\n    this.stream.on('error', noop) // we handle this in \"close\"\n    this.stream.on('close', this._shutdown.bind(this))\n  }\n\n  static from (stream, opts) {\n    if (stream.userData && stream.userData.isProtomux) return stream.userData\n    if (stream.isProtomux) return stream\n    return new this(stream, opts)\n  }\n\n  static isProtomux (mux) {\n    return typeof mux === 'object' && mux.isProtomux === true\n  }\n\n  * [Symbol.iterator] () {\n    for (const session of this._local) {\n      if (session !== null) yield session\n    }\n  }\n\n  isIdle () {\n    return this._local.length === this._free.length\n  }\n\n  cork () {\n    if (++this.corked === 1) {\n      this._batch = []\n      this._batchState = { buffer: null, start: 0, end: 1 }\n    }\n  }\n\n  uncork () {\n    if (--this.corked === 0) {\n      this._sendBatch(this._batch, this._batchState)\n      this._batch = null\n      this._batchState = null\n    }\n  }\n\n  getLastChannel ({ protocol, id = null }) {\n    const key = toKey(protocol, id)\n    const info = this._infos.get(key)\n    if (info) return info.lastChannel\n    return null\n  }\n\n  pair ({ protocol, id = null }, notify) {\n    this._notify.set(toKey(protocol, id), notify)\n  }\n\n  unpair ({ protocol, id = null }) {\n    this._notify.delete(toKey(protocol, id))\n  }\n\n  opened ({ protocol, id = null }) {\n    const key = toKey(protocol, id)\n    const info = this._infos.get(key)\n    return info ? info.opened > 0 : false\n  }\n\n  createChannel ({ userData = null, protocol, aliases = [], id = null, unique = true, handshake = null, messages = [], onopen = noop, onclose = noop, ondestroy = noop, ondrain = noop }) {\n    if (this.stream.destroyed) return null\n\n    const info = this._get(protocol, id, aliases)\n    if (unique && info.opened > 0) return null\n\n    if (info.incoming.length === 0) {\n      return new Channel(this, info, userData, protocol, aliases, id, handshake, messages, onopen, onclose, ondestroy, ondrain)\n    }\n\n    this._remoteBacklog--\n\n    const remoteId = info.incoming.shift()\n    const r = this._remote[remoteId - 1]\n    if (r === null) return null\n\n    const session = new Channel(this, info, userData, protocol, aliases, id, handshake, messages, onopen, onclose, ondestroy, ondrain)\n\n    session._remoteId = remoteId\n    session._fullyOpenSoon()\n\n    return session\n  }\n\n  _pushBatch (localId, buffer) {\n    if (this._batchState.end >= MAX_BATCH) {\n      this._sendBatch(this._batch, this._batchState)\n      this._batch = []\n      this._batchState = { buffer: null, start: 0, end: 1 }\n    }\n\n    if (this._batch.length === 0 || this._batch[this._batch.length - 1].localId !== localId) {\n      this._batchState.end++\n      c.uint.preencode(this._batchState, localId)\n    }\n    c.buffer.preencode(this._batchState, buffer)\n    this._batch.push({ localId, buffer })\n  }\n\n  _sendBatch (batch, state) {\n    if (batch.length === 0) return\n\n    let prev = batch[0].localId\n\n    state.buffer = this._alloc(state.end)\n    state.buffer[state.start++] = 0\n    state.buffer[state.start++] = 0\n\n    c.uint.encode(state, prev)\n\n    for (let i = 0; i < batch.length; i++) {\n      const b = batch[i]\n      if (prev !== b.localId) {\n        state.buffer[state.start++] = 0\n        c.uint.encode(state, (prev = b.localId))\n      }\n      c.buffer.encode(state, b.buffer)\n    }\n\n    this.drained = this.stream.write(state.buffer)\n  }\n\n  _get (protocol, id, aliases = []) {\n    const key = toKey(protocol, id)\n\n    let info = this._infos.get(key)\n    if (info) return info\n\n    info = { key, protocol, aliases: [], id, pairing: 0, opened: 0, incoming: [], outgoing: [], lastChannel: null }\n    this._infos.set(key, info)\n\n    for (const alias of aliases) {\n      const key = toKey(alias, id)\n      info.aliases.push(key)\n\n      this._infos.set(key, info)\n    }\n\n    return info\n  }\n\n  _gc (info) {\n    if (info.opened === 0 && info.outgoing.length === 0 && info.incoming.length === 0) {\n      this._infos.delete(info.key)\n\n      for (const alias of info.aliases) this._infos.delete(alias)\n    }\n  }\n\n  _ondata (buffer) {\n    if (buffer.byteLength === 0) return // ignore empty frames...\n    try {\n      const state = { buffer, start: 0, end: buffer.byteLength }\n      this._decode(c.uint.decode(state), state)\n    } catch (err) {\n      this._safeDestroy(err)\n    }\n  }\n\n  _ondrain () {\n    this.drained = true\n\n    for (const s of this._local) {\n      if (s !== null) s._track(s.ondrain(s))\n    }\n  }\n\n  _onend () { // TODO: support half open mode for the users who wants that here\n    this.stream.end()\n  }\n\n  _decode (remoteId, state) {\n    const type = c.uint.decode(state)\n\n    if (remoteId === 0) {\n      return this._oncontrolsession(type, state)\n    }\n\n    const r = remoteId <= this._remote.length ? this._remote[remoteId - 1] : null\n\n    // if the channel is closed ignore - could just be a pipeline message...\n    if (r === null) return null\n\n    if (r.pending !== null) {\n      this._bufferMessage(r, type, state)\n      return null\n    }\n\n    return r.session._recv(type, state)\n  }\n\n  _oncontrolsession (type, state) {\n    switch (type) {\n      case 0:\n        this._onbatch(state)\n        break\n\n      case 1:\n        // return the promise back up as this has sideeffects so we can batch reply\n        return this._onopensession(state)\n\n      case 2:\n        this._onrejectsession(state)\n        break\n\n      case 3:\n        this._onclosesession(state)\n        break\n    }\n\n    return null\n  }\n\n  _bufferMessage (r, type, { buffer, start, end }) {\n    const state = { buffer, start, end } // copy\n    r.pending.push({ type, state })\n    this._buffered += byteSize(state)\n    this._pauseMaybe()\n  }\n\n  _pauseMaybe () {\n    if (this._paused === true || this._buffered <= MAX_BUFFERED) return\n    this._paused = true\n    this.stream.pause()\n  }\n\n  _resumeMaybe () {\n    if (this._paused === false || this._buffered > MAX_BUFFERED) return\n    this._paused = false\n    this.stream.resume()\n  }\n\n  _onbatch (state) {\n    const end = state.end\n    let remoteId = c.uint.decode(state)\n\n    let waiting = null\n\n    while (state.end > state.start) {\n      const len = c.uint.decode(state)\n      if (len === 0) {\n        remoteId = c.uint.decode(state)\n        continue\n      }\n      state.end = state.start + len\n      // if batch contains more than one message, cork it so we reply back with a batch\n      if (end !== state.end && waiting === null) {\n        waiting = []\n        this.cork()\n      }\n      const p = this._decode(remoteId, state)\n      if (waiting !== null && p !== null) waiting.push(p)\n      state.start = state.end\n      state.end = end\n    }\n\n    if (waiting !== null) {\n      // the waiting promises are not allowed to throw but we destroy the stream in case we are wrong\n      Promise.all(waiting).then(this._uncorkBound, this._safeDestroyBound)\n    }\n  }\n\n  _onopensession (state) {\n    const remoteId = c.uint.decode(state)\n    const protocol = c.string.decode(state)\n    const id = unslab(c.buffer.decode(state))\n\n    // remote tried to open the control session - auto reject for now\n    // as we can use as an explicit control protocol declaration if we need to\n    if (remoteId === 0) {\n      this._rejectSession(0)\n      return null\n    }\n\n    const rid = remoteId - 1\n    const info = this._get(protocol, id)\n\n    // allow the remote to grow the ids by one\n    if (this._remote.length === rid) {\n      this._remote.push(null)\n    }\n\n    if (rid >= this._remote.length || this._remote[rid] !== null) {\n      throw new Error('Invalid open message')\n    }\n\n    if (info.outgoing.length > 0) {\n      const localId = info.outgoing.shift()\n      const session = this._local[localId - 1]\n\n      if (session === null) { // we already closed the channel - ignore\n        this._free.push(localId - 1)\n        return null\n      }\n\n      this._remote[rid] = { state, pending: null, session: null }\n\n      session._remoteId = remoteId\n      session._fullyOpen()\n      return null\n    }\n\n    const copyState = { buffer: state.buffer, start: state.start, end: state.end }\n    this._remote[rid] = { state: copyState, pending: [], session: null }\n\n    if (++this._remoteBacklog > MAX_BACKLOG) {\n      throw new Error('Remote exceeded backlog')\n    }\n\n    info.pairing++\n    info.incoming.push(remoteId)\n\n    return this._requestSession(protocol, id, info).catch(this._safeDestroyBound)\n  }\n\n  _onrejectsession (state) {\n    const localId = c.uint.decode(state)\n\n    // TODO: can be done smarter...\n    for (const info of this._infos.values()) {\n      const i = info.outgoing.indexOf(localId)\n      if (i === -1) continue\n\n      info.outgoing.splice(i, 1)\n\n      const session = this._local[localId - 1]\n\n      this._free.push(localId - 1)\n      if (session !== null) session._close(true)\n\n      this._gc(info)\n      return\n    }\n\n    throw new Error('Invalid reject message')\n  }\n\n  _onclosesession (state) {\n    const remoteId = c.uint.decode(state)\n\n    if (remoteId === 0) return // ignore\n\n    const rid = remoteId - 1\n    const r = rid < this._remote.length ? this._remote[rid] : null\n\n    if (r === null) return\n\n    if (r.session !== null) r.session._close(true)\n  }\n\n  async _requestSession (protocol, id, info) {\n    const notify = this._notify.get(toKey(protocol, id)) || this._notify.get(toKey(protocol, null))\n\n    if (notify) await notify(id)\n\n    if (--info.pairing > 0) return\n\n    while (info.incoming.length > 0) {\n      this._rejectSession(info, info.incoming.shift())\n    }\n\n    this._gc(info)\n  }\n\n  _rejectSession (info, remoteId) {\n    if (remoteId > 0) {\n      const r = this._remote[remoteId - 1]\n\n      if (r.pending !== null) {\n        for (let i = 0; i < r.pending.length; i++) {\n          this._buffered -= byteSize(r.pending[i].state)\n        }\n      }\n\n      this._remote[remoteId - 1] = null\n      this._resumeMaybe()\n    }\n\n    const state = { buffer: null, start: 2, end: 2 }\n\n    c.uint.preencode(state, remoteId)\n\n    state.buffer = this._alloc(state.end)\n\n    state.buffer[0] = 0\n    state.buffer[1] = 2\n    c.uint.encode(state, remoteId)\n\n    this._write0(state.buffer)\n  }\n\n  _write0 (buffer) {\n    if (this._batch !== null) {\n      this._pushBatch(0, buffer.subarray(1))\n      return\n    }\n\n    this.drained = this.stream.write(buffer)\n  }\n\n  destroy (err) {\n    this.stream.destroy(err)\n  }\n\n  _safeDestroy (err) {\n    safetyCatch(err)\n    this.stream.destroy(err)\n  }\n\n  _shutdown () {\n    for (const s of this._local) {\n      if (s !== null) s._close(true)\n    }\n  }\n}\n\nfunction noop () {}\n\nfunction toKey (protocol, id) {\n  return protocol + '##' + (id ? b4a.toString(id, 'hex') : '')\n}\n\nfunction byteSize (state) {\n  return 512 + (state.end - state.start)\n}\n\nfunction isPromise (p) {\n  return !!(p && typeof p.then === 'function')\n}\n\nfunction encodingLength (enc, val) {\n  const state = { buffer: null, start: 0, end: 0 }\n  enc.preencode(state, val)\n  return state.end\n}\n{\n  \"name\": \"protomux\",\n  \"version\": \"3.10.1\",\n  \"description\": \"Multiplex multiple message oriented protocols over a stream\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"dependencies\": {\n    \"b4a\": \"^1.3.1\",\n    \"compact-encoding\": \"^2.5.1\",\n    \"queue-tick\": \"^1.0.0\",\n    \"safety-catch\": \"^1.0.1\",\n    \"unslab\": \"^1.3.0\"\n  },\n  \"devDependencies\": {\n    \"@hyperswarm/secret-stream\": \"^6.0.0\",\n    \"brittle\": \"^3.0.0\",\n    \"standard\": \"^16.0.4\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/protomux.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/protomux/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/protomux\"\n}\n{\n  \"name\": \"queue-tick\",\n  \"version\": \"1.0.1\",\n  \"description\": \"Next tick shim that prefers process.nextTick over queueMicrotask for compat\",\n  \"main\": \"./process-next-tick.js\",\n  \"browser\": \"./queue-microtask.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"standard\": \"^16.0.3\",\n    \"tape\": \"^5.3.1\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && tape test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/queue-tick.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/queue-tick/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/queue-tick\"\n}\nmodule.exports = (typeof process !== 'undefined' && typeof process.nextTick === 'function')\n  ? process.nextTick.bind(process)\n  : require('./queue-microtask')\nmodule.exports = typeof queueMicrotask === 'function' ? queueMicrotask : (fn) => Promise.resolve().then(fn)\nconst b4a = require('b4a')\n\nvar EMPTY = []\n\nmodule.exports = RecordCache\n\nfunction RecordSet () {\n  this.list = []\n  this.map = new Map()\n}\n\nRecordSet.prototype.add = function (record, value) {\n  var k = toString(record)\n  var r = this.map.get(k)\n  if (r) return false\n\n  r = {index: this.list.length, record: value || record}\n  this.list.push(r)\n  this.map.set(k, r)\n  return true\n}\n\nRecordSet.prototype.remove = function (record) {\n  var k = toString(record)\n  var r = this.map.get(k)\n  if (!r) return false\n\n  swap(this.list, r.index, this.list.length - 1)\n  this.list.pop()\n  this.map.delete(k)\n  return true\n}\n\nfunction RecordStore () {\n  this.records = new Map()\n  this.size = 0\n}\n\nRecordStore.prototype.add = function (name, record, value) {\n  var r = this.records.get(name)\n\n  if (!r) {\n    r = new RecordSet()\n    this.records.set(name, r)\n  }\n\n  if (r.add(record, value)) {\n    this.size++\n    return true\n  }\n\n  return false\n}\n\nRecordStore.prototype.remove = function (name, record, value) {\n  var r = this.records.get(name)\n  if (!r) return false\n\n  if (r.remove(record, value)) {\n    this.size--\n    if (!r.map.size) this.records.delete(name)\n    return true\n  }\n\n  return false\n}\n\nRecordStore.prototype.get = function (name) {\n  var r = this.records.get(name)\n  return r ? r.list : EMPTY\n}\n\nfunction RecordCache (opts) {\n  if (!(this instanceof RecordCache)) return new RecordCache(opts)\n  if (!opts) opts = {}\n\n  this.maxSize = opts.maxSize || Infinity\n  this.maxAge = opts.maxAge || 0\n\n  this._onstale = opts.onStale || opts.onstale || null\n  this._fresh = new RecordStore()\n  this._stale = new RecordStore()\n  this._interval = null\n  this._gced = false\n\n  if (this.maxAge && this.maxAge < Infinity) {\n    // 2/3 gives us a span of 0.66-1.33 maxAge or avg maxAge\n    var tick = Math.ceil(2 / 3 * this.maxAge)\n    this._interval = setInterval(this._gcAuto.bind(this), tick)\n    if (this._interval.unref) this._interval.unref()\n  }\n}\n\nObject.defineProperty(RecordCache.prototype, 'size', {\n  get: function () {\n    return this._fresh.size + this._stale.size\n  }\n})\n\nRecordCache.prototype.add = function (name, record, value) {\n  this._stale.remove(name, record, value)\n  if (this._fresh.add(name, record, value) && this._fresh.size > this.maxSize) {\n    this._gc()\n  }\n}\n\nRecordCache.prototype.remove = function (name, record, value) {\n  this._fresh.remove(name, record, value)\n  this._stale.remove(name, record, value)\n}\n\nRecordCache.prototype.get = function (name, n) {\n  var a = this._fresh.get(name)\n  var b = this._stale.get(name)\n  var aLen = a.length\n  var bLen = b.length\n  var len = aLen + bLen\n\n  if (n > len || !n) n = len\n  var result = new Array(n)\n\n  for (var i = 0; i < n; i++) {\n    var j = Math.floor(Math.random() * (aLen + bLen))\n    if (j < aLen) {\n      result[i] = a[j].record\n      swap(a, j, --aLen)\n    } else {\n      j -= aLen\n      result[i] = b[j].record\n      swap(b, j, --bLen)\n    }\n  }\n\n  return result\n}\n\nRecordCache.prototype._gcAuto = function () {\n  if (!this._gced) this._gc()\n  this._gced = false\n}\n\nRecordCache.prototype._gc = function () {\n  if (this._onstale && this._stale.size > 0) this._onstale(this._stale)\n  this._stale = this._fresh\n  this._fresh = new RecordStore()\n  this._gced = true\n}\n\nRecordCache.prototype.clear = function () {\n  this._gc()\n  this._gc()\n}\n\nRecordCache.prototype.destroy = function () {\n  this.clear()\n  clearInterval(this._interval)\n  this._interval = null\n}\n\nfunction toString (record) {\n  return b4a.isBuffer(record) ? b4a.toString(record, 'hex') : record\n}\n\nfunction swap (list, a, b) {\n  var tmp = list[a]\n  tmp.index = b\n  list[b].index = a\n  list[a] = list[b]\n  list[b] = tmp\n}\n{\n  \"name\": \"record-cache\",\n  \"version\": \"1.2.0\",\n  \"description\": \"Cache optimised for record like things\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"b4a\": \"^1.3.1\"\n  },\n  \"devDependencies\": {\n    \"standard\": \"^10.0.3\",\n    \"tape\": \"^4.8.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && tape test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/record-cache.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/record-cache/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/record-cache\"\n}\nmodule.exports = require.addon.bind(require)\n{\n  \"name\": \"require-addon\",\n  \"version\": \"1.2.0\",\n  \"description\": \"Import native addons across JavaScript runtimes\",\n  \"exports\": {\n    \"./package\": \"./package.json\",\n    \".\": {\n      \"bare\": \"./lib/bare.js\",\n      \"node\": \"./lib/node.js\",\n      \"default\": \"./lib/default.js\"\n    }\n  },\n  \"imports\": {\n    \"fs\": {\n      \"bare\": \"bare-fs\",\n      \"default\": \"fs\"\n    },\n    \"path\": {\n      \"bare\": \"bare-path\",\n      \"default\": \"path\"\n    },\n    \"url\": {\n      \"bare\": \"bare-url\",\n      \"default\": \"url\"\n    }\n  },\n  \"files\": [\n    \"lib\"\n  ],\n  \"scripts\": {\n    \"test\": \"npm run lint && npm run test:bare && npm run test:node\",\n    \"test:bare\": \"bare test.js\",\n    \"test:node\": \"node test.js\",\n    \"lint\": \"prettier --check .\",\n    \"format\": \"prettier --write .\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/require-addon.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/require-addon/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/require-addon#readme\",\n  \"engines\": {\n    \"bare\": \">=1.10.0\"\n  },\n  \"dependencies\": {\n    \"bare-addon-resolve\": \"^1.3.0\"\n  },\n  \"devDependencies\": {\n    \"bare-bundle\": \"^1.8.1\",\n    \"bare-bundle-evaluate\": \"^1.1.0\",\n    \"bare-fs\": \"^4.0.0\",\n    \"bare-path\": \"^3.0.0\",\n    \"bare-url\": \"^2.1.0\",\n    \"brittle\": \"^3.7.0\",\n    \"prettier\": \"^3.6.2\",\n    \"prettier-config-holepunch\": \"^2.0.0\"\n  }\n}\nmodule.exports = safetyCatch\n\nfunction isActuallyUncaught (err) {\n  if (!err) return false\n  return err instanceof TypeError ||\n    err instanceof SyntaxError ||\n    err instanceof ReferenceError ||\n    err instanceof EvalError ||\n    err instanceof RangeError ||\n    err instanceof URIError ||\n    err.code === 'ERR_ASSERTION'\n}\n\nfunction throwErrorNT (err) {\n  queueMicrotask(() => { throw err })\n}\n\nfunction safetyCatch (err) {\n  if (isActuallyUncaught(err)) {\n    throwErrorNT(err)\n    throw err\n  }\n}\n{\n  \"name\": \"safety-catch\",\n  \"version\": \"1.0.2\",\n  \"description\": \"Small module that makes sure your catch, caught an actual error and not a programming mistake or assertion\",\n  \"main\": \"index.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/safety-catch.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/safety-catch/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/safety-catch\"\n}\nconst set = require('unordered-set')\n\nmodule.exports = opts => new ShuffledPriorityQueue(opts)\n\nclass ShuffledPriorityQueue {\n  constructor (opts) {\n    this.priorities = []\n    this.equals = (opts && opts.equals) || null\n  }\n\n  get length () {\n    return this.priorities.reduce(add, 0)\n  }\n\n  [Symbol.iterator] () {\n    return new Iterator(this)\n  }\n\n  head () {\n    for (let i = this.priorities.length - 1; i >= 0; i--) {\n      const q = this.priorities[i]\n      if (q.length) return shuffle(q, 0)\n    }\n    return null\n  }\n\n  tail () {\n    for (let i = 0; i < this.priorities.length; i++) {\n      const q = this.priorities[i]\n      if (q.length) return shuffle(q, 0)\n    }\n    return null\n  }\n\n  prev (prev) {\n    if (!prev) return this.tail()\n    return next(this.priorities, prev, 1)\n  }\n\n  next (prev) {\n    if (!prev) return this.head()\n    return next(this.priorities, prev, -1)\n  }\n\n  shift () {\n    return this.remove(this.head())\n  }\n\n  pop () {\n    return this.remove(this.tail())\n  }\n\n  add (val) {\n    const prio = val.priority || 0\n    while (prio >= this.priorities.length) this.priorities.push([])\n    set.add(this.priorities[prio], val)\n    return val\n  }\n\n  remove (val) {\n    if (!val) return null\n\n    if (val._index === undefined) {\n      val = this.find(val)\n      if (!val) return null\n    }\n\n    return set.remove(this.priorities[val.priority || 0], val)\n  }\n\n  has (val) {\n    if (val._index === undefined) return this.find(val)\n    const priority = val.priority || 0\n    if (priority >= this.priorities.length) return false\n    return set.has(this.priorities[priority], val)\n  }\n\n  find (val) {\n    if (val._index !== undefined) return val\n\n    const prio = val.priority || 0\n    const qs = this.priorities\n    if (prio >= qs.length) return null\n\n    const q = qs[prio]\n\n    for (let i = 0; i < q.length; i++) {\n      if (this.equals(q[i], val)) return q[i]\n    }\n\n    return null\n  }\n}\n\nclass Iterator {\n  constructor (queue) {\n    this.prev = null\n    this.queue = queue\n  }\n\n  next () {\n    const next = this.queue.next(this.prev)\n    this.prev = next\n    return { done: !next, value: next }\n  }\n}\n\nfunction shuffle (q, i) {\n  const ran = i + Math.floor(Math.random() * (q.length - i))\n  set.swap(q, q[ran], q[i])\n  return q[i]\n}\n\nfunction next (queues, prev, inc) {\n  let i = prev.priority || 0\n  let j = (prev._index || 0) + 1\n\n  while (true) {\n    if (i < 0 || i >= queues.length) return null\n    const q = queues[i]\n\n    if (j >= q.length) {\n      i += inc\n      j = 0\n      continue\n    }\n\n    return shuffle(q, j)\n  }\n}\n\nfunction add (len, b) {\n  return len + b.length\n}\n{\n  \"name\": \"shuffled-priority-queue\",\n  \"version\": \"2.1.0\",\n  \"description\": \"A priority queue that shuffles elements with the same priority.\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"standard && tape test.js\"\n  },\n  \"dependencies\": {\n    \"unordered-set\": \"^2.0.1\"\n  },\n  \"devDependencies\": {\n    \"standard\": \"^12.0.1\",\n    \"tape\": \"^4.9.1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/shuffled-priority-queue.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/shuffled-priority-queue/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/shuffled-priority-queue\"\n}\nmodule.exports = class Signal {\n  constructor () {\n    this._resolve = null\n    this._reject = null\n    this._promise = null\n    this._bind = bind.bind(this)\n    this._onerror = clear.bind(this)\n    this._onsuccess = clear.bind(this, null)\n    this._timers = new Set()\n  }\n\n  wait (max) {\n    if (!this._promise) {\n      this._promise = new Promise(this._bind)\n      this._promise.then(this._onsuccess).catch(this._onerror)\n    }\n    if (max) return this._sleep(max)\n    return this._promise\n  }\n\n  _sleep (max) {\n    const s = new Promise((resolve, reject) => {\n      const done = () => {\n        this._timers.delete(state)\n        resolve(true)\n      }\n      const id = setTimeout(done, max)\n      const state = { id, resolve, reject }\n      this._timers.add(state)\n    })\n\n    return s\n  }\n\n  notify (err) {\n    if (!this._promise) return\n    const resolve = this._resolve\n    const reject = this._reject\n    this._promise = null\n    if (err) reject(err)\n    else resolve(true)\n  }\n}\n\nfunction clear (err) {\n  for (const { id, resolve, reject } of this._timers) {\n    clearTimeout(id)\n    if (err) reject(err)\n    else resolve(true)\n  }\n  this._timers.clear()\n}\n\nfunction bind (resolve, reject) {\n  this._resolve = resolve\n  this._reject = reject\n}\n{\n  \"name\": \"signal-promise\",\n  \"version\": \"1.0.3\",\n  \"description\": \"Simple wait/notify promise with optional max wait time\",\n  \"main\": \"index.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/signal-promise.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/signal-promise/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/signal-promise\"\n}\nrequire.addon = require('require-addon')\nmodule.exports = require.addon('.', __filename)\nconst binding = require('./binding')\nconst { isNode } = require('which-runtime')\n\nconst OPTIONAL = Buffer.from(new ArrayBuffer(0))\n\nmodule.exports = exports = { ...binding }\n\n// memory\n\nexports.sodium_memzero = function (buf) {\n  binding.sodium_memzero(buf)\n}\n\nexports.sodium_mlock = function (buf) {\n  const res = binding.sodium_mlock(buf)\n  if (res !== 0) throw new Error('memory lock failed')\n}\n\nexports.sodium_munlock = function (buf) {\n  const res = binding.sodium_munlock(buf)\n  if (res !== 0) throw new Error('memory unlock failed')\n}\n\nexports.sodium_malloc = function (size) {\n  if (size < 0) throw new Error('invalid size')\n  const buf = Buffer.from(binding.sodium_malloc(size))\n  buf.secure = true\n\n  return buf\n}\n\nexports.sodium_free = function (buf) {\n  if (!buf?.secure) return\n\n  binding.sodium_free(buf.buffer)\n}\n\nexports.sodium_mprotect_noaccess = function (buf) {\n  const res = binding.sodium_mprotect_noaccess(buf.buffer)\n\n  if (res !== 0) throw new Error('failed to lock buffer')\n}\n\nexports.sodium_mprotect_readonly = function (buf) {\n  const res = binding.sodium_mprotect_readonly(buf.buffer)\n\n  if (res !== 0) throw new Error('failed to unlock buffer')\n}\n\nexports.sodium_mprotect_readwrite = function (buf) {\n  const res = binding.sodium_mprotect_readwrite(buf.buffer)\n\n  if (res !== 0) throw new Error('failed to unlock buffer')\n}\n\n// crypto_randombytes\n\nexports.randombytes_buf = function (buffer) {\n  binding.randombytes_buf(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n}\n\nexports.randombytes_buf_deterministic = function (buffer, seed) {\n  binding.randombytes_buf_deterministic(\n    buffer.buffer,\n    buffer.byteOffset,\n    buffer.byteLength,\n\n    seed.buffer,\n    seed.byteOffset,\n    seed.byteLength\n  )\n}\n\n// sodium_helpers\n\nexports.sodium_memcmp = function (a, b) {\n  if (a?.byteLength !== b?.byteLength)\n    throw new Error('buffers must be of same length\"')\n  return binding.sodium_memcmp(a, b)\n}\n\nexports.sodium_add = function (a, b) {\n  if (a?.byteLength !== b?.byteLength)\n    throw new Error('buffers must be of same length\"')\n  binding.sodium_add(a, b)\n}\n\nexports.sodium_sub = function (a, b) {\n  if (a?.byteLength !== b?.byteLength)\n    throw new Error('buffers must be of same length\"')\n  binding.sodium_sub(a, b)\n}\n\nexports.sodium_compare = function (a, b) {\n  if (a?.byteLength !== b?.byteLength)\n    throw new Error('buffers must be of same length\"')\n  return binding.sodium_compare(a, b)\n}\n\nexports.sodium_is_zero = function (buffer, length) {\n  if (!buffer) throw new Error('invalid buffer')\n  length ??= buffer.byteLength\n  if (length > buffer.byteLength || length < 0)\n    throw new Error('invalid length')\n\n  return binding.sodium_is_zero(buffer, length)\n}\n\nexports.sodium_pad = function (buffer, unpaddedBuflen, blockSize) {\n  if (unpaddedBuflen > buffer.byteLength)\n    throw new Error('unpadded length cannot exceed buffer length')\n  if (blockSize > buffer.byteLength)\n    throw new Error('block size cannot exceed buffer length')\n  if (blockSize < 1) throw new Error('block sizemust be at least 1 byte')\n  if (\n    buffer?.byteLength <\n    unpaddedBuflen + (blockSize - (unpaddedBuflen % blockSize))\n  )\n    throw new Error('buf not long enough')\n\n  return binding.sodium_pad(buffer, unpaddedBuflen, blockSize)\n}\n\nexports.sodium_unpad = function (buffer, paddedBuflen, blockSize) {\n  if (paddedBuflen > buffer.byteLength)\n    throw new Error('unpadded length cannot exceed buffer length')\n  if (blockSize > buffer.byteLength)\n    throw new Error('block size cannot exceed buffer length')\n  if (blockSize < 1) throw new Error('block size must be at least 1 byte')\n\n  return binding.sodium_unpad(buffer, paddedBuflen, blockSize)\n}\n\n// crypto_sign\n\nexports.crypto_sign_keypair = function (pk, sk) {\n  if (pk?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)\n    throw new Error('pk')\n\n  const res = binding.crypto_sign_keypair(pk, sk)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_sign_seed_keypair = function (pk, sk, seed) {\n  if (pk?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)\n    throw new Error('pk')\n\n  const res = binding.crypto_sign_seed_keypair(pk, sk, seed)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_sign = function (sm, m, sk) {\n  if (sm?.byteLength !== binding.crypto_sign_BYTES + m.byteLength)\n    throw new Error('sm must be \"m.byteLength + crypto_sign_BYTES\" bytes')\n  if (sk?.byteLength !== binding.crypto_sign_SECRETKEYBYTES)\n    throw new Error('sk')\n\n  const res = binding.crypto_sign(sm, m, sk)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_sign_open = function (m, sm, pk) {\n  if (sm?.byteLength < binding.crypto_sign_BYTES) throw new Error('sm')\n  if (m?.byteLength !== sm.byteLength - binding.crypto_sign_BYTES)\n    throw new Error('m must be \"sm.byteLength - crypto_sign_BYTES\" bytes')\n  if (pk?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)\n    throw new Error('pk')\n\n  const res = binding.crypto_sign_open(m, sm, pk)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_sign_open = function (m, sm, pk) {\n  if (sm?.byteLength < binding.crypto_sign_BYTES) throw new Error('sm')\n  if (m?.byteLength !== sm.byteLength - binding.crypto_sign_BYTES)\n    throw new Error('m must be \"sm.byteLength - crypto_sign_BYTES\" bytes')\n  if (pk?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)\n    throw new Error('pk')\n\n  return binding.crypto_sign_open(m, sm, pk)\n}\n\nexports.crypto_sign_detached = function (sig, m, sk) {\n  if (sig?.byteLength !== binding.crypto_sign_BYTES) throw new Error('sig')\n  if (sk?.byteLength !== binding.crypto_sign_SECRETKEYBYTES)\n    throw new Error('sk')\n\n  const res = binding.crypto_sign_detached(sig, m, sk)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_sign_verify_detached = function (sig, m, pk) {\n  return binding.crypto_sign_verify_detached(\n    sig.buffer,\n    sig.byteOffset,\n    sig.byteLength,\n\n    m.buffer,\n    m.byteOffset,\n    m.byteLength,\n\n    pk.buffer,\n    pk.byteOffset,\n    pk.byteLength\n  )\n}\n\nexports.crypto_sign_ed25519_sk_to_pk = function (pk, sk) {\n  if (pk?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)\n    throw new Error('pk')\n  if (sk?.byteLength !== binding.crypto_sign_SECRETKEYBYTES)\n    throw new Error('sk')\n\n  const res = binding.crypto_sign_ed25519_sk_to_pk(pk, sk)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_sign_ed25519_pk_to_curve25519 = function (x25519pk, ed25519pk) {\n  if (x25519pk?.byteLength !== binding.crypto_box_PUBLICKEYBYTES)\n    throw new Error('x25519_pk')\n  if (ed25519pk?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)\n    throw new Error('ed25519_pk')\n\n  const res = binding.crypto_sign_ed25519_pk_to_curve25519(x25519pk, ed25519pk)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_sign_ed25519_sk_to_curve25519 = function (x25519sk, ed25519sk) {\n  if (x25519sk?.byteLength !== binding.crypto_box_SECRETKEYBYTES)\n    throw new Error('x25519_sk')\n\n  const edLen = ed25519sk.byteLength\n\n  if (\n    edLen !== binding.crypto_sign_SECRETKEYBYTES &&\n    edLen !== binding.crypto_box_SECRETKEYBYTES\n  ) {\n    throw new Error(\n      \"ed25519_sk should either be 'crypto_sign_SECRETKEYBYTES' bytes or 'crypto_sign_SECRETKEYBYTES - crypto_sign_PUBLICKEYBYTES' bytes\"\n    )\n  }\n\n  const res = binding.crypto_sign_ed25519_sk_to_curve25519(x25519sk, ed25519sk)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\n// crypto_box\n\nexports.crypto_box_keypair = function (pk, sk) {\n  if (pk?.byteLength !== binding.crypto_box_PUBLICKEYBYTES)\n    throw new Error('pk')\n  if (sk?.byteLength !== binding.crypto_box_SECRETKEYBYTES)\n    throw new Error('sk')\n\n  const res = binding.crypto_box_keypair(pk, sk)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_box_seed_keypair = function (pk, sk, seed) {\n  if (pk?.byteLength !== binding.crypto_box_PUBLICKEYBYTES)\n    throw new Error('pk')\n  if (sk?.byteLength !== binding.crypto_box_SECRETKEYBYTES)\n    throw new Error('sk')\n\n  const res = binding.crypto_box_seed_keypair(pk, sk, seed)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_box_easy = function (c, m, n, pk, sk) {\n  const res = binding.crypto_box_easy(c, m, n, pk, sk)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_box_detached = function (c, mac, m, n, pk, sk) {\n  const res = binding.crypto_box_detached(c, mac, m, n, pk, sk)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_box_seal = function (c, m, pk) {\n  const res = binding.crypto_box_seal(c, m, pk)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_box_seal_open = function (m, c, pk, sk) {\n  return binding.crypto_box_seal_open(\n    m.buffer,\n    m.byteOffset,\n    m.byteLength,\n\n    c.buffer,\n    c.byteOffset,\n    c.byteLength,\n\n    pk.buffer,\n    pk.byteOffset,\n    pk.byteLength,\n\n    sk.buffer,\n    sk.byteOffset,\n    sk.byteLength\n  )\n}\n\n// crypto_secretbox\n\nexports.crypto_secretbox_easy = function (c, m, n, k) {\n  if (c?.byteLength !== m.byteLength + binding.crypto_secretbox_MACBYTES)\n    throw new Error(\n      'c must be \"m.byteLength + crypto_secretbox_MACBYTES\" bytes'\n    )\n  if (n?.byteLength !== binding.crypto_secretbox_NONCEBYTES)\n    throw new Error('n')\n  if (k?.byteLength !== binding.crypto_secretbox_KEYBYTES) throw new Error('k')\n\n  const res = binding.crypto_secretbox_easy(c, m, n, k)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_secretbox_open_easy = function (m, c, n, k) {\n  if (m?.byteLength !== c.byteLength - binding.crypto_secretbox_MACBYTES)\n    throw new Error('m must be \"c - crypto_secretbox_MACBYTES\" bytes')\n  if (c?.byteLength < binding.crypto_secretbox_MACBYTES) throw new Error('c')\n  if (n?.byteLength !== binding.crypto_secretbox_NONCEBYTES)\n    throw new Error('n')\n  if (k?.byteLength !== binding.crypto_secretbox_KEYBYTES) throw new Error('k')\n\n  return binding.crypto_secretbox_open_easy(m, c, n, k)\n}\n\nexports.crypto_secretbox_detached = function (c, mac, m, n, k) {\n  if (c?.byteLength !== m.byteLength)\n    throw new Error('c must \"m.byteLength\" bytes')\n  if (mac?.byteLength !== binding.crypto_secretbox_MACBYTES)\n    throw new Error('mac')\n  if (n?.byteLength !== binding.crypto_secretbox_NONCEBYTES)\n    throw new Error('n')\n  if (k?.byteLength !== binding.crypto_secretbox_KEYBYTES) throw new Error('k')\n\n  const res = binding.crypto_secretbox_detached(c, mac, m, n, k)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_secretbox_open_detached = function (m, c, mac, n, k) {\n  if (m?.byteLength !== c.byteLength)\n    throw new Error('m must be \"c.byteLength\" bytes')\n  if (mac?.byteLength !== binding.crypto_secretbox_MACBYTES)\n    throw new Error('mac')\n  if (n?.byteLength !== binding.crypto_secretbox_NONCEBYTES)\n    throw new Error('n')\n  if (k?.byteLength !== binding.crypto_secretbox_KEYBYTES) throw new Error('k')\n\n  return binding.crypto_secretbox_open_detached(m, c, mac, n, k)\n}\n\n// crypto_generichash\n\nexports.crypto_generichash = function (output, input, key = OPTIONAL) {\n  const res = binding.crypto_generichash(\n    output.buffer,\n    output.byteOffset,\n    output.byteLength,\n\n    input.buffer,\n    input.byteOffset,\n    input.byteLength,\n\n    key.buffer,\n    key.byteOffset,\n    key.byteLength\n  )\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_generichash_batch = function (output, batch, key) {\n  if (isNode || batch.length < 4) {\n    const res = binding.crypto_generichash_batch(\n      output,\n      batch,\n      !!key,\n      key || OPTIONAL\n    )\n    if (res !== 0) throw new Error('status: ' + res)\n  } else {\n    const state = Buffer.alloc(binding.crypto_generichash_STATEBYTES)\n\n    exports.crypto_generichash_init(state, key, output.byteLength)\n\n    for (const buf of batch) {\n      exports.crypto_generichash_update(state, buf)\n    }\n\n    exports.crypto_generichash_final(state, output)\n  }\n}\n\nexports.crypto_generichash_keygen = function (key) {\n  const res = binding.crypto_generichash_keygen(\n    key.buffer,\n    key.byteOffset,\n    key.byteLength\n  )\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_generichash_init = function (state, key, outputLength) {\n  key ||= OPTIONAL\n\n  const res = binding.crypto_generichash_init(\n    state.buffer,\n    state.byteOffset,\n    state.byteLength,\n\n    key.buffer,\n    key.byteOffset,\n    key.byteLength,\n\n    outputLength\n  )\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_generichash_update = function (state, input) {\n  const res = binding.crypto_generichash_update(\n    state.buffer,\n    state.byteOffset,\n    state.byteLength,\n\n    input.buffer,\n    input.byteOffset,\n    input.byteLength\n  )\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_generichash_final = function (state, output) {\n  const res = binding.crypto_generichash_final(\n    state.buffer,\n    state.byteOffset,\n    state.byteLength,\n\n    output.buffer,\n    output.byteOffset,\n    output.byteLength\n  )\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\n// secretstream\n\nexports.crypto_secretstream_xchacha20poly1305_keygen = function (k) {\n  binding.crypto_secretstream_xchacha20poly1305_keygen(\n    k.buffer,\n    k.byteOffset,\n    k.byteLength\n  )\n}\n\nexports.crypto_secretstream_xchacha20poly1305_init_push = function (\n  state,\n  header,\n  k\n) {\n  const res = binding.crypto_secretstream_xchacha20poly1305_init_push(\n    state.buffer,\n    state.byteOffset,\n    state.byteLength,\n\n    header.buffer,\n    header.byteOffset,\n    header.byteLength,\n\n    k.buffer,\n    k.byteOffset,\n    k.byteLength\n  )\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_secretstream_xchacha20poly1305_init_pull = function (\n  state,\n  header,\n  k\n) {\n  const res = binding.crypto_secretstream_xchacha20poly1305_init_pull(\n    state.buffer,\n    state.byteOffset,\n    state.byteLength,\n\n    header.buffer,\n    header.byteOffset,\n    header.byteLength,\n\n    k.buffer,\n    k.byteOffset,\n    k.byteLength\n  )\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_secretstream_xchacha20poly1305_push = function (\n  state,\n  c,\n  m,\n  ad,\n  tag\n) {\n  ad ||= OPTIONAL\n\n  const res = binding.crypto_secretstream_xchacha20poly1305_push(\n    state.buffer,\n    state.byteOffset,\n    state.byteLength,\n\n    c.buffer,\n    c.byteOffset,\n    c.byteLength,\n\n    m.buffer,\n    m.byteOffset,\n    m.byteLength,\n\n    ad.buffer,\n    ad.byteOffset,\n    ad.byteLength,\n\n    tag\n  )\n\n  if (res < 0) throw new Error('push failed')\n\n  return res\n}\n\nexports.crypto_secretstream_xchacha20poly1305_pull = function (\n  state,\n  m,\n  tag,\n  c,\n  ad\n) {\n  ad ||= OPTIONAL\n\n  if (c?.byteLength < binding.crypto_secretstream_xchacha20poly1305_ABYTES)\n    throw new Error('invalid cipher length')\n  if (\n    m?.byteLength !==\n    c.byteLength - binding.crypto_secretstream_xchacha20poly1305_ABYTES\n  )\n    throw new Error('invalid message length')\n\n  const res = binding.crypto_secretstream_xchacha20poly1305_pull(\n    state.buffer,\n    state.byteOffset,\n    state.byteLength,\n\n    m.buffer,\n    m.byteOffset,\n    m.byteLength,\n\n    tag.buffer,\n    tag.byteOffset,\n    tag.byteLength,\n\n    c.buffer,\n    c.byteOffset,\n    c.byteLength,\n\n    ad.buffer,\n    ad.byteOffset,\n    ad.byteLength\n  )\n\n  if (res < 0) throw new Error('pull failed')\n\n  return res\n}\n\nexports.crypto_secretstream_xchacha20poly1305_rekey = function (state) {\n  binding.crypto_secretstream_xchacha20poly1305_rekey(\n    state.buffer,\n    state.byteOffset,\n    state.byteLength\n  )\n}\n\n// crypto_stream\n\nexports.crypto_stream = function (c, n, k) {\n  if (n?.byteLength !== binding.crypto_stream_NONCEBYTES) throw new Error('n')\n  if (k?.byteLength !== binding.crypto_stream_KEYBYTES) throw new Error('k')\n\n  const res = binding.crypto_stream(c, n, k)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_stream_xor = function (c, m, n, k) {\n  const res = binding.crypto_stream_xor(\n    c.buffer,\n    c.byteOffset,\n    c.byteLength,\n\n    m.buffer,\n    m.byteOffset,\n    m.byteLength,\n\n    n.buffer,\n    n.byteOffset,\n    n.byteLength,\n\n    k.buffer,\n    k.byteOffset,\n    k.byteLength\n  )\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_stream_chacha20 = function (c, n, k) {\n  if (n?.byteLength !== binding.crypto_stream_chacha20_NONCEBYTES)\n    throw new Error('n')\n  if (k?.byteLength !== binding.crypto_stream_chacha20_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_stream_chacha20(c, n, k)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_stream_chacha20_xor = function (c, m, n, k) {\n  if (c?.byteLength !== m.byteLength)\n    throw new Error('m must be \"c.byteLength\" bytes')\n  if (n?.byteLength !== binding.crypto_stream_chacha20_NONCEBYTES)\n    throw new Error('n')\n  if (k?.byteLength !== binding.crypto_stream_chacha20_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_stream_chacha20_xor(c, m, n, k)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_stream_chacha20_xor_ic = function (c, m, n, ic, k) {\n  if (c?.byteLength !== m.byteLength)\n    throw new Error('m must be \"c.byteLength\" bytes')\n  if (n?.byteLength !== binding.crypto_stream_chacha20_NONCEBYTES)\n    throw new Error('n')\n  if (k?.byteLength !== binding.crypto_stream_chacha20_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_stream_chacha20_xor_ic(c, m, n, ic, k)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_stream_chacha20_ietf = function (c, n, k) {\n  if (n?.byteLength !== binding.crypto_stream_chacha20_ietf_NONCEBYTES)\n    throw new Error('n')\n  if (k?.byteLength !== binding.crypto_stream_chacha20_ietf_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_stream_chacha20_ietf(c, n, k)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_stream_chacha20_ietf_xor = function (c, m, n, k) {\n  if (c?.byteLength !== m.byteLength)\n    throw new Error('m must be \"c.byteLength\" bytes')\n  if (n?.byteLength !== binding.crypto_stream_chacha20_ietf_NONCEBYTES)\n    throw new Error('n')\n  if (k?.byteLength !== binding.crypto_stream_chacha20_ietf_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_stream_chacha20_ietf_xor(c, m, n, k)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_stream_chacha20_ietf_xor_ic = function (c, m, n, ic, k) {\n  if (c?.byteLength !== m.byteLength)\n    throw new Error('m must be \"c.byteLength\" bytes')\n  if (n?.byteLength !== binding.crypto_stream_chacha20_ietf_NONCEBYTES)\n    throw new Error('n')\n  if (k?.byteLength !== binding.crypto_stream_chacha20_ietf_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_stream_chacha20_ietf_xor_ic(c, m, n, ic, k)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_stream_xchacha20 = function (c, n, k) {\n  if (n?.byteLength !== binding.crypto_stream_xchacha20_NONCEBYTES)\n    throw new Error('n')\n  if (k?.byteLength !== binding.crypto_stream_xchacha20_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_stream_xchacha20(c, n, k)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_stream_xchacha20_xor = function (c, m, n, k) {\n  if (c?.byteLength !== m.byteLength)\n    throw new Error('m must be \"c.byteLength\" bytes')\n  if (n?.byteLength !== binding.crypto_stream_xchacha20_NONCEBYTES)\n    throw new Error('n')\n  if (k?.byteLength !== binding.crypto_stream_xchacha20_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_stream_xchacha20_xor(c, m, n, k)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_stream_xchacha20_xor_ic = function (c, m, n, ic, k) {\n  if (c?.byteLength !== m.byteLength)\n    throw new Error('m must be \"c.byteLength\" bytes')\n  if (n?.byteLength !== binding.crypto_stream_xchacha20_NONCEBYTES)\n    throw new Error('n')\n  if (k?.byteLength !== binding.crypto_stream_xchacha20_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_stream_xchacha20_xor_ic(c, m, n, ic, k)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_stream_salsa20 = function (c, n, k) {\n  if (n?.byteLength !== binding.crypto_stream_salsa20_NONCEBYTES)\n    throw new Error('n')\n  if (k?.byteLength !== binding.crypto_stream_salsa20_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_stream_salsa20(c, n, k)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_stream_salsa20_xor = function (c, m, n, k) {\n  if (c?.byteLength !== m.byteLength)\n    throw new Error('m must be \"c.byteLength\" bytes')\n  if (n?.byteLength !== binding.crypto_stream_salsa20_NONCEBYTES)\n    throw new Error('n')\n  if (k?.byteLength !== binding.crypto_stream_salsa20_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_stream_salsa20_xor(c, m, n, k)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_stream_salsa20_xor_ic = function (c, m, n, ic, k) {\n  if (c?.byteLength !== m.byteLength)\n    throw new Error('m must be \"c.byteLength\" bytes')\n  if (n?.byteLength !== binding.crypto_stream_salsa20_NONCEBYTES)\n    throw new Error('n')\n  if (k?.byteLength !== binding.crypto_stream_salsa20_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_stream_salsa20_xor_ic(c, m, n, ic, k)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\n// crypto_auth\n\nexports.crypto_auth = function (out, input, k) {\n  if (out?.byteLength !== binding.crypto_auth_BYTES) throw new Error('out')\n  if (k?.byteLength !== binding.crypto_auth_KEYBYTES) throw new Error('k')\n\n  const res = binding.crypto_auth(out, input, k)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_auth_verify = function (h, input, k) {\n  if (h?.byteLength !== binding.crypto_auth_BYTES) throw new Error('h')\n  if (k?.byteLength !== binding.crypto_auth_KEYBYTES) throw new Error('k')\n\n  return binding.crypto_auth_verify(h, input, k)\n}\n\n// crypto_onetimeauth\n\nexports.crypto_onetimeauth = function (out, input, k) {\n  if (out?.byteLength !== binding.crypto_onetimeauth_BYTES)\n    throw new Error('out')\n  if (k?.byteLength !== binding.crypto_onetimeauth_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_onetimeauth(out, input, k)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_onetimeauth_init = function (state, k) {\n  if (state?.byteLength !== binding.crypto_onetimeauth_STATEBYTES)\n    throw new Error(\"state must be 'crypto_onetimeauth_STATEBYTES' bytes\")\n  if (k?.byteLength !== binding.crypto_onetimeauth_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_onetimeauth_init(state, k)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_onetimeauth_update = function (state, input) {\n  if (state?.byteLength !== binding.crypto_onetimeauth_STATEBYTES)\n    throw new Error(\"state must be 'crypto_onetimeauth_STATEBYTES' bytes\")\n\n  const res = binding.crypto_onetimeauth_update(state, input)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_onetimeauth_final = function (state, out) {\n  if (state?.byteLength !== binding.crypto_onetimeauth_STATEBYTES)\n    throw new Error(\"state must be 'crypto_onetimeauth_STATEBYTES' bytes\")\n  if (out?.byteLength !== binding.crypto_onetimeauth_BYTES)\n    throw new Error('out')\n\n  const res = binding.crypto_onetimeauth_final(state, out)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_onetimeauth_verify = function (h, input, k) {\n  if (h?.byteLength !== binding.crypto_onetimeauth_BYTES) throw new Error('h')\n  if (k?.byteLength !== binding.crypto_onetimeauth_KEYBYTES)\n    throw new Error('k')\n\n  return binding.crypto_onetimeauth_verify(h, input, k)\n}\n\n// crypto_pwhash\n\nexports.crypto_pwhash = function (out, passwd, salt, opslimit, memlimit, alg) {\n  if (out?.byteLength < binding.crypto_pwhash_BYTES_MIN) throw new Error('out')\n  if (out?.byteLength > binding.crypto_pwhash_BYTES_MAX) throw new Error('out')\n  if (salt?.byteLength !== binding.crypto_pwhash_SALTBYTES)\n    throw new Error('salt')\n  if (opslimit < binding.crypto_pwhash_OPSLIMIT_MIN) throw new Error('opslimit')\n  if (opslimit > binding.crypto_pwhash_OPSLIMIT_MAX) throw new Error('opslimit')\n  if (memlimit < binding.crypto_pwhash_MEMLIMIT_MIN) throw new Error('memlimit')\n  if (memlimit > binding.crypto_pwhash_MEMLIMIT_MAX) throw new Error('memlimit')\n  if (alg < 1 || alg > 2)\n    throw new Error('alg must be either Argon2i 1.3 or Argon2id 1.3')\n\n  const res = binding.crypto_pwhash(out, passwd, salt, opslimit, memlimit, alg)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_pwhash_async = function (\n  out,\n  passwd,\n  salt,\n  opslimit,\n  memlimit,\n  alg,\n  callback = undefined\n) {\n  if (out?.byteLength < binding.crypto_pwhash_BYTES_MIN) throw new Error('out')\n  if (out?.byteLength > binding.crypto_pwhash_BYTES_MAX) throw new Error('out')\n  if (salt?.byteLength !== binding.crypto_pwhash_SALTBYTES)\n    throw new Error('salt')\n  if (opslimit < binding.crypto_pwhash_OPSLIMIT_MIN) throw new Error('opslimit')\n  if (opslimit > binding.crypto_pwhash_OPSLIMIT_MAX) throw new Error('opslimit')\n  if (memlimit < binding.crypto_pwhash_MEMLIMIT_MIN) throw new Error('memlimit')\n  if (memlimit > binding.crypto_pwhash_MEMLIMIT_MAX) throw new Error('memlimit')\n  if (alg < 1 || alg > 2)\n    throw new Error('alg must be either Argon2i 1.3 or Argon2id 1.3')\n\n  const [done, promise] = checkStatus(callback)\n\n  binding.crypto_pwhash_async(\n    out.buffer,\n    out.byteOffset,\n    out.byteLength,\n\n    passwd.buffer,\n    passwd.byteOffset,\n    passwd.byteLength,\n\n    salt.buffer,\n    salt.byteOffset,\n    salt.byteLength,\n\n    opslimit,\n    memlimit,\n    alg,\n\n    done\n  )\n\n  return promise\n}\n\nexports.crypto_pwhash_str = function (out, passwd, opslimit, memlimit) {\n  if (out?.byteLength !== binding.crypto_pwhash_STRBYTES) throw new Error('out')\n  if (typeof opslimit !== 'number') throw new Error('opslimit')\n  if (opslimit < binding.crypto_pwhash_OPSLIMIT_MIN) throw new Error('opslimit')\n  if (opslimit > binding.crypto_pwhash_OPSLIMIT_MAX) throw new Error('opslimit')\n  if (typeof memlimit !== 'number') throw new Error('memlimit')\n  if (memlimit < binding.crypto_pwhash_MEMLIMIT_MIN) throw new Error('memlimit')\n  if (memlimit > binding.crypto_pwhash_MEMLIMIT_MAX) throw new Error('memlimit')\n\n  const res = binding.crypto_pwhash_str(out, passwd, opslimit, memlimit)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_pwhash_str_async = function (\n  out,\n  passwd,\n  opslimit,\n  memlimit,\n  callback = undefined\n) {\n  if (out?.byteLength !== binding.crypto_pwhash_STRBYTES) throw new Error('out')\n  if (!passwd?.byteLength) throw new Error('passwd')\n  if (typeof opslimit !== 'number') throw new Error('opslimit')\n  if (opslimit < binding.crypto_pwhash_OPSLIMIT_MIN) throw new Error('opslimit')\n  if (opslimit > binding.crypto_pwhash_OPSLIMIT_MAX) throw new Error('opslimit')\n  if (typeof memlimit !== 'number') throw new Error('memlimit')\n  if (memlimit < binding.crypto_pwhash_MEMLIMIT_MIN) throw new Error('memlimit')\n  if (memlimit > binding.crypto_pwhash_MEMLIMIT_MAX) throw new Error('memlimit')\n\n  const [done, promise] = checkStatus(callback)\n\n  binding.crypto_pwhash_str_async(\n    out.buffer,\n    out.byteOffset,\n    out.byteLength,\n\n    passwd.buffer,\n    passwd.byteOffset,\n    passwd.byteLength,\n\n    opslimit,\n    memlimit,\n\n    done\n  )\n\n  return promise\n}\n\nexports.crypto_pwhash_str_verify = function (str, passwd) {\n  if (str?.byteLength !== binding.crypto_pwhash_STRBYTES) throw new Error('str')\n\n  return binding.crypto_pwhash_str_verify(str, passwd)\n}\n\nexports.crypto_pwhash_str_verify_async = function (\n  str,\n  passwd,\n  callback = undefined\n) {\n  if (str?.byteLength !== binding.crypto_pwhash_STRBYTES) throw new Error('str')\n  if (!passwd?.byteLength) throw new Error('passwd')\n\n  const [done, promise] = checkStatus(callback, true)\n\n  binding.crypto_pwhash_str_verify_async(\n    str.buffer,\n    str.byteOffset,\n    str.byteLength,\n\n    passwd.buffer,\n    passwd.byteOffset,\n    passwd.byteLength,\n\n    done\n  )\n\n  return promise\n}\n\nexports.crypto_pwhash_str_needs_rehash = function (str, opslimit, memlimit) {\n  if (str?.byteLength !== binding.crypto_pwhash_STRBYTES) throw new Error('str')\n  if (opslimit < binding.crypto_pwhash_OPSLIMIT_MIN) throw new Error('opslimit')\n  if (opslimit > binding.crypto_pwhash_OPSLIMIT_MAX) throw new Error('opslimit')\n  if (memlimit < binding.crypto_pwhash_MEMLIMIT_MIN) throw new Error('memlimit')\n  if (memlimit > binding.crypto_pwhash_MEMLIMIT_MAX) throw new Error('memlimit')\n\n  return binding.crypto_pwhash_str_needs_rehash(str, opslimit, memlimit)\n}\n\nexports.crypto_pwhash_scryptsalsa208sha256 = function (\n  out,\n  passwd,\n  salt,\n  opslimit,\n  memlimit\n) {\n  if (out?.byteLength < binding.crypto_pwhash_scryptsalsa208sha256_BYTES_MIN)\n    throw new Error('out')\n  if (out?.byteLength > binding.crypto_pwhash_scryptsalsa208sha256_BYTES_MAX)\n    throw new Error('out')\n  if (salt?.byteLength !== binding.crypto_pwhash_scryptsalsa208sha256_SALTBYTES)\n    throw new Error('salt')\n  if (opslimit < binding.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN)\n    throw new Error('opslimit')\n  if (opslimit > binding.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX)\n    throw new Error('opslimit')\n  if (memlimit < binding.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN)\n    throw new Error('memlimit')\n  if (memlimit > binding.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX)\n    throw new Error('memlimit')\n\n  const res = binding.crypto_pwhash_scryptsalsa208sha256(\n    out,\n    passwd,\n    salt,\n    opslimit,\n    memlimit\n  )\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_pwhash_scryptsalsa208sha256_async = function (\n  out,\n  passwd,\n  salt,\n  opslimit,\n  memlimit,\n  callback = undefined\n) {\n  if (out?.byteLength < binding.crypto_pwhash_scryptsalsa208sha256_BYTES_MIN)\n    throw new Error('out')\n  if (out?.byteLength > binding.crypto_pwhash_scryptsalsa208sha256_BYTES_MAX)\n    throw new Error('out')\n  if (!passwd?.byteLength) throw new Error('passwd')\n  if (salt?.byteLength !== binding.crypto_pwhash_scryptsalsa208sha256_SALTBYTES)\n    throw new Error('salt')\n  if (opslimit < binding.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN)\n    throw new Error('opslimit')\n  if (opslimit > binding.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX)\n    throw new Error('opslimit')\n  if (memlimit < binding.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN)\n    throw new Error('memlimit')\n  if (memlimit > binding.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX)\n    throw new Error('memlimit')\n\n  const [done, promise] = checkStatus(callback)\n\n  binding.crypto_pwhash_scryptsalsa208sha256_async(\n    out.buffer,\n    out.byteOffset,\n    out.byteLength,\n\n    passwd.buffer,\n    passwd.byteOffset,\n    passwd.byteLength,\n\n    salt.buffer,\n    salt.byteOffset,\n    salt.byteLength,\n\n    opslimit,\n    memlimit,\n\n    done\n  )\n\n  return promise\n}\n\nexports.crypto_pwhash_scryptsalsa208sha256_str_async = function (\n  out,\n  passwd,\n  opslimit,\n  memlimit,\n  callback = undefined\n) {\n  if (out?.byteLength !== binding.crypto_pwhash_scryptsalsa208sha256_STRBYTES)\n    throw new Error('out')\n  if (!passwd?.byteLength) throw new Error('passwd')\n  if (opslimit < binding.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN)\n    throw new Error('opslimit')\n  if (opslimit > binding.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX)\n    throw new Error('opslimit')\n  if (memlimit < binding.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN)\n    throw new Error('memlimit')\n  if (memlimit > binding.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX)\n    throw new Error('memlimit')\n\n  const [done, promise] = checkStatus(callback)\n\n  binding.crypto_pwhash_scryptsalsa208sha256_str_async(\n    out.buffer,\n    out.byteOffset,\n    out.byteLength,\n\n    passwd.buffer,\n    passwd.byteOffset,\n    passwd.byteLength,\n\n    opslimit,\n    memlimit,\n\n    done\n  )\n\n  return promise\n}\n\nexports.crypto_pwhash_scryptsalsa208sha256_str = function (\n  out,\n  passwd,\n  opslimit,\n  memlimit\n) {\n  if (out?.byteLength !== binding.crypto_pwhash_scryptsalsa208sha256_STRBYTES)\n    throw new Error('out')\n  if (!passwd?.byteLength) throw new Error('passwd')\n  if (opslimit < binding.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN)\n    throw new Error('opslimit')\n  if (opslimit > binding.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX)\n    throw new Error('opslimit')\n  if (memlimit < binding.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN)\n    throw new Error('memlimit')\n  if (memlimit > binding.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MAX)\n    throw new Error('memlimit')\n\n  const res = binding.crypto_pwhash_scryptsalsa208sha256_str(\n    out,\n    passwd,\n    opslimit,\n    memlimit\n  )\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_pwhash_scryptsalsa208sha256_str_verify_async = function (\n  str,\n  passwd,\n  callback = undefined\n) {\n  if (str?.byteLength !== binding.crypto_pwhash_scryptsalsa208sha256_STRBYTES)\n    throw new Error('str')\n  if (!passwd?.byteLength) throw new Error('passwd')\n\n  const [done, promise] = checkStatus(callback, true)\n\n  binding.crypto_pwhash_scryptsalsa208sha256_str_verify_async(\n    str.buffer,\n    str.byteOffset,\n    str.byteLength,\n\n    passwd.buffer,\n    passwd.byteOffset,\n    passwd.byteLength,\n\n    done\n  )\n\n  return promise\n}\n\nexports.crypto_pwhash_scryptsalsa208sha256_str_verify = function (str, passwd) {\n  if (str?.byteLength !== binding.crypto_pwhash_scryptsalsa208sha256_STRBYTES)\n    throw new Error('str')\n  if (!passwd?.byteLength) throw new Error('passwd')\n\n  return binding.crypto_pwhash_scryptsalsa208sha256_str_verify(str, passwd)\n}\n\nexports.crypto_pwhash_scryptsalsa208sha256_str_needs_rehash = function (\n  str,\n  opslimit,\n  memlimit\n) {\n  if (str?.byteLength !== binding.crypto_pwhash_scryptsalsa208sha256_STRBYTES)\n    throw new Error('str')\n  if (opslimit < binding.crypto_pwhash_OPSLIMIT_MIN) throw new Error('opslimit')\n  if (opslimit > binding.crypto_pwhash_OPSLIMIT_MAX) throw new Error('opslimit')\n  if (memlimit < binding.crypto_pwhash_MEMLIMIT_MIN) throw new Error('memlimit')\n  if (memlimit > binding.crypto_pwhash_MEMLIMIT_MAX) throw new Error('memlimit')\n\n  return binding.crypto_pwhash_scryptsalsa208sha256_str_needs_rehash(\n    str,\n    opslimit,\n    memlimit\n  )\n}\n\n// crypto_kx\n\nexports.crypto_kx_keypair = function (pk, sk) {\n  if (pk?.byteLength !== binding.crypto_kx_PUBLICKEYBYTES) throw new Error('pk')\n  if (sk?.byteLength !== binding.crypto_kx_SECRETKEYBYTES) throw new Error('sk')\n\n  const res = binding.crypto_kx_keypair(pk, sk)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_kx_seed_keypair = function (pk, sk, seed) {\n  if (pk?.byteLength !== binding.crypto_kx_PUBLICKEYBYTES) throw new Error('pk')\n  if (sk?.byteLength !== binding.crypto_kx_SECRETKEYBYTES) throw new Error('sk')\n  if (seed?.byteLength !== binding.crypto_kx_SEEDBYTES) throw new Error('seed')\n\n  const res = binding.crypto_kx_seed_keypair(pk, sk, seed)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_kx_client_session_keys = function (\n  rx,\n  tx,\n  clientPk,\n  clientSk,\n  serverPk\n) {\n  // match `std::optional` by coercing null to undefined\n  rx ??= undefined\n  tx ??= undefined\n\n  if (!rx && !tx) throw new Error('at least one session key must be specified')\n\n  if (rx) {\n    if (rx?.byteLength !== binding.crypto_kx_SESSIONKEYBYTES)\n      throw new Error(\n        'receiving key buffer must be \"crypto_kx_SESSIONKEYBYTES\" bytes or null'\n      )\n  } else {\n    if (tx?.byteLength !== binding.crypto_kx_SESSIONKEYBYTES)\n      throw new Error(\n        'transmitting key buffer must be \"crypto_kx_SESSIONKEYBYTES\" bytes or null'\n      )\n  }\n\n  if (clientPk?.byteLength !== binding.crypto_kx_PUBLICKEYBYTES)\n    throw new Error('client_pk')\n  if (clientSk?.byteLength !== binding.crypto_kx_SECRETKEYBYTES)\n    throw new Error('client_sk')\n  if (serverPk?.byteLength !== binding.crypto_kx_PUBLICKEYBYTES)\n    throw new Error('server_pk')\n\n  const res = binding.crypto_kx_client_session_keys(\n    rx,\n    tx,\n    clientPk,\n    clientSk,\n    serverPk\n  )\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_kx_server_session_keys = function (\n  rx,\n  tx,\n  serverPk,\n  serverSk,\n  clientPk\n) {\n  rx ??= undefined\n  tx ??= undefined\n\n  if (!rx && !tx) throw new Error('at least one session key must be specified')\n\n  if (rx) {\n    if (rx?.byteLength !== binding.crypto_kx_SESSIONKEYBYTES)\n      throw new Error(\n        'receiving key buffer must be \"crypto_kx_SESSIONKEYBYTES\" bytes or null'\n      )\n  } else {\n    if (tx?.byteLength !== binding.crypto_kx_SESSIONKEYBYTES)\n      throw new Error(\n        'transmitting key buffer must be \"crypto_kx_SESSIONKEYBYTES\" bytes or null'\n      )\n  }\n\n  if (serverPk?.byteLength !== binding.crypto_kx_PUBLICKEYBYTES)\n    throw new Error('server_pk')\n  if (serverSk?.byteLength !== binding.crypto_kx_SECRETKEYBYTES)\n    throw new Error('server_sk')\n  if (clientPk?.byteLength !== binding.crypto_kx_PUBLICKEYBYTES)\n    throw new Error('client_pk')\n\n  const res = binding.crypto_kx_server_session_keys(\n    rx,\n    tx,\n    serverPk,\n    serverSk,\n    clientPk\n  )\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\n// crypto_scalarmult\n\nexports.crypto_scalarmult_base = function (q, n) {\n  if (q?.byteLength !== binding.crypto_scalarmult_BYTES) throw new Error('q')\n  if (n?.byteLength !== binding.crypto_scalarmult_SCALARBYTES)\n    throw new Error('n')\n\n  const res = binding.crypto_scalarmult_base(q, n)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_scalarmult = function (q, n, p) {\n  if (q?.byteLength !== binding.crypto_scalarmult_BYTES) throw new Error('q')\n  if (n?.byteLength !== binding.crypto_scalarmult_SCALARBYTES)\n    throw new Error('n')\n  if (p?.byteLength !== binding.crypto_scalarmult_BYTES) throw new Error('p')\n\n  const res = binding.crypto_scalarmult(q, n, p)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_scalarmult_ed25519_base = function (q, n) {\n  if (q?.byteLength !== binding.crypto_scalarmult_ed25519_BYTES)\n    throw new Error('q')\n  if (n?.byteLength !== binding.crypto_scalarmult_ed25519_SCALARBYTES)\n    throw new Error('n')\n\n  const res = binding.crypto_scalarmult_ed25519_base(q, n)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_scalarmult_ed25519 = function (q, n, p) {\n  if (q?.byteLength !== binding.crypto_scalarmult_ed25519_BYTES)\n    throw new Error('q')\n  if (n?.byteLength !== binding.crypto_scalarmult_ed25519_SCALARBYTES)\n    throw new Error('n')\n  if (p?.byteLength !== binding.crypto_scalarmult_ed25519_BYTES)\n    throw new Error('p')\n\n  const res = binding.crypto_scalarmult_ed25519(q, n, p)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_core_ed25519_is_valid_point = function (p) {\n  if (p?.byteLength !== binding.crypto_core_ed25519_BYTES) throw new Error('p')\n\n  return binding.crypto_core_ed25519_is_valid_point(p)\n}\n\nexports.crypto_core_ed25519_from_uniform = function (p, r) {\n  if (p?.byteLength !== binding.crypto_core_ed25519_BYTES) throw new Error('p')\n  if (r?.byteLength !== binding.crypto_core_ed25519_UNIFORMBYTES)\n    throw new Error('r')\n\n  const res = binding.crypto_core_ed25519_from_uniform(p, r)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_scalarmult_ed25519_base_noclamp = function (q, n) {\n  if (q?.byteLength !== binding.crypto_scalarmult_ed25519_BYTES)\n    throw new Error('q')\n  if (n?.byteLength !== binding.crypto_scalarmult_ed25519_SCALARBYTES)\n    throw new Error('n')\n\n  const res = binding.crypto_scalarmult_ed25519_base_noclamp(q, n)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_scalarmult_ed25519_noclamp = function (q, n, p) {\n  if (q?.byteLength !== binding.crypto_scalarmult_ed25519_BYTES)\n    throw new Error('q')\n  if (n?.byteLength !== binding.crypto_scalarmult_ed25519_SCALARBYTES)\n    throw new Error('n')\n  if (p?.byteLength !== binding.crypto_scalarmult_ed25519_BYTES)\n    throw new Error('p')\n\n  const res = binding.crypto_scalarmult_ed25519_noclamp(q, n, p)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\n// crypto_core\n\nexports.crypto_core_ed25519_add = function (r, p, q) {\n  if (r?.byteLength !== binding.crypto_core_ed25519_BYTES) throw new Error('r')\n  if (p?.byteLength !== binding.crypto_core_ed25519_BYTES) throw new Error('p')\n  if (q?.byteLength !== binding.crypto_core_ed25519_BYTES) throw new Error('q')\n\n  const res = binding.crypto_core_ed25519_add(r, p, q)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_core_ed25519_sub = function (r, p, q) {\n  if (r?.byteLength !== binding.crypto_core_ed25519_BYTES) throw new Error('r')\n  if (p?.byteLength !== binding.crypto_core_ed25519_BYTES) throw new Error('p')\n  if (q?.byteLength !== binding.crypto_core_ed25519_BYTES) throw new Error('q')\n\n  const res = binding.crypto_core_ed25519_sub(r, p, q)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_core_ed25519_scalar_random = function (r) {\n  if (r?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)\n    throw new Error('r')\n\n  binding.crypto_core_ed25519_scalar_random(r)\n}\n\nexports.crypto_core_ed25519_scalar_reduce = function (r, s) {\n  if (r?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)\n    throw new Error('r')\n  if (s?.byteLength !== binding.crypto_core_ed25519_NONREDUCEDSCALARBYTES)\n    throw new Error('s')\n\n  binding.crypto_core_ed25519_scalar_reduce(r, s)\n}\n\nexports.crypto_core_ed25519_scalar_invert = function (recip, s) {\n  if (recip?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)\n    throw new Error('recip')\n  if (s?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)\n    throw new Error('s')\n\n  binding.crypto_core_ed25519_scalar_invert(recip, s)\n}\n\nexports.crypto_core_ed25519_scalar_negate = function (neg, s) {\n  if (neg?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)\n    throw new Error('neg')\n  if (s?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)\n    throw new Error('s')\n\n  binding.crypto_core_ed25519_scalar_negate(neg, s)\n}\n\nexports.crypto_core_ed25519_scalar_complement = function (comp, s) {\n  if (comp?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)\n    throw new Error('comp')\n  if (s?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)\n    throw new Error('s')\n\n  binding.crypto_core_ed25519_scalar_complement(comp, s)\n}\n\nexports.crypto_core_ed25519_scalar_add = function (z, x, y) {\n  if (z?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)\n    throw new Error('z')\n  if (x?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)\n    throw new Error('x')\n  if (y?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)\n    throw new Error('y')\n\n  binding.crypto_core_ed25519_scalar_add(z, x, y)\n}\n\nexports.crypto_core_ed25519_scalar_sub = function (z, x, y) {\n  if (z?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)\n    throw new Error('z')\n  if (x?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)\n    throw new Error('x')\n  if (y?.byteLength !== binding.crypto_core_ed25519_SCALARBYTES)\n    throw new Error('y')\n\n  binding.crypto_core_ed25519_scalar_sub(z, x, y)\n}\n\n// crypto_shorthash\n\nexports.crypto_shorthash = function (out, input, k) {\n  if (out?.byteLength !== binding.crypto_shorthash_BYTES) throw new Error('out')\n  if (k?.byteLength !== binding.crypto_shorthash_KEYBYTES) throw new Error('k')\n\n  const res = binding.crypto_shorthash(out, input, k)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\n// crypto_kdf\n\nexports.crypto_kdf_keygen = function (key) {\n  if (key?.byteLength !== binding.crypto_kdf_KEYBYTES) throw new Error('key')\n\n  binding.crypto_kdf_keygen(key)\n}\n\nexports.crypto_kdf_derive_from_key = function (subkey, subkeyId, ctx, key) {\n  if (subkey?.byteLength < binding.crypto_kdf_BYTES_MIN)\n    throw new Error('subkey')\n  if (subkey?.byteLength > binding.crypto_kdf_BYTES_MAX)\n    throw new Error('subkey')\n  if (ctx?.byteLength !== binding.crypto_kdf_CONTEXTBYTES)\n    throw new Error('ctx')\n  if (key?.byteLength !== binding.crypto_kdf_KEYBYTES) throw new Error('key')\n\n  const res = binding.crypto_kdf_derive_from_key(subkey, subkeyId, ctx, key)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\n// crypto_hash\n\nexports.crypto_hash = function (out, input) {\n  if (out?.byteLength !== binding.crypto_hash_BYTES) throw new Error('out')\n\n  const res = binding.crypto_hash(out, input)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_hash_sha256 = function (out, input) {\n  if (out?.byteLength !== binding.crypto_hash_sha256_BYTES)\n    throw new Error('out')\n\n  const res = binding.crypto_hash_sha256(out, input)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_hash_sha256_init = function (state) {\n  if (state?.byteLength !== binding.crypto_hash_sha256_STATEBYTES) {\n    throw new Error(\"state must be 'crypto_hash_sha256_STATEBYTES' bytes\")\n  }\n\n  const res = binding.crypto_hash_sha256_init(state)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_hash_sha256_update = function (state, input) {\n  if (state?.byteLength !== binding.crypto_hash_sha256_STATEBYTES) {\n    throw new Error(\"state must be 'crypto_hash_sha256_STATEBYTES' bytes\")\n  }\n\n  const res = binding.crypto_hash_sha256_update(state, input)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_hash_sha256_final = function (state, out) {\n  if (state?.byteLength !== binding.crypto_hash_sha256_STATEBYTES) {\n    throw new Error(\"state must be 'crypto_hash_sha256_STATEBYTES' bytes\")\n  }\n  if (out?.byteLength !== binding.crypto_hash_sha256_BYTES)\n    throw new Error('state')\n\n  const res = binding.crypto_hash_sha256_final(state, out)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_hash_sha512 = function (out, input) {\n  if (out?.byteLength !== binding.crypto_hash_sha512_BYTES)\n    throw new Error('out')\n\n  const res = binding.crypto_hash_sha512(out, input)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_hash_sha512_init = function (state) {\n  if (state?.byteLength !== binding.crypto_hash_sha512_STATEBYTES) {\n    throw new Error(\"state must be 'crypto_hash_sha512_STATEBYTES' bytes\")\n  }\n\n  const res = binding.crypto_hash_sha512_init(state)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_hash_sha512_update = function (state, input) {\n  if (state?.byteLength !== binding.crypto_hash_sha512_STATEBYTES) {\n    throw new Error(\"state must be 'crypto_hash_sha512_STATEBYTES' bytes\")\n  }\n\n  const res = binding.crypto_hash_sha512_update(state, input)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\nexports.crypto_hash_sha512_final = function (state, out) {\n  if (state?.byteLength !== binding.crypto_hash_sha512_STATEBYTES) {\n    throw new Error(\"state must be 'crypto_hash_sha512_STATEBYTES' bytes\")\n  }\n  if (out?.byteLength !== binding.crypto_hash_sha512_BYTES)\n    throw new Error('out')\n\n  const res = binding.crypto_hash_sha512_final(state, out)\n\n  if (res !== 0) throw new Error('status: ' + res)\n}\n\n// crypto_aead\n\nexports.crypto_aead_xchacha20poly1305_ietf_keygen = function (k) {\n  if (k?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_KEYBYTES)\n    throw new Error('k')\n\n  binding.crypto_aead_xchacha20poly1305_ietf_keygen(k)\n}\n\nexports.crypto_aead_xchacha20poly1305_ietf_encrypt = function (\n  c,\n  m,\n  ad,\n  nsec = null,\n  npub,\n  k\n) {\n  ad ??= undefined\n  if (nsec !== null) throw new Error('nsec must always be set to null')\n  if (\n    c?.byteLength !==\n    m.byteLength + binding.crypto_aead_xchacha20poly1305_ietf_ABYTES\n  )\n    throw new Error(\n      'c must \"m.byteLength + crypto_aead_xchacha20poly1305_ietf_ABYTES\" bytes'\n    )\n  if (c?.byteLength > 0xffffffff)\n    throw new Error('c.byteLength must be a 32bit integer')\n  if (npub?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES)\n    throw new Error('npub')\n  if (k?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_aead_xchacha20poly1305_ietf_encrypt(\n    c,\n    m,\n    ad,\n    npub,\n    k\n  )\n  if (res < 0) throw new Error('could not encrypt data')\n\n  return res\n}\n\nexports.crypto_aead_xchacha20poly1305_ietf_decrypt = function (\n  m,\n  nsec = null,\n  c,\n  ad,\n  npub,\n  k\n) {\n  ad ??= undefined\n  if (nsec !== null) throw new Error('nsec must always be set to null')\n  if (\n    m?.byteLength !==\n    c.byteLength - binding.crypto_aead_xchacha20poly1305_ietf_ABYTES\n  )\n    throw new Error(\n      'm must \"c.byteLength - crypto_aead_xchacha20poly1305_ietf_ABYTES\" bytes'\n    )\n  if (m?.byteLength > 0xffffffff)\n    throw new Error('m.byteLength must be a 32bit integer')\n  if (npub?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES)\n    throw new Error('npub')\n  if (k?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_aead_xchacha20poly1305_ietf_decrypt(\n    m,\n    c,\n    ad,\n    npub,\n    k\n  )\n  if (res < 0) throw new Error('could not verify data')\n\n  return res\n}\n\nexports.crypto_aead_xchacha20poly1305_ietf_encrypt_detached = function (\n  c,\n  mac,\n  m,\n  ad,\n  nsec = null,\n  npub,\n  k\n) {\n  ad ??= undefined\n  if (nsec !== null) throw new Error('nsec must always be set to null')\n  if (c?.byteLength !== m.byteLength)\n    throw new Error('c must be \"m.byteLength\" bytes')\n  if (mac?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_ABYTES)\n    throw new Error('mac')\n  if (npub?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES)\n    throw new Error('npub')\n  if (k?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_aead_xchacha20poly1305_ietf_encrypt_detached(\n    c,\n    mac,\n    m,\n    ad,\n    npub,\n    k\n  )\n  if (res < 0) throw new Error('could not encrypt data')\n\n  return res\n}\n\nexports.crypto_aead_xchacha20poly1305_ietf_decrypt_detached = function (\n  m,\n  nsec = null,\n  c,\n  mac,\n  ad,\n  npub,\n  k\n) {\n  ad ??= undefined\n  if (nsec !== null) throw new Error('nsec must always be set to null')\n  if (m?.byteLength !== c.byteLength)\n    throw new Error('m must be \"c.byteLength\" bytes')\n  if (mac?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_ABYTES)\n    throw new Error('mac')\n  if (npub?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES)\n    throw new Error('npub')\n  if (k?.byteLength !== binding.crypto_aead_xchacha20poly1305_ietf_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_aead_xchacha20poly1305_ietf_decrypt_detached(\n    m,\n    c,\n    mac,\n    ad,\n    npub,\n    k\n  )\n  if (res !== 0) throw new Error('could not verify data')\n}\n\nexports.crypto_aead_chacha20poly1305_ietf_keygen = function (k) {\n  if (k?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_KEYBYTES)\n    throw new Error('k')\n\n  binding.crypto_aead_chacha20poly1305_ietf_keygen(k)\n}\n\nexports.crypto_aead_chacha20poly1305_ietf_encrypt = function (\n  c,\n  m,\n  ad,\n  nsec = null,\n  npub,\n  k\n) {\n  ad ??= undefined\n  if (nsec !== null) throw new Error('nsec must always be set to null')\n  if (\n    c?.byteLength !==\n    m.byteLength + binding.crypto_aead_chacha20poly1305_ietf_ABYTES\n  )\n    throw new Error(\n      'c must \"m.byteLength + crypto_aead_chacha20poly1305_ietf_ABYTES\" bytes'\n    )\n  if (c?.byteLength > 0xffffffff)\n    throw new Error('c.byteLength must be a 32bit integer')\n  if (npub?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_NPUBBYTES)\n    throw new Error('npub')\n  if (k?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_aead_chacha20poly1305_ietf_encrypt(\n    c,\n    m,\n    ad,\n    npub,\n    k\n  )\n  if (res < 0) throw new Error('could not encrypt data')\n\n  return res\n}\n\nexports.crypto_aead_chacha20poly1305_ietf_decrypt = function (\n  m,\n  nsec = null,\n  c,\n  ad,\n  npub,\n  k\n) {\n  ad ??= undefined\n  if (nsec !== null) throw new Error('nsec must always be set to null')\n  if (\n    m?.byteLength !==\n    c.byteLength - binding.crypto_aead_chacha20poly1305_ietf_ABYTES\n  )\n    throw new Error(\n      'm must \"c.byteLength - crypto_aead_chacha20poly1305_ietf_ABYTES\" bytes'\n    )\n  if (m?.byteLength > 0xffffffff)\n    throw new Error('m.byteLength must be a 32bit integer')\n  if (npub?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_NPUBBYTES)\n    throw new Error('npub')\n  if (k?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_aead_chacha20poly1305_ietf_decrypt(\n    m,\n    c,\n    ad,\n    npub,\n    k\n  )\n  if (res < 0) throw new Error('could not verify data')\n\n  return res\n}\n\nexports.crypto_aead_chacha20poly1305_ietf_encrypt_detached = function (\n  c,\n  mac,\n  m,\n  ad,\n  nsec = null,\n  npub,\n  k\n) {\n  ad ??= undefined\n  if (nsec !== null) throw new Error('nsec must always be set to null')\n  if (c?.byteLength !== m.byteLength)\n    throw new Error('c must be \"m.byteLength\" bytes')\n  if (mac?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_ABYTES)\n    throw new Error('mac')\n  if (npub?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_NPUBBYTES)\n    throw new Error('npub')\n  if (k?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_aead_chacha20poly1305_ietf_encrypt_detached(\n    c,\n    mac,\n    m,\n    ad,\n    npub,\n    k\n  )\n  if (res < 0) throw new Error('could not encrypt data')\n\n  return res\n}\n\nexports.crypto_aead_chacha20poly1305_ietf_decrypt_detached = function (\n  m,\n  nsec = null,\n  c,\n  mac,\n  ad,\n  npub,\n  k\n) {\n  ad ??= undefined\n  if (nsec !== null) throw new Error('nsec must always be set to null')\n  if (m?.byteLength !== c.byteLength)\n    throw new Error('m must be \"c.byteLength\" bytes')\n  if (mac?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_ABYTES)\n    throw new Error('mac')\n  if (npub?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_NPUBBYTES)\n    throw new Error('npub')\n  if (k?.byteLength !== binding.crypto_aead_chacha20poly1305_ietf_KEYBYTES)\n    throw new Error('k')\n\n  const res = binding.crypto_aead_chacha20poly1305_ietf_decrypt_detached(\n    m,\n    c,\n    mac,\n    ad,\n    npub,\n    k\n  )\n  if (res !== 0) throw new Error('could not verify data')\n}\n\n// crypto_stream\n\nexports.crypto_stream_xor_wrap_init = function (state, n, k) {\n  if (state?.byteLength !== binding.sn_crypto_stream_xor_STATEBYTES) {\n    throw new Error(\"state must be 'sn_crypto_stream_xor_STATEBYTES' bytes\")\n  }\n  if (n?.byteLength !== binding.crypto_stream_NONCEBYTES) throw new Error('n')\n  if (k?.byteLength !== binding.crypto_stream_KEYBYTES) throw new Error('k')\n\n  binding.crypto_stream_xor_wrap_init(state, n, k)\n}\n\nexports.crypto_stream_xor_wrap_update = function (state, c, m) {\n  if (state?.byteLength !== binding.sn_crypto_stream_xor_STATEBYTES) {\n    throw new Error(\"state must be 'sn_crypto_stream_xor_STATEBYTES' bytes\")\n  }\n  if (c?.byteLength !== m.byteLength)\n    throw new Error('c must be \"m.byteLength\" bytes')\n\n  binding.crypto_stream_xor_wrap_update(state, c, m)\n}\n\nexports.crypto_stream_xor_wrap_final = function (state) {\n  if (state?.byteLength !== binding.sn_crypto_stream_xor_STATEBYTES) {\n    throw new Error(\"state must be 'sn_crypto_stream_xor_STATEBYTES' bytes\")\n  }\n\n  binding.crypto_stream_xor_wrap_final(state)\n}\n\nexports.crypto_stream_chacha20_xor_wrap_init = function (state, n, k) {\n  if (state?.byteLength !== binding.crypto_stream_chacha20_xor_STATEBYTES) {\n    throw new Error(\n      \"state must be 'crypto_stream_chacha20_xor_STATEBYTES' bytes\"\n    )\n  }\n  if (n?.byteLength !== binding.crypto_stream_chacha20_NONCEBYTES)\n    throw new Error('n')\n  if (k?.byteLength !== binding.crypto_stream_chacha20_KEYBYTES)\n    throw new Error('k')\n\n  binding.crypto_stream_chacha20_xor_wrap_init(state, n, k)\n}\n\nexports.crypto_stream_chacha20_xor_wrap_update = function (state, c, m) {\n  if (state?.byteLength !== binding.crypto_stream_chacha20_xor_STATEBYTES) {\n    throw new Error(\n      \"state must be 'crypto_stream_chacha20_xor_STATEBYTES' bytes\"\n    )\n  }\n  if (c?.byteLength !== m.byteLength)\n    throw new Error('c must be \"m.byteLength\" bytes')\n\n  binding.crypto_stream_chacha20_xor_wrap_update(state, c, m)\n}\n\nexports.crypto_stream_chacha20_xor_wrap_final = function (state) {\n  if (state?.byteLength !== binding.crypto_stream_chacha20_xor_STATEBYTES) {\n    throw new Error(\n      \"state must be 'crypto_stream_chacha20_xor_STATEBYTES' bytes\"\n    )\n  }\n\n  binding.crypto_stream_chacha20_xor_wrap_final(state)\n}\n\nexports.crypto_stream_chacha20_ietf_xor_wrap_init = function (state, n, k) {\n  if (\n    state?.byteLength !== binding.crypto_stream_chacha20_ietf_xor_STATEBYTES\n  ) {\n    throw new Error(\n      \"state must be 'crypto_stream_chacha20_ietf_xor_STATEBYTES' bytes\"\n    )\n  }\n  if (n?.byteLength !== binding.crypto_stream_chacha20_ietf_NONCEBYTES)\n    throw new Error('n')\n  if (k?.byteLength !== binding.crypto_stream_chacha20_ietf_KEYBYTES)\n    throw new Error('k')\n\n  binding.crypto_stream_chacha20_ietf_xor_wrap_init(state, n, k)\n}\n\nexports.crypto_stream_chacha20_ietf_xor_wrap_update = function (state, c, m) {\n  if (\n    state?.byteLength !== binding.crypto_stream_chacha20_ietf_xor_STATEBYTES\n  ) {\n    throw new Error(\n      \"state must be 'crypto_stream_chacha20_ietf_xor_STATEBYTES' bytes\"\n    )\n  }\n  if (c?.byteLength !== m.byteLength)\n    throw new Error('c must be \"m.byteLength\" bytes')\n\n  binding.crypto_stream_chacha20_ietf_xor_wrap_update(state, c, m)\n}\n\nexports.crypto_stream_chacha20_ietf_xor_wrap_final = function (state) {\n  if (\n    state?.byteLength !== binding.crypto_stream_chacha20_ietf_xor_STATEBYTES\n  ) {\n    throw new Error(\n      \"state must be 'crypto_stream_chacha20_ietf_xor_STATEBYTES' bytes\"\n    )\n  }\n\n  binding.crypto_stream_chacha20_ietf_xor_wrap_final(state)\n}\n\nexports.crypto_stream_xchacha20_xor_wrap_init = function (state, n, k) {\n  if (state?.byteLength !== binding.crypto_stream_xchacha20_xor_STATEBYTES) {\n    throw new Error(\n      \"state must be 'crypto_stream_xchacha20_xor_STATEBYTES' bytes\"\n    )\n  }\n  if (n?.byteLength !== binding.crypto_stream_xchacha20_NONCEBYTES)\n    throw new Error('n')\n  if (k?.byteLength !== binding.crypto_stream_xchacha20_KEYBYTES)\n    throw new Error('k')\n\n  binding.crypto_stream_xchacha20_xor_wrap_init(state, n, k)\n}\n\nexports.crypto_stream_xchacha20_xor_wrap_update = function (state, c, m) {\n  if (state?.byteLength !== binding.crypto_stream_xchacha20_xor_STATEBYTES) {\n    throw new Error(\n      \"state must be 'crypto_stream_xchacha20_xor_STATEBYTES' bytes\"\n    )\n  }\n  if (c?.byteLength !== m.byteLength)\n    throw new Error('c must be \"m.byteLength\" bytes')\n\n  binding.crypto_stream_xchacha20_xor_wrap_update(state, c, m)\n}\n\nexports.crypto_stream_xchacha20_xor_wrap_final = function (state) {\n  if (state?.byteLength !== binding.crypto_stream_xchacha20_xor_STATEBYTES) {\n    throw new Error(\n      \"state must be 'crypto_stream_xchacha20_xor_STATEBYTES' bytes\"\n    )\n  }\n\n  binding.crypto_stream_xchacha20_xor_wrap_final(state)\n}\n\nexports.crypto_stream_salsa20_xor_wrap_init = function (state, n, k) {\n  if (state?.byteLength !== binding.crypto_stream_salsa20_xor_STATEBYTES) {\n    throw new Error(\n      \"state must be 'crypto_stream_salsa20_xor_STATEBYTES' bytes\"\n    )\n  }\n  if (n?.byteLength !== binding.crypto_stream_salsa20_NONCEBYTES)\n    throw new Error('n')\n  if (k?.byteLength !== binding.crypto_stream_salsa20_KEYBYTES)\n    throw new Error('k')\n\n  binding.crypto_stream_salsa20_xor_wrap_init(state, n, k)\n}\n\nexports.crypto_stream_salsa20_xor_wrap_update = function (state, c, m) {\n  if (state?.byteLength !== binding.crypto_stream_salsa20_xor_STATEBYTES) {\n    throw new Error(\n      \"state must be 'crypto_stream_salsa20_xor_STATEBYTES' bytes\"\n    )\n  }\n  if (c?.byteLength !== m.byteLength)\n    throw new Error('c must be \"m.byteLength\" bytes')\n\n  binding.crypto_stream_salsa20_xor_wrap_update(state, c, m)\n}\n\nexports.crypto_stream_salsa20_xor_wrap_final = function (state) {\n  if (state?.byteLength !== binding.crypto_stream_salsa20_xor_STATEBYTES) {\n    throw new Error(\n      \"state must be 'crypto_stream_salsa20_xor_STATEBYTES' bytes\"\n    )\n  }\n\n  binding.crypto_stream_salsa20_xor_wrap_final(state)\n}\n\n// experimental\n\nexports.extension_tweak_ed25519_base = function (n, p, ns) {\n  if (n?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)\n    throw new Error('n')\n  if (p?.byteLength !== binding.extension_tweak_ed25519_BYTES)\n    throw new Error('p')\n\n  binding.extension_tweak_ed25519_base(n, p, ns)\n}\n\nexports.extension_tweak_ed25519_sign_detached = function (sig, m, scalar, pk) {\n  if (sig?.byteLength !== binding.crypto_sign_BYTES) throw new Error('sig')\n  if (scalar?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)\n    throw new Error('scalar')\n  if (pk && pk.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)\n    throw new Error('pk')\n\n  const res = binding.extension_tweak_ed25519_sign_detached(sig, m, scalar, pk)\n  if (res !== 0) throw new Error('failed to compute signature')\n}\n\nexports.extension_tweak_ed25519_sk_to_scalar = function (n, sk) {\n  if (n?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)\n    throw new Error('n')\n  if (sk?.byteLength !== binding.crypto_sign_SECRETKEYBYTES)\n    throw new Error('sk')\n\n  binding.extension_tweak_ed25519_sk_to_scalar(n, sk)\n}\n\nexports.extension_tweak_ed25519_scalar = function (scalarOut, scalar, ns) {\n  if (scalarOut?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)\n    throw new Error('scalar_out')\n  if (scalar?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)\n    throw new Error('scalar')\n\n  binding.extension_tweak_ed25519_scalar(scalarOut, scalar, ns)\n}\n\nexports.extension_tweak_ed25519_pk = function (tpk, pk, ns) {\n  if (tpk?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)\n    throw new Error('tpk')\n  if (pk?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)\n    throw new Error('pk')\n\n  const res = binding.extension_tweak_ed25519_pk(tpk, pk, ns)\n  if (res !== 0) throw new Error('failed to tweak public key')\n}\n\nexports.extension_tweak_ed25519_keypair = function (\n  pk,\n  scalarOut,\n  scalarIn,\n  ns\n) {\n  if (pk?.byteLength !== binding.extension_tweak_ed25519_BYTES)\n    throw new Error('pk')\n  if (scalarOut?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)\n    throw new Error('scalar_out')\n  if (scalarIn?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)\n    throw new Error('scalar_in')\n\n  binding.extension_tweak_ed25519_keypair(pk, scalarOut, scalarIn, ns)\n}\n\nexports.extension_tweak_ed25519_scalar_add = function (scalarOut, scalar, n) {\n  if (scalarOut?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)\n    throw new Error('scalar_out')\n  if (scalar?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)\n    throw new Error('scalar')\n  if (n?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)\n    throw new Error('n')\n\n  binding.extension_tweak_ed25519_scalar_add(scalarOut, scalar, n)\n}\n\nexports.extension_tweak_ed25519_pk_add = function (tpk, pk, p) {\n  if (tpk?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)\n    throw new Error('tpk')\n  if (pk?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES)\n    throw new Error('pk')\n  if (p?.byteLength !== binding.crypto_sign_PUBLICKEYBYTES) throw new Error('p')\n\n  const res = binding.extension_tweak_ed25519_pk_add(tpk, pk, p)\n  if (res !== 0) throw new Error('failed to add tweak to public key')\n}\n\nexports.extension_tweak_ed25519_keypair_add = function (\n  pk,\n  scalarOut,\n  scalarIn,\n  tweak\n) {\n  if (pk?.byteLength !== binding.extension_tweak_ed25519_BYTES)\n    throw new Error('pk')\n  if (scalarOut?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)\n    throw new Error('scalar_out')\n  if (scalarIn?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)\n    throw new Error('scalar_in')\n  if (tweak?.byteLength !== binding.extension_tweak_ed25519_SCALARBYTES)\n    throw new Error('tweak')\n\n  const res = binding.extension_tweak_ed25519_keypair_add(\n    pk,\n    scalarOut,\n    scalarIn,\n    tweak\n  )\n  if (res !== 0) throw new Error('failed to add tweak to keypair')\n}\n\nexports.extension_pbkdf2_sha512_async = function (\n  out,\n  passwd,\n  salt,\n  iter,\n  outlen,\n  callback = undefined\n) {\n  if (iter < binding.extension_pbkdf2_sha512_ITERATIONS_MIN)\n    throw new Error('iterations')\n  if (outlen > binding.extension_pbkdf2_sha512_BYTES_MAX)\n    throw new Error('outlen')\n  if (out?.byteLength < outlen) throw new Error('out')\n  if (!out?.byteLength) throw new Error('out')\n  if (!passwd?.byteLength) throw new Error('passwd')\n  if (!salt?.byteLength) throw new Error('salt')\n\n  const [done, promise] = checkStatus(callback)\n\n  binding.extension_pbkdf2_sha512_async(\n    out.buffer,\n    out.byteOffset,\n    out.byteLength,\n\n    passwd.buffer,\n    passwd.byteOffset,\n    passwd.byteLength,\n\n    salt.buffer,\n    salt.byteOffset,\n    salt.byteLength,\n\n    iter,\n    outlen,\n\n    done\n  )\n\n  return promise\n}\n\nexports.extension_pbkdf2_sha512 = function (out, passwd, salt, iter, outlen) {\n  if (iter < binding.extension_pbkdf2_sha512_ITERATIONS_MIN)\n    throw new Error('iterations')\n  if (outlen > binding.extension_pbkdf2_sha512_BYTES_MAX)\n    throw new Error('outlen')\n  if (out?.byteLength < outlen) throw new Error('out')\n\n  const res = binding.extension_pbkdf2_sha512(out, passwd, salt, iter, outlen)\n\n  if (res !== 0) throw new Error('failed to add tweak to public key')\n}\n\nfunction checkStatus(callback, booleanResult = false) {\n  let done, promise\n\n  if (typeof callback === 'function') {\n    done = function (status) {\n      if (booleanResult) callback(null, status === 0)\n      else if (status === 0) callback(null)\n      else callback(new Error('status: ' + status))\n    }\n  } else {\n    promise = new Promise(function (resolve, reject) {\n      done = function (status) {\n        if (booleanResult) resolve(status === 0)\n        else if (status === 0) resolve()\n        else reject(new Error('status: ' + status))\n      }\n    })\n  }\n\n  return [done, promise]\n}\n{\n  \"name\": \"sodium-native\",\n  \"version\": \"5.0.10\",\n  \"description\": \"Low level bindings for libsodium\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"binding.cc\",\n    \"binding.js\",\n    \"extensions\",\n    \"prebuilds\",\n    \"CMakeLists.txt\"\n  ],\n  \"addon\": true,\n  \"dependencies\": {\n    \"require-addon\": \"^1.1.0\",\n    \"which-runtime\": \"^1.2.1\"\n  },\n  \"devDependencies\": {\n    \"bare-compat-napi\": \"^1.3.5\",\n    \"brittle\": \"^3.16.2\",\n    \"cmake-bare\": \"^1.6.1\",\n    \"cmake-fetch\": \"^1.4.3\",\n    \"cmake-napi\": \"^1.2.1\",\n    \"prettier\": \"^3.6.2\",\n    \"prettier-config-holepunch\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"test\": \"prettier . --check && npm run test:node && npm run test:bare\",\n    \"test:node\": \"node test/all.js\",\n    \"test:bare\": \"bare test/all.js\"\n  },\n  \"standard\": {\n    \"ignore\": [\n      \"/test/fixtures/*.js\"\n    ]\n  },\n  \"engines\": {\n    \"bare\": \">=1.16.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/sodium-native.git\"\n  },\n  \"contributors\": [\n    \"Emil Bay <github@tixz.dk> (http://bayes.dk)\",\n    \"Mathias Buus <mathiasbuus@gmail.com> (https://mafinto.sh)\",\n    \"Christophe Diederichs <chm-diederichs@hyperdivision.dk>\"\n  ],\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/sodium-native/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/sodium-native\"\n}\nconst sodium = require('sodium-universal')\nconst b4a = require('b4a')\n\nconst ABYTES = sodium.crypto_secretstream_xchacha20poly1305_ABYTES\nconst TAG_MESSAGE = sodium.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE\nconst TAG_FINAL = sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL\nconst STATEBYTES = sodium.crypto_secretstream_xchacha20poly1305_STATEBYTES\nconst HEADERBYTES = sodium.crypto_secretstream_xchacha20poly1305_HEADERBYTES\nconst KEYBYTES = sodium.crypto_secretstream_xchacha20poly1305_KEYBYTES\nconst TAG_FINAL_BYTE = b4a.isBuffer(TAG_FINAL) ? TAG_FINAL[0] : TAG_FINAL\n\nconst EMPTY = b4a.alloc(0)\nconst TAG = b4a.alloc(1)\n\nclass Push {\n  constructor (key, state = b4a.allocUnsafeSlow(STATEBYTES), header = b4a.allocUnsafeSlow(HEADERBYTES)) {\n    if (!TAG_FINAL) throw new Error('JavaScript sodium version needs to support crypto_secretstream_xchacha20poly')\n\n    this.key = key\n    this.state = state\n    this.header = header\n\n    sodium.crypto_secretstream_xchacha20poly1305_init_push(this.state, this.header, this.key)\n  }\n\n  next (message, cipher = b4a.allocUnsafe(message.byteLength + ABYTES)) {\n    sodium.crypto_secretstream_xchacha20poly1305_push(this.state, cipher, message, null, TAG_MESSAGE)\n    return cipher\n  }\n\n  final (message = EMPTY, cipher = b4a.allocUnsafe(ABYTES)) {\n    sodium.crypto_secretstream_xchacha20poly1305_push(this.state, cipher, message, null, TAG_FINAL)\n    return cipher\n  }\n}\n\nclass Pull {\n  constructor (key, state = b4a.allocUnsafeSlow(STATEBYTES)) {\n    if (!TAG_FINAL) throw new Error('JavaScript sodium version needs to support crypto_secretstream_xchacha20poly')\n\n    this.key = key\n    this.state = state\n    this.final = false\n  }\n\n  init (header) {\n    sodium.crypto_secretstream_xchacha20poly1305_init_pull(this.state, header, this.key)\n  }\n\n  next (cipher, message = b4a.allocUnsafe(cipher.byteLength - ABYTES)) {\n    sodium.crypto_secretstream_xchacha20poly1305_pull(this.state, message, TAG, cipher, null)\n    this.final = TAG[0] === TAG_FINAL_BYTE\n    return message\n  }\n}\n\nfunction keygen (buf = b4a.alloc(KEYBYTES)) {\n  sodium.crypto_secretstream_xchacha20poly1305_keygen(buf)\n  return buf\n}\n\nmodule.exports = {\n  keygen,\n  KEYBYTES,\n  ABYTES,\n  STATEBYTES,\n  HEADERBYTES,\n  Push,\n  Pull\n}\n{\n  \"name\": \"sodium-secretstream\",\n  \"version\": \"1.2.0\",\n  \"description\": \"Wraps libsodiums secretstream in a higher level abstraction\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"b4a\": \"^1.1.1\",\n    \"sodium-universal\": \"^5.0.0\"\n  },\n  \"devDependencies\": {\n    \"standard\": \"^17.0.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/sodium-secretstream.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/sodium-secretstream/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/sodium-secretstream\"\n}\nmodule.exports = require('sodium-native')\n{\n  \"name\": \"sodium-universal\",\n  \"version\": \"5.0.1\",\n  \"description\": \"Universal wrapper for sodium-javascript and sodium-native working in Node.js and the Browser\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"sodium-native\": \"^5.0.1\"\n  },\n  \"peerDependencies\": {\n    \"sodium-javascript\": \"~0.8.0\"\n  },\n  \"peerDependenciesMeta\": {\n    \"sodium-javascript\": {\n      \"optional\": true\n    }\n  },\n  \"scripts\": {\n    \"prepublish\": \"./build-scripts/generate.js\"\n  },\n  \"browser\": {\n    \"sodium-native\": \"sodium-javascript\"\n  },\n  \"browserify\": {\n    \"transform\": [\n      \"./build-scripts/transform.js\"\n    ]\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/sodium-universal.git\"\n  },\n  \"keywords\": [\n    \"libsodium\",\n    \"sodium\",\n    \"sodium-native\",\n    \"sodium-javascript\",\n    \"browserify\"\n  ],\n  \"contributors\": [\n    \"Emil Bay <github@tixz.dk> (http://bayes.dk)\",\n    \"Mathias Buus <mathiasbuus@gmail.com> (https://mafinto.sh)\",\n    \"Christophe Diederichs <chm-diederichs@hyperdivision.dk>\"\n  ],\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/sodium-universal/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/sodium-universal#readme\"\n}\nconst { EventEmitter } = require('events-universal')\nconst STREAM_DESTROYED = new Error('Stream was destroyed')\nconst PREMATURE_CLOSE = new Error('Premature close')\n\nconst FIFO = require('fast-fifo')\nconst TextDecoder = require('text-decoder')\n\n// if we do a future major, expect queue microtask to be there always, for now a bit defensive\nconst qmt = typeof queueMicrotask === 'undefined' ? fn => global.process.nextTick(fn) : queueMicrotask\n\n/* eslint-disable no-multi-spaces */\n\n// 29 bits used total (4 from shared, 14 from read, and 11 from write)\nconst MAX = ((1 << 29) - 1)\n\n// Shared state\nconst OPENING       = 0b0001\nconst PREDESTROYING = 0b0010\nconst DESTROYING    = 0b0100\nconst DESTROYED     = 0b1000\n\nconst NOT_OPENING = MAX ^ OPENING\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE           = 0b00000000000001 << 4\nconst READ_UPDATING         = 0b00000000000010 << 4\nconst READ_PRIMARY          = 0b00000000000100 << 4\nconst READ_QUEUED           = 0b00000000001000 << 4\nconst READ_RESUMED          = 0b00000000010000 << 4\nconst READ_PIPE_DRAINED     = 0b00000000100000 << 4\nconst READ_ENDING           = 0b00000001000000 << 4\nconst READ_EMIT_DATA        = 0b00000010000000 << 4\nconst READ_EMIT_READABLE    = 0b00000100000000 << 4\nconst READ_EMITTED_READABLE = 0b00001000000000 << 4\nconst READ_DONE             = 0b00010000000000 << 4\nconst READ_NEXT_TICK        = 0b00100000000000 << 4\nconst READ_NEEDS_PUSH       = 0b01000000000000 << 4\nconst READ_READ_AHEAD       = 0b10000000000000 << 4\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED\nconst READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD\n\nconst READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE\nconst READ_NON_PRIMARY            = MAX ^ READ_PRIMARY\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH)\nconst READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH\nconst READ_PAUSED                 = MAX ^ READ_RESUMED\nconst READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE)\nconst READ_NOT_ENDING             = MAX ^ READ_ENDING\nconst READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING\nconst READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK\nconst READ_NOT_UPDATING           = MAX ^ READ_UPDATING\nconst READ_NO_READ_AHEAD          = MAX ^ READ_READ_AHEAD\nconst READ_PAUSED_NO_READ_AHEAD   = MAX ^ READ_RESUMED_READ_AHEAD\n\n// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)\nconst WRITE_ACTIVE     = 0b00000000001 << 18\nconst WRITE_UPDATING   = 0b00000000010 << 18\nconst WRITE_PRIMARY    = 0b00000000100 << 18\nconst WRITE_QUEUED     = 0b00000001000 << 18\nconst WRITE_UNDRAINED  = 0b00000010000 << 18\nconst WRITE_DONE       = 0b00000100000 << 18\nconst WRITE_EMIT_DRAIN = 0b00001000000 << 18\nconst WRITE_NEXT_TICK  = 0b00010000000 << 18\nconst WRITE_WRITING    = 0b00100000000 << 18\nconst WRITE_FINISHING  = 0b01000000000 << 18\nconst WRITE_CORKED     = 0b10000000000 << 18\n\nconst WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING)\nconst WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY\nconst WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING)\nconst WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED\nconst WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK\nconst WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING\nconst WRITE_NOT_CORKED    = MAX ^ WRITE_CORKED\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE\nconst NOT_ACTIVE = MAX ^ ACTIVE\nconst DONE = READ_DONE | WRITE_DONE\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING\nconst OPEN_STATUS = DESTROY_STATUS | OPENING\nconst AUTO_DESTROY = DESTROY_STATUS | DONE\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE\nconst IS_OPENING = OPEN_STATUS | TICKING\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY\nconst READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY\nconst WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS\n\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')\n\nclass WritableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark\n    this.buffered = 0\n    this.error = null\n    this.pipeline = null\n    this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength\n    this.map = mapWritable || map\n    this.afterWrite = afterWrite.bind(this)\n    this.afterUpdateNextTick = updateWriteNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & WRITE_DONE) !== 0\n  }\n\n  push (data) {\n    if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false\n    if (this.map !== null) data = this.map(data)\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED\n      return true\n    }\n\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED\n    return false\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED\n\n    return data\n  }\n\n  end (data) {\n    if (typeof data === 'function') this.stream.once('finish', data)\n    else if (data !== undefined && data !== null) this.push(data)\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY\n  }\n\n  autoBatch (data, cb) {\n    const buffer = []\n    const stream = this.stream\n\n    buffer.push(data)\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift())\n    }\n\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)\n    stream._writev(buffer, cb)\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= WRITE_UPDATING\n\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift()\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING\n        stream._write(data, this.afterWrite)\n      }\n\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= WRITE_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = stream._duplexState | WRITE_ACTIVE\n      stream._final(afterFinal.bind(this))\n      return\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= WRITE_NEXT_TICK\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n}\n\nclass ReadableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark\n    this.buffered = 0\n    this.readAhead = highWaterMark > 0\n    this.error = null\n    this.pipeline = null\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength\n    this.map = mapReadable || map\n    this.pipeTo = null\n    this.afterRead = afterRead.bind(this)\n    this.afterUpdateNextTick = updateReadNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & READ_DONE) !== 0\n  }\n\n  pipe (pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')\n    if (typeof cb !== 'function') cb = null\n\n    this.stream._duplexState |= READ_PIPE_DRAINED\n    this.pipeTo = pipeTo\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb)\n\n    if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline\n      if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo)\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg\n      pipeTo.on('error', onerror)\n      pipeTo.on('close', onclose)\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline))\n    }\n\n    pipeTo.on('drain', afterDrain.bind(this))\n    this.stream.emit('piping', pipeTo)\n    pipeTo.emit('pipe', this.stream)\n  }\n\n  push (data) {\n    const stream = this.stream\n\n    if (data === null) {\n      this.highWaterMark = 0\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED\n      return false\n    }\n\n    if (this.map !== null) {\n      data = this.map(data)\n      if (data === null) {\n        stream._duplexState &= READ_PUSHED\n        return this.buffered < this.highWaterMark\n      }\n    }\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED\n\n    return this.buffered < this.highWaterMark\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED\n    return data\n  }\n\n  unshift (data) {\n    const pending = [this.map !== null ? this.map(data) : data]\n    while (this.buffered > 0) pending.push(this.shift())\n\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i]\n      this.buffered += this.byteLength(data)\n      this.queue.push(data)\n    }\n\n    this.push(pending[pending.length - 1])\n  }\n\n  read () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n      return data\n    }\n\n    if (this.readAhead === false) {\n      stream._duplexState |= READ_READ_AHEAD\n      this.updateNextTick()\n    }\n\n    return null\n  }\n\n  drain () {\n    const stream = this.stream\n\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n    }\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= READ_UPDATING\n\n    do {\n      this.drain()\n\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH\n        stream._read(this.afterRead)\n        this.drain()\n      }\n\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE\n        stream.emit('readable')\n      }\n\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= READ_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING\n      stream.emit('end')\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING\n      if (this.pipeTo !== null) this.pipeTo.end()\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTickIfOpen () {\n    if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n}\n\nclass TransformState {\n  constructor (stream) {\n    this.data = null\n    this.afterTransform = afterTransform.bind(stream)\n    this.afterFinal = null\n  }\n}\n\nclass Pipeline {\n  constructor (src, dst, cb) {\n    this.from = src\n    this.to = dst\n    this.afterPipe = cb\n    this.error = null\n    this.pipeToFinished = false\n  }\n\n  finished () {\n    this.pipeToFinished = true\n  }\n\n  done (stream, err) {\n    if (err) this.error = err\n\n    if (stream === this.to) {\n      this.to = null\n\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'))\n        }\n        return\n      }\n    }\n\n    if (stream === this.from) {\n      this.from = null\n\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'))\n        }\n        return\n      }\n    }\n\n    if (this.afterPipe !== null) this.afterPipe(this.error)\n    this.to = this.from = this.afterPipe = null\n  }\n}\n\nfunction afterDrain () {\n  this.stream._duplexState |= READ_PIPE_DRAINED\n  this.updateCallback()\n}\n\nfunction afterFinal (err) {\n  const stream = this.stream\n  if (err) stream.destroy(err)\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE\n    stream.emit('finish')\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING\n  }\n\n  stream._duplexState &= WRITE_NOT_FINISHING\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update()\n  else this.updateNextTick()\n}\n\nfunction afterDestroy (err) {\n  const stream = this.stream\n\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error\n  if (err) stream.emit('error', err)\n  stream._duplexState |= DESTROYED\n  stream.emit('close')\n\n  const rs = stream._readableState\n  const ws = stream._writableState\n\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err)\n\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false)\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err)\n  }\n}\n\nfunction afterWrite (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  if (this.drains !== null) tickDrains(this.drains)\n\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain')\n    }\n  }\n\n  this.updateCallback()\n}\n\nfunction afterRead (err) {\n  if (err) this.stream.destroy(err)\n  this.stream._duplexState &= READ_NOT_ACTIVE\n  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD\n  this.updateCallback()\n}\n\nfunction updateReadNT () {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction updateWriteNT () {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction tickDrains (drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true)\n      i--\n    }\n  }\n}\n\nfunction afterOpen (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY\n    stream.emit('open')\n  }\n\n  stream._duplexState &= NOT_ACTIVE\n\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback()\n  }\n\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback()\n  }\n}\n\nfunction afterTransform (err, data) {\n  if (data !== undefined && data !== null) this.push(data)\n  this._writableState.afterWrite(err)\n}\n\nfunction newListener (name) {\n  if (this._readableState !== null) {\n    if (name === 'data') {\n      this._duplexState |= (READ_EMIT_DATA | READ_RESUMED_READ_AHEAD)\n      this._readableState.updateNextTick()\n    }\n    if (name === 'readable') {\n      this._duplexState |= READ_EMIT_READABLE\n      this._readableState.updateNextTick()\n    }\n  }\n\n  if (this._writableState !== null) {\n    if (name === 'drain') {\n      this._duplexState |= WRITE_EMIT_DRAIN\n      this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Stream extends EventEmitter {\n  constructor (opts) {\n    super()\n\n    this._duplexState = 0\n    this._readableState = null\n    this._writableState = null\n\n    if (opts) {\n      if (opts.open) this._open = opts.open\n      if (opts.destroy) this._destroy = opts.destroy\n      if (opts.predestroy) this._predestroy = opts.predestroy\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this))\n      }\n    }\n\n    this.on('newListener', newListener)\n  }\n\n  _open (cb) {\n    cb(null)\n  }\n\n  _destroy (cb) {\n    cb(null)\n  }\n\n  _predestroy () {\n    // does nothing\n  }\n\n  get readable () {\n    return this._readableState !== null ? true : undefined\n  }\n\n  get writable () {\n    return this._writableState !== null ? true : undefined\n  }\n\n  get destroyed () {\n    return (this._duplexState & DESTROYED) !== 0\n  }\n\n  get destroying () {\n    return (this._duplexState & DESTROY_STATUS) !== 0\n  }\n\n  destroy (err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY\n\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0\n        this._readableState.error = err\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0\n        this._writableState.error = err\n      }\n\n      this._duplexState |= PREDESTROYING\n      this._predestroy()\n      this._duplexState &= NOT_PREDESTROYING\n\n      if (this._readableState !== null) this._readableState.updateNextTick()\n      if (this._writableState !== null) this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Readable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD\n    this._readableState = new ReadableState(this, opts)\n\n    if (opts) {\n      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD\n      if (opts.read) this._read = opts.read\n      if (opts.eagerOpen) this._readableState.updateNextTick()\n      if (opts.encoding) this.setEncoding(opts.encoding)\n    }\n  }\n\n  setEncoding (encoding) {\n    const dec = new TextDecoder(encoding)\n    const map = this._readableState.map || echo\n    this._readableState.map = mapOrSkip\n    return this\n\n    function mapOrSkip (data) {\n      const next = dec.push(data)\n      return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next)\n    }\n  }\n\n  _read (cb) {\n    cb(null)\n  }\n\n  pipe (dest, cb) {\n    this._readableState.updateNextTick()\n    this._readableState.pipe(dest, cb)\n    return dest\n  }\n\n  read () {\n    this._readableState.updateNextTick()\n    return this._readableState.read()\n  }\n\n  push (data) {\n    this._readableState.updateNextTickIfOpen()\n    return this._readableState.push(data)\n  }\n\n  unshift (data) {\n    this._readableState.updateNextTickIfOpen()\n    return this._readableState.unshift(data)\n  }\n\n  resume () {\n    this._duplexState |= READ_RESUMED_READ_AHEAD\n    this._readableState.updateNextTick()\n    return this\n  }\n\n  pause () {\n    this._duplexState &= (this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED)\n    return this\n  }\n\n  static _fromAsyncIterator (ite, opts) {\n    let destroy\n\n    const rs = new Readable({\n      ...opts,\n      read (cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb)\n      },\n      predestroy () {\n        destroy = ite.return()\n      },\n      destroy (cb) {\n        if (!destroy) return cb(null)\n        destroy.then(cb.bind(null, null)).catch(cb)\n      }\n    })\n\n    return rs\n\n    function push (data) {\n      if (data.done) rs.push(null)\n      else rs.push(data.value)\n    }\n  }\n\n  static from (data, opts) {\n    if (isReadStreamx(data)) return data\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data]\n\n    let i = 0\n    return new Readable({\n      ...opts,\n      read (cb) {\n        this.push(i === data.length ? null : data[i++])\n        cb(null)\n      }\n    })\n  }\n\n  static isBackpressured (rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark\n  }\n\n  static isPaused (rs) {\n    return (rs._duplexState & READ_RESUMED) === 0\n  }\n\n  [asyncIterator] () {\n    const stream = this\n\n    let error = null\n    let promiseResolve = null\n    let promiseReject = null\n\n    this.on('error', (err) => { error = err })\n    this.on('readable', onreadable)\n    this.on('close', onclose)\n\n    return {\n      [asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve\n          promiseReject = reject\n          const data = stream.read()\n          if (data !== null) ondata(data)\n          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null)\n        })\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function onreadable () {\n      if (promiseResolve !== null) ondata(stream.read())\n    }\n\n    function onclose () {\n      if (promiseResolve !== null) ondata(null)\n    }\n\n    function ondata (data) {\n      if (promiseReject === null) return\n      if (error) promiseReject(error)\n      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED)\n      else promiseResolve({ value: data, done: data === null })\n      promiseReject = promiseResolve = null\n    }\n\n    function destroy (err) {\n      stream.destroy(err)\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })\n        stream.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nclass Writable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | READ_DONE\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n      if (opts.eagerOpen) this._writableState.updateNextTick()\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  static isBackpressured (ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0\n  }\n\n  static drained (ws) {\n    if (ws.destroyed) return Promise.resolve(false)\n    const state = ws._writableState\n    const pending = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length)\n    const writes = pending + ((ws._duplexState & WRITE_WRITING) ? 1 : 0)\n    if (writes === 0) return Promise.resolve(true)\n    if (state.drains === null) state.drains = []\n    return new Promise((resolve) => {\n      state.drains.push({ writes, resolve })\n    })\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Duplex extends Readable { // and Writable\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState = OPENING | (this._duplexState & READ_READ_AHEAD)\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Transform extends Duplex {\n  constructor (opts) {\n    super(opts)\n    this._transformState = new TransformState(this)\n\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform\n      if (opts.flush) this._flush = opts.flush\n    }\n  }\n\n  _write (data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data\n    } else {\n      this._transform(data, this._transformState.afterTransform)\n    }\n  }\n\n  _read (cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data\n      this._transformState.data = null\n      cb(null)\n      this._transform(data, this._transformState.afterTransform)\n    } else {\n      cb(null)\n    }\n  }\n\n  destroy (err) {\n    super.destroy(err)\n    if (this._transformState.data !== null) {\n      this._transformState.data = null\n      this._transformState.afterTransform()\n    }\n  }\n\n  _transform (data, cb) {\n    cb(null, data)\n  }\n\n  _flush (cb) {\n    cb(null)\n  }\n\n  _final (cb) {\n    this._transformState.afterFinal = cb\n    this._flush(transformAfterFlush.bind(this))\n  }\n}\n\nclass PassThrough extends Transform {}\n\nfunction transformAfterFlush (err, data) {\n  const cb = this._transformState.afterFinal\n  if (err) return cb(err)\n  if (data !== null && data !== undefined) this.push(data)\n  this.push(null)\n  cb(null)\n}\n\nfunction pipelinePromise (...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n\nfunction pipeline (stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams]\n  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null\n\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')\n\n  let src = all[0]\n  let dest = null\n  let error = null\n\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i]\n\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror)\n    } else {\n      errorHandle(src, true, i > 1, onerror)\n      src.pipe(dest)\n    }\n\n    src = dest\n  }\n\n  if (done) {\n    let fin = false\n\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy)\n\n    dest.on('error', (err) => {\n      if (error === null) error = err\n    })\n\n    dest.on('finish', () => {\n      fin = true\n      if (!autoDestroy) done(error)\n    })\n\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)))\n    }\n  }\n\n  return dest\n\n  function errorHandle (s, rd, wr, onerror) {\n    s.on('error', onerror)\n    s.on('close', onclose)\n\n    function onclose () {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)\n    }\n  }\n\n  function onerror (err) {\n    if (!err || error) return\n    error = err\n\n    for (const s of all) {\n      s.destroy(err)\n    }\n  }\n}\n\nfunction echo (s) {\n  return s\n}\n\nfunction isStream (stream) {\n  return !!stream._readableState || !!stream._writableState\n}\n\nfunction isStreamx (stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream)\n}\n\nfunction isEnded (stream) {\n  return !!stream._readableState && stream._readableState.ended\n}\n\nfunction isFinished (stream) {\n  return !!stream._writableState && stream._writableState.ended\n}\n\nfunction getStreamError (stream, opts = {}) {\n  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error)\n\n  // avoid implicit errors by default\n  return (!opts.all && err === STREAM_DESTROYED) ? null : err\n}\n\nfunction isReadStreamx (stream) {\n  return isStreamx(stream) && stream.readable\n}\n\nfunction isDisturbed (stream) {\n  return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0\n}\n\nfunction isTypedArray (data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'\n}\n\nfunction defaultByteLength (data) {\n  return isTypedArray(data) ? data.byteLength : 1024\n}\n\nfunction noop () {}\n\nfunction abort () {\n  this.destroy(new Error('Stream aborted.'))\n}\n\nfunction isWritev (s) {\n  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev\n}\n\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  isEnded,\n  isFinished,\n  isDisturbed,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n}\n{\n  \"name\": \"streamx\",\n  \"version\": \"2.23.0\",\n  \"description\": \"An iteration of the Node.js core streams with a series of improvements\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"events-universal\": \"^1.0.0\",\n    \"fast-fifo\": \"^1.3.2\",\n    \"text-decoder\": \"^1.1.0\"\n  },\n  \"devDependencies\": {\n    \"b4a\": \"^1.6.6\",\n    \"brittle\": \"^3.1.1\",\n    \"end-of-stream\": \"^1.4.4\",\n    \"standard\": \"^17.0.0\"\n  },\n  \"files\": [\n    \"index.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"standard && node test/all.js\",\n    \"test:bare\": \"standard && bare test/all.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/streamx.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/streamx/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/streamx\"\n}\nconst PassThroughDecoder = require('./lib/pass-through-decoder')\nconst UTF8Decoder = require('./lib/utf8-decoder')\n\nmodule.exports = class TextDecoder {\n  constructor (encoding = 'utf8') {\n    this.encoding = normalizeEncoding(encoding)\n\n    switch (this.encoding) {\n      case 'utf8':\n        this.decoder = new UTF8Decoder()\n        break\n      case 'utf16le':\n      case 'base64':\n        throw new Error('Unsupported encoding: ' + this.encoding)\n      default:\n        this.decoder = new PassThroughDecoder(this.encoding)\n    }\n  }\n\n  get remaining () {\n    return this.decoder.remaining\n  }\n\n  push (data) {\n    if (typeof data === 'string') return data\n    return this.decoder.decode(data)\n  }\n\n  // For Node.js compatibility\n  write (data) {\n    return this.push(data)\n  }\n\n  end (data) {\n    let result = ''\n    if (data) result = this.push(data)\n    result += this.decoder.flush()\n    return result\n  }\n}\n\nfunction normalizeEncoding (encoding) {\n  encoding = encoding.toLowerCase()\n\n  switch (encoding) {\n    case 'utf8':\n    case 'utf-8':\n      return 'utf8'\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return 'utf16le'\n    case 'latin1':\n    case 'binary':\n      return 'latin1'\n    case 'base64':\n    case 'ascii':\n    case 'hex':\n      return encoding\n    default:\n      throw new Error('Unknown encoding: ' + encoding)\n  }\n};\nconst b4a = require('b4a')\n\nmodule.exports = class PassThroughDecoder {\n  constructor (encoding) {\n    this.encoding = encoding\n  }\n\n  get remaining () {\n    return 0\n  }\n\n  decode (tail) {\n    return b4a.toString(tail, this.encoding)\n  }\n\n  flush () {\n    return ''\n  }\n}\nconst b4a = require('b4a')\n\n/**\n * https://encoding.spec.whatwg.org/#utf-8-decoder\n */\nmodule.exports = class UTF8Decoder {\n  constructor () {\n    this.codePoint = 0\n    this.bytesSeen = 0\n    this.bytesNeeded = 0\n    this.lowerBoundary = 0x80\n    this.upperBoundary = 0xbf\n  }\n\n  get remaining () {\n    return this.bytesSeen\n  }\n\n  decode (data) {\n    // If we have a fast path, just sniff if the last part is a boundary\n    if (this.bytesNeeded === 0) {\n      let isBoundary = true\n\n      for (let i = Math.max(0, data.byteLength - 4), n = data.byteLength; i < n && isBoundary; i++) {\n        isBoundary = data[i] <= 0x7f\n      }\n\n      if (isBoundary) return b4a.toString(data, 'utf8')\n    }\n\n    let result = ''\n\n    for (let i = 0, n = data.byteLength; i < n; i++) {\n      const byte = data[i]\n\n      if (this.bytesNeeded === 0) {\n        if (byte <= 0x7f) {\n          result += String.fromCharCode(byte)\n        } else {\n          this.bytesSeen = 1\n\n          if (byte >= 0xc2 && byte <= 0xdf) {\n            this.bytesNeeded = 2\n            this.codePoint = byte & 0x1f\n          } else if (byte >= 0xe0 && byte <= 0xef) {\n            if (byte === 0xe0) this.lowerBoundary = 0xa0\n            else if (byte === 0xed) this.upperBoundary = 0x9f\n            this.bytesNeeded = 3\n            this.codePoint = byte & 0xf\n          } else if (byte >= 0xf0 && byte <= 0xf4) {\n            if (byte === 0xf0) this.lowerBoundary = 0x90\n            if (byte === 0xf4) this.upperBoundary = 0x8f\n            this.bytesNeeded = 4\n            this.codePoint = byte & 0x7\n          } else {\n            result += '\\ufffd'\n          }\n        }\n\n        continue\n      }\n\n      if (byte < this.lowerBoundary || byte > this.upperBoundary) {\n        this.codePoint = 0\n        this.bytesNeeded = 0\n        this.bytesSeen = 0\n        this.lowerBoundary = 0x80\n        this.upperBoundary = 0xbf\n\n        result += '\\ufffd'\n\n        continue\n      }\n\n      this.lowerBoundary = 0x80\n      this.upperBoundary = 0xbf\n\n      this.codePoint = (this.codePoint << 6) | (byte & 0x3f)\n      this.bytesSeen++\n\n      if (this.bytesSeen !== this.bytesNeeded) continue\n\n      result += String.fromCodePoint(this.codePoint)\n\n      this.codePoint = 0\n      this.bytesNeeded = 0\n      this.bytesSeen = 0\n    }\n\n    return result\n  }\n\n  flush () {\n    const result = this.bytesNeeded > 0 ? '\\ufffd' : ''\n\n    this.codePoint = 0\n    this.bytesNeeded = 0\n    this.bytesSeen = 0\n    this.lowerBoundary = 0x80\n    this.upperBoundary = 0xbf\n\n    return result\n  }\n}\n{\n  \"name\": \"text-decoder\",\n  \"version\": \"1.2.3\",\n  \"description\": \"Streaming text decoder that preserves multibyte Unicode characters\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\",\n    \"lib\"\n  ],\n  \"browser\": {\n    \"./lib/pass-through-decoder.js\": \"./lib/browser-decoder.js\",\n    \"./lib/utf8-decoder.js\": \"./lib/browser-decoder.js\"\n  },\n  \"react-native\": {\n    \"./lib/pass-through-decoder.js\": \"./lib/pass-through-decoder.js\",\n    \"./lib/utf8-decoder.js\": \"./lib/utf8-decoder.js\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/text-decoder.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/text-decoder/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/text-decoder#readme\",\n  \"dependencies\": {\n    \"b4a\": \"^1.6.4\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"standard\": \"^17.0.0\"\n  }\n}\nmodule.exports = class TimeOrderedSet {\n  constructor () {\n    this.oldest = null\n    this.latest = null\n    this.length = 0\n  }\n\n  has (node) {\n    return !!(node.next || node.prev) || node === this.oldest\n  }\n\n  add (node) {\n    if (this.has(node)) this.remove(node)\n\n    if (!this.latest && !this.oldest) {\n      this.latest = this.oldest = node\n      node.prev = node.next = null\n    } else {\n      this.latest.next = node\n      node.prev = this.latest\n      node.next = null\n      this.latest = node\n    }\n\n    this.length++\n\n    return node\n  }\n\n  remove (node) {\n    if (!this.has(node)) return node\n\n    if (this.oldest !== node && this.latest !== node) {\n      node.prev.next = node.next\n      node.next.prev = node.prev\n    } else {\n      if (this.oldest === node) {\n        this.oldest = node.next\n        if (this.oldest) this.oldest.prev = null\n      }\n      if (this.latest === node) {\n        this.latest = node.prev\n        if (this.latest) this.latest.next = null\n      }\n    }\n\n    node.next = node.prev = null\n    this.length--\n\n    return node\n  }\n\n  toArray ({ limit = Infinity, reverse = false } = {}) {\n    const list = []\n\n    if (reverse) {\n      let node = this.latest\n      while (node && limit--) {\n        list.push(node)\n        node = node.prev\n      }\n    } else {\n      let node = this.oldest\n      while (node && limit--) {\n        list.push(node)\n        node = node.next\n      }\n    }\n\n    return list\n  }\n}\n{\n  \"name\": \"time-ordered-set\",\n  \"version\": \"2.0.1\",\n  \"description\": \"Efficiently maintain a set of nodes ordered by the time they were added to the set\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"devDependencies\": {\n    \"brittle\": \"^3.0.0\",\n    \"standard\": \"^17.1.2\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/time-ordered-set.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/time-ordered-set/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/time-ordered-set\"\n}\nmodule.exports = class TimerBrowser {\n  constructor (ms, fn, ctx = null, interval = false) {\n    this.ms = ms\n    this.ontimeout = fn\n    this.context = ctx || null\n    this.interval = interval\n    this.done = false\n\n    this._timer = interval\n      ? setInterval(callInterval, ms, this)\n      : setTimeout(callTimeout, ms, this)\n  }\n\n  unref () {}\n\n  ref () {}\n\n  refresh () {\n    if (this.done) return\n\n    if (this.interval) {\n      clearInterval(this._timer)\n      this._timer = setInterval(callInterval, this.ms, this)\n    } else {\n      clearTimeout(this._timer)\n      this._timer = setTimeout(callTimeout, this.ms, this)\n    }\n  }\n\n  destroy () {\n    this.done = true\n    this.ontimeout = null\n\n    if (this.interval) clearInterval(this._timer)\n    else clearTimeout(this._timer)\n  }\n\n  static once (ms, fn, ctx) {\n    return new this(ms, fn, ctx, false)\n  }\n\n  static on (ms, fn, ctx) {\n    return new this(ms, fn, ctx, true)\n  }\n}\n\nfunction callTimeout (self) {\n  self.done = true\n  self.ontimeout.call(self.context)\n}\n\nfunction callInterval (self) {\n  self.ontimeout.call(self.context)\n}\nmodule.exports = isNode()\n  ? require('./node')\n  : require('./browser')\n\nfunction isNode () {\n  const to = setTimeout(function () {}, 1000)\n  clearTimeout(to)\n  return !!to.refresh\n}\nmodule.exports = class Timer {\n  constructor (ms, fn, ctx = null, interval = false) {\n    this.ms = ms\n    this.ontimeout = fn\n    this.context = ctx\n    this.interval = interval\n    this.done = false\n\n    this._timer = interval\n      ? setInterval(callInterval, ms, this)\n      : setTimeout(callTimeout, ms, this)\n  }\n\n  unref () {\n    this._timer.unref()\n  }\n\n  ref () {\n    this._timer.ref()\n  }\n\n  refresh () {\n    if (this.done !== true) this._timer.refresh()\n  }\n\n  destroy () {\n    this.done = true\n    this.ontimeout = null\n    if (this.interval) clearInterval(this._timer)\n    else clearTimeout(this._timer)\n  }\n\n  static once (ms, fn, ctx) {\n    return new this(ms, fn, ctx, false)\n  }\n\n  static on (ms, fn, ctx) {\n    return new this(ms, fn, ctx, true)\n  }\n}\n\nfunction callTimeout (self) {\n  self.done = true\n  self.ontimeout.call(self.context)\n}\n\nfunction callInterval (self) {\n  self.ontimeout.call(self.context)\n}\n{\n  \"name\": \"timeout-refresh\",\n  \"version\": \"2.0.1\",\n  \"description\": \"Efficiently refresh a timer\",\n  \"main\": \"index.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"standard\": \"^16.0.4\",\n    \"tape\": \"^5.5.2\"\n  },\n  \"browser\": \"./browser.js\",\n  \"scripts\": {\n    \"test\": \"standard && tape test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/timeout-refresh.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/timeout-refresh/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/timeout-refresh\"\n}\nrequire.addon = require('require-addon')\n\nmodule.exports = require.addon('.', __filename)\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nconst v4Seg = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'\nconst v4Str = `(${v4Seg}[.]){3}${v4Seg}`\nconst IPv4Pattern = new RegExp(`^${v4Str}$`)\n\nconst v6Seg = '(?:[0-9a-fA-F]{1,4})'\nconst IPv6Pattern = new RegExp(\n  '^(' +\n    `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` +\n    `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` +\n    `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|` +\n    `(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|` +\n    `(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|` +\n    `(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|` +\n    `(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|` +\n    `(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:))` +\n    ')(%[0-9a-zA-Z-.:]{1,})?$'\n)\n\nconst isIPv4 = (exports.isIPv4 = function isIPv4(host) {\n  return IPv4Pattern.test(host)\n})\n\nconst isIPv6 = (exports.isIPv6 = function isIPv6(host) {\n  return IPv6Pattern.test(host)\n})\n\nexports.isIP = function isIP(host) {\n  if (isIPv4(host)) return 4\n  if (isIPv6(host)) return 6\n  return 0\n}\nconst events = require('events')\nconst b4a = require('b4a')\nconst binding = require('../binding')\n\nmodule.exports = class NetworkInterfaces extends events.EventEmitter {\n  constructor(udx) {\n    super()\n\n    this._handle = b4a.alloc(binding.sizeof_udx_napi_interface_event_t)\n    this._watching = false\n    this._destroying = null\n\n    binding.udx_napi_interface_event_init(\n      udx._handle,\n      this._handle,\n      this,\n      this._onevent,\n      this._onclose\n    )\n\n    this.interfaces = binding.udx_napi_interface_event_get_addrs(this._handle)\n  }\n\n  _onclose() {\n    this.emit('close')\n  }\n\n  _onevent() {\n    this.interfaces = binding.udx_napi_interface_event_get_addrs(this._handle)\n\n    this.emit('change', this.interfaces)\n  }\n\n  watch() {\n    if (this._watching) return this\n    this._watching = true\n\n    binding.udx_napi_interface_event_start(this._handle)\n\n    return this\n  }\n\n  unwatch() {\n    if (!this._watching) return this\n    this._watching = false\n\n    binding.udx_napi_interface_event_stop(this._handle)\n\n    return this\n  }\n\n  async destroy() {\n    if (this._destroying) return this._destroying\n    this._destroying = events.once(this, 'close')\n\n    binding.udx_napi_interface_event_close(this._handle)\n\n    return this._destroying\n  }\n\n  [Symbol.iterator]() {\n    return this.interfaces[Symbol.iterator]()\n  }\n}\nconst events = require('events')\nconst b4a = require('b4a')\nconst binding = require('../binding')\nconst ip = require('./ip')\n\nmodule.exports = class UDXSocket extends events.EventEmitter {\n  constructor(udx, opts = {}) {\n    super()\n\n    this.udx = udx\n\n    this._handle = b4a.alloc(binding.sizeof_udx_napi_socket_t)\n    this._inited = false\n    this._host = null\n    this._family = 0\n    this._ipv6Only = opts.ipv6Only === true\n    this._reuseAddress = opts.reuseAddress === true\n    this._port = 0\n    this._reqs = []\n    this._free = []\n    this._closing = null\n    this._closed = false\n\n    this._view64 = new BigUint64Array(\n      this._handle.buffer,\n      this._handle.byteOffset,\n      this._handle.byteLength >> 3\n    )\n\n    this.streams = new Set()\n\n    this.userData = null\n  }\n\n  get bound() {\n    return this._port !== 0\n  }\n\n  get closing() {\n    return this._closing !== null\n  }\n\n  get idle() {\n    return this.streams.size === 0\n  }\n\n  get busy() {\n    return this.streams.size > 0\n  }\n\n  get bytesTransmitted() {\n    if (this._inited !== true) return 0\n    return Number(this._view64[binding.offsetof_udx_socket_t_bytes_tx >> 3])\n  }\n\n  get packetsTransmitted() {\n    if (this._inited !== true) return 0\n    return Number(this._view64[binding.offsetof_udx_socket_t_packets_tx >> 3])\n  }\n\n  get bytesReceived() {\n    if (this._inited !== true) return 0\n    return Number(this._view64[binding.offsetof_udx_socket_t_bytes_rx >> 3])\n  }\n\n  get packetsReceived() {\n    if (this._inited !== true) return 0\n    return Number(this._view64[binding.offsetof_udx_socket_t_packets_rx >> 3])\n  }\n\n  get packetsDroppedByKernel() {\n    if (this._inited !== true) return 0\n    return Number(this._view64[binding.offsetof_udx_socket_t_packets_dropped_by_kernel >> 3])\n  }\n\n  toJSON() {\n    return {\n      bound: this.bound,\n      closing: this.closing,\n      streams: this.streams.size,\n      address: this.address(),\n      ipv6Only: this._ipv6Only,\n      reuseAddress: this._reuseAddress,\n      idle: this.idle,\n      busy: this.busy\n    }\n  }\n\n  _init() {\n    if (this._inited) return\n\n    binding.udx_napi_socket_init(\n      this.udx._handle,\n      this._handle,\n      this,\n      this._onsend,\n      this._onmessage,\n      this._onclose,\n      this._reallocMessage\n    )\n\n    this._inited = true\n  }\n\n  _onsend(id, err) {\n    const req = this._reqs[id]\n\n    const onflush = req.onflush\n\n    req.buffer = null\n    req.onflush = null\n\n    this._free.push(id)\n\n    onflush(err >= 0)\n\n    // gc the free list\n    if (this._free.length >= 16 && this._free.length === this._reqs.length) {\n      this._free = []\n      this._reqs = []\n    }\n  }\n\n  _onmessage(len, port, host, family) {\n    this.emit('message', this.udx._consumeMessage(len), { host, family, port })\n    return this.udx._buffer\n  }\n\n  _onclose() {\n    this.emit('close')\n  }\n\n  _reallocMessage() {\n    return this.udx._reallocMessage()\n  }\n\n  _onidle() {\n    this.emit('idle')\n  }\n\n  _onbusy() {\n    this.emit('busy')\n  }\n\n  _addStream(stream) {\n    if (this.streams.has(stream)) return false\n    this.streams.add(stream)\n    if (this.streams.size === 1) this._onbusy()\n    return true\n  }\n\n  _removeStream(stream) {\n    if (!this.streams.has(stream)) return false\n    this.streams.delete(stream)\n    const closed = this._closeMaybe()\n    if (this.idle && !closed) this._onidle()\n    return true\n  }\n\n  address() {\n    if (!this.bound) return null\n    return { host: this._host, family: this._family, port: this._port }\n  }\n\n  bind(port, host) {\n    if (this.bound) throw new Error('Already bound')\n    if (this.closing) throw new Error('Socket is closed')\n\n    if (!port) port = 0\n\n    let flags = 0\n    if (this._ipv6Only) flags |= binding.UV_UDP_IPV6ONLY\n    if (this._reuseAddress) flags |= binding.UV_UDP_REUSEADDR\n\n    let family\n\n    if (host) {\n      family = ip.isIP(host)\n      if (!family) throw new Error(`${host} is not a valid IP address`)\n\n      if (!this._inited) this._init()\n\n      this._port = binding.udx_napi_socket_bind(this._handle, port, host, family, flags)\n    } else {\n      if (!this._inited) this._init()\n\n      try {\n        host = '::'\n        family = 6\n        this._port = binding.udx_napi_socket_bind(this._handle, port, host, family, flags)\n      } catch {\n        host = '0.0.0.0'\n        family = 4\n        this._port = binding.udx_napi_socket_bind(this._handle, port, host, family, flags)\n      }\n    }\n\n    this._host = host\n    this._family = family\n\n    this.emit('listening')\n  }\n\n  async close() {\n    if (this._closing) return this._closing\n    this._closing = new Promise((resolve) => this.once('close', resolve))\n    this._closeMaybe()\n    return this._closing\n  }\n\n  _closeMaybe() {\n    if (this._closed || this._closing === null) return this._closed\n\n    if (!this._inited) {\n      this._closed = true\n      this.emit('close')\n      return true\n    }\n\n    if (this.idle) {\n      binding.udx_napi_socket_close(this._handle)\n      this._closed = true\n    }\n\n    return this._closed\n  }\n\n  setTTL(ttl) {\n    if (!this._inited) throw new Error('Socket not active')\n    binding.udx_napi_socket_set_ttl(this._handle, ttl)\n  }\n\n  getRecvBufferSize() {\n    if (!this._inited) throw new Error('Socket not active')\n    return binding.udx_napi_socket_get_recv_buffer_size(this._handle)\n  }\n\n  setRecvBufferSize(size) {\n    if (!this._inited) throw new Error('Socket not active')\n    return binding.udx_napi_socket_set_recv_buffer_size(this._handle, size)\n  }\n\n  getSendBufferSize() {\n    if (!this._inited) throw new Error('Socket not active')\n    return binding.udx_napi_socket_get_send_buffer_size(this._handle)\n  }\n\n  setSendBufferSize(size) {\n    if (!this._inited) throw new Error('Socket not active')\n    return binding.udx_napi_socket_set_send_buffer_size(this._handle, size)\n  }\n\n  addMembership(group, ifaceAddress) {\n    if (!this._inited) throw new Error('Socket not active')\n    return binding.udx_napi_socket_set_membership(this._handle, group, ifaceAddress || '', true)\n  }\n\n  dropMembership(group, ifaceAddress) {\n    if (!this._inited) throw new Error('Socket not active')\n    return binding.udx_napi_socket_set_membership(this._handle, group, ifaceAddress || '', false)\n  }\n\n  async send(buffer, port, host, ttl) {\n    if (this.closing) return false\n\n    if (!host) host = '127.0.0.1'\n\n    const family = ip.isIP(host)\n    if (!family) throw new Error(`${host} is not a valid IP address`)\n\n    if (!this.bound) this.bind(0)\n\n    const id = this._allocSend()\n    const req = this._reqs[id]\n\n    req.buffer = buffer\n\n    const promise = new Promise((resolve) => {\n      req.onflush = resolve\n    })\n\n    binding.udx_napi_socket_send_ttl(\n      this._handle,\n      req.handle,\n      id,\n      buffer,\n      port,\n      host,\n      family,\n      ttl || 0\n    )\n\n    return promise\n  }\n\n  trySend(buffer, port, host, ttl) {\n    if (this.closing) return\n\n    if (!host) host = '127.0.0.1'\n\n    const family = ip.isIP(host)\n    if (!family) throw new Error(`${host} is not a valid IP address`)\n\n    if (!this.bound) this.bind(0)\n\n    const id = this._allocSend()\n    const req = this._reqs[id]\n\n    req.buffer = buffer\n    req.onflush = noop\n\n    binding.udx_napi_socket_send_ttl(\n      this._handle,\n      req.handle,\n      id,\n      buffer,\n      port,\n      host,\n      family,\n      ttl || 0\n    )\n  }\n\n  _allocSend() {\n    if (this._free.length > 0) return this._free.pop()\n    const handle = b4a.allocUnsafe(binding.sizeof_udx_socket_send_t)\n    return this._reqs.push({ handle, buffer: null, onflush: null }) - 1\n  }\n}\n\nfunction noop() {}\nconst streamx = require('streamx')\nconst b4a = require('b4a')\nconst binding = require('../binding')\nconst ip = require('./ip')\n\nconst MAX_PACKET = 2048\nconst BUFFER_SIZE = 65536 + MAX_PACKET\n\nmodule.exports = class UDXStream extends streamx.Duplex {\n  constructor(udx, id, opts = {}) {\n    super({ mapWritable: toBuffer, eagerOpen: true })\n\n    this.udx = udx\n    this.socket = null\n\n    this._handle = b4a.alloc(binding.sizeof_udx_napi_stream_t)\n    this._view = new Uint32Array(\n      this._handle.buffer,\n      this._handle.byteOffset,\n      this._handle.byteLength >> 2\n    )\n    this._view16 = new Uint16Array(\n      this._handle.buffer,\n      this._handle.byteOffset,\n      this._handle.byteLength >> 1\n    )\n    this._view64 = new BigUint64Array(\n      this._handle.buffer,\n      this._handle.byteOffset,\n      this._handle.byteLength >> 3\n    )\n\n    this._wreqs = []\n    this._wfree = []\n\n    this._sreqs = []\n    this._sfree = []\n    this._closed = false\n\n    this._flushing = 0\n    this._flushes = []\n\n    this._buffer = null\n    this._reallocData()\n\n    this._onwrite = null\n    this._ondestroy = null\n    this._firewall = opts.firewall || firewallAll\n\n    this._remoteChanging = null\n    this._previousSocket = null\n\n    this.id = id\n    this.remoteId = 0\n    this.remoteHost = null\n    this.remoteFamily = 0\n    this.remotePort = 0\n\n    this.userData = null\n\n    binding.udx_napi_stream_init(\n      this.udx._handle,\n      this._handle,\n      id,\n      opts.framed ? 1 : 0,\n      this,\n      this._ondata,\n      this._onend,\n      this._ondrain,\n      this._onack,\n      this._onsend,\n      this._onmessage,\n      this._onclose,\n      this._onfirewall,\n      this._onremotechanged,\n      this._reallocData,\n      this._reallocMessage\n    )\n\n    if (opts.seq) binding.udx_napi_stream_set_seq(this._handle, opts.seq)\n\n    binding.udx_napi_stream_recv_start(this._handle, this._buffer)\n  }\n\n  get connected() {\n    return this.socket !== null\n  }\n\n  get mtu() {\n    return this._view16[binding.offsetof_udx_stream_t_mtu >> 1]\n  }\n\n  get rtt() {\n    return this._view[binding.offsetof_udx_stream_t_srtt >> 2]\n  }\n\n  get cwnd() {\n    return this._view[binding.offsetof_udx_stream_t_cwnd >> 2]\n  }\n\n  get rtoCount() {\n    return this._view16[binding.offsetof_udx_stream_t_rto_count >> 1]\n  }\n\n  get retransmits() {\n    return this._view16[binding.offsetof_udx_stream_t_retransmit_count >> 1]\n  }\n\n  get fastRecoveries() {\n    return this._view16[binding.offsetof_udx_stream_t_fast_recovery_count >> 1]\n  }\n\n  get inflight() {\n    return this._view[binding.offsetof_udx_stream_t_inflight >> 2]\n  }\n\n  get bytesTransmitted() {\n    return Number(this._view64[binding.offsetof_udx_stream_t_bytes_tx >> 3])\n  }\n\n  get packetsTransmitted() {\n    return Number(this._view64[binding.offsetof_udx_stream_t_packets_tx >> 3])\n  }\n\n  get bytesReceived() {\n    return Number(this._view64[binding.offsetof_udx_stream_t_bytes_rx >> 3])\n  }\n\n  get packetsReceived() {\n    return Number(this._view64[binding.offsetof_udx_stream_t_packets_rx >> 3])\n  }\n\n  get localHost() {\n    return this.socket ? this.socket.address().host : null\n  }\n\n  get localFamily() {\n    return this.socket ? this.socket.address().family : 0\n  }\n\n  get localPort() {\n    return this.socket ? this.socket.address().port : 0\n  }\n\n  setInteractive(bool) {\n    if (!this._closed) return\n    binding.udx_napi_stream_set_mode(this._handle, bool ? 0 : 1)\n  }\n\n  connect(socket, remoteId, port, host, opts = {}) {\n    if (this._closed) return\n\n    if (this.connected) throw new Error('Already connected')\n    if (socket.closing) throw new Error('Socket is closed')\n\n    if (typeof host === 'object') {\n      opts = host\n      host = null\n    }\n\n    if (!host) host = '127.0.0.1'\n\n    const family = ip.isIP(host)\n    if (!family) throw new Error(`${host} is not a valid IP address`)\n    if (!(port > 0 && port < 65536)) throw new Error(`${port} is not a valid port`)\n\n    if (!socket.bound) socket.bind(0)\n\n    this.remoteId = remoteId\n    this.remotePort = port\n    this.remoteHost = host\n    this.remoteFamily = family\n    this.socket = socket\n\n    if (opts.ack) binding.udx_napi_stream_set_ack(this._handle, opts.ack)\n\n    binding.udx_napi_stream_connect(this._handle, socket._handle, remoteId, port, host, family)\n\n    this.socket._addStream(this)\n\n    this.emit('connect')\n  }\n\n  changeRemote(socket, remoteId, port, host) {\n    if (this._remoteChanging) throw new Error('Remote already changing')\n\n    if (!this.connected) throw new Error('Not yet connected')\n    if (socket.closing) throw new Error('Socket is closed')\n\n    if (this.socket.udx !== socket.udx) {\n      throw new Error('Cannot change to a socket on another UDX instance')\n    }\n\n    if (!host) host = '127.0.0.1'\n\n    const family = ip.isIP(host)\n    if (!family) throw new Error(`${host} is not a valid IP address`)\n    if (!(port > 0 && port < 65536)) throw new Error(`${port} is not a valid port`)\n\n    if (this.socket !== socket) this._previousSocket = this.socket\n\n    this.remoteId = remoteId\n    this.remotePort = port\n    this.remoteHost = host\n    this.remoteFamily = family\n    this.socket = socket\n\n    this._remoteChanging = new Promise((resolve, reject) => {\n      const onchanged = () => {\n        this.off('close', onclose)\n        resolve()\n      }\n\n      const onclose = () => {\n        this.off('remote-changed', onchanged)\n        reject(new Error('Stream is closed'))\n      }\n\n      this.once('remote-changed', onchanged).once('close', onclose)\n    })\n\n    binding.udx_napi_stream_change_remote(\n      this._handle,\n      socket._handle,\n      remoteId,\n      port,\n      host,\n      family\n    )\n\n    this.socket._addStream(this)\n\n    return this._remoteChanging\n  }\n\n  relayTo(destination) {\n    if (this._closed) return\n\n    binding.udx_napi_stream_relay_to(this._handle, destination._handle)\n  }\n\n  async send(buffer) {\n    if (!this.connected || this._closed) return false\n\n    const id = this._allocSend()\n    const req = this._sreqs[id]\n\n    req.buffer = buffer\n\n    const promise = new Promise((resolve) => {\n      req.onflush = resolve\n    })\n\n    binding.udx_napi_stream_send(this._handle, req.handle, id, buffer)\n\n    return promise\n  }\n\n  trySend(buffer) {\n    if (!this.connected || this._closed) return\n\n    const id = this._allocSend()\n    const req = this._sreqs[id]\n\n    req.buffer = buffer\n    req.onflush = noop\n\n    binding.udx_napi_stream_send(this._handle, req.handle, id, buffer)\n  }\n\n  async flush() {\n    if ((await streamx.Writable.drained(this)) === false) return false\n    if (this.destroying) return false\n\n    const missing = this._wreqs.length - this._wfree.length\n    if (missing === 0) return true\n\n    return new Promise((resolve) => {\n      this._flushes.push({ flush: this._flushing++, missing, resolve })\n    })\n  }\n\n  toJSON() {\n    return {\n      id: this.id,\n      connected: this.connected,\n      destroying: this.destroying,\n      destroyed: this.destroyed,\n      remoteId: this.remoteId,\n      remoteHost: this.remoteHost,\n      remoteFamily: this.remoteFamily,\n      remotePort: this.remotePort,\n      mtu: this.mtu,\n      rtt: this.rtt,\n      cwnd: this.cwnd,\n      inflight: this.inflight,\n      socket: this.socket ? this.socket.toJSON() : null\n    }\n  }\n\n  _read(cb) {\n    cb(null)\n  }\n\n  _writeContinue(err) {\n    if (this._onwrite === null) return\n    const cb = this._onwrite\n    this._onwrite = null\n    cb(err)\n  }\n\n  _destroyContinue(err) {\n    if (this._ondestroy === null) return\n    const cb = this._ondestroy\n    this._ondestroy = null\n    cb(err)\n  }\n\n  _writev(buffers, cb) {\n    if (!this.connected)\n      throw customError('Writing while not connected not currently supported', 'ERR_ASSERTION')\n\n    let drained = true\n\n    if (buffers.length === 1) {\n      const id = this._allocWrite(1)\n      const req = this._wreqs[id]\n\n      req.flush = this._flushing\n      req.buffer = buffers[0]\n\n      drained = binding.udx_napi_stream_write(this._handle, req.handle, id, req.buffer) !== 0\n    } else {\n      const id = this._allocWrite(nextBatchSize(buffers.length))\n      const req = this._wreqs[id]\n\n      req.flush = this._flushing\n      req.buffers = buffers\n\n      drained = binding.udx_napi_stream_writev(this._handle, req.handle, id, req.buffers) !== 0\n    }\n\n    if (drained) cb(null)\n    else this._onwrite = cb\n  }\n\n  _final(cb) {\n    const id = this._allocWrite(1)\n    const req = this._wreqs[id]\n\n    req.flush = this._flushes\n    req.buffer = b4a.allocUnsafe(0)\n\n    const drained =\n      binding.udx_napi_stream_write_end(this._handle, req.handle, id, req.buffer) !== 0\n\n    if (drained) cb(null)\n    else this._onwrite = cb\n  }\n\n  _predestroy() {\n    if (!this._closed) binding.udx_napi_stream_destroy(this._handle)\n    this._closed = true\n    this._writeContinue(null)\n  }\n\n  _destroy(cb) {\n    if (this.connected) this._ondestroy = cb\n    else cb(null)\n  }\n\n  _ondata(read) {\n    this.push(this._consumeData(read))\n    return this._buffer\n  }\n\n  _onend(read) {\n    if (read > 0) this.push(this._consumeData(read))\n    this.push(null)\n  }\n\n  _ondrain() {\n    this._writeContinue(null)\n  }\n\n  _flushAck(flush) {\n    for (let i = this._flushes.length - 1; i >= 0; i--) {\n      const f = this._flushes[i]\n      if (f.flush < flush) break\n      f.missing--\n    }\n\n    while (this._flushes.length > 0 && this._flushes[0].missing === 0) {\n      this._flushes.shift().resolve(true)\n    }\n  }\n\n  _onack(id) {\n    const req = this._wreqs[id]\n\n    req.buffers = req.buffer = null\n    this._wfree.push(id)\n\n    if (this._flushes.length > 0) this._flushAck(req.flush)\n\n    // gc the free list\n    if (this._wfree.length >= 64 && this._wfree.length === this._wreqs.length) {\n      this._wfree = []\n      this._wreqs = []\n    }\n  }\n\n  _onsend(id, err) {\n    const req = this._sreqs[id]\n\n    const onflush = req.onflush\n\n    req.buffer = null\n    req.onflush = null\n\n    this._sfree.push(id)\n\n    onflush(err >= 0)\n\n    // gc the free list\n    if (this._sfree.length >= 16 && this._sfree.length === this._sreqs.length) {\n      this._sfree = []\n      this._sreqs = []\n    }\n  }\n\n  _onmessage(len) {\n    this.emit('message', this.udx._consumeMessage(len))\n    return this.udx._buffer\n  }\n\n  _onclose(err) {\n    this._closed = true\n\n    if (this.socket) {\n      this.socket._removeStream(this)\n      this.socket = null\n    }\n\n    if (this._previousSocket) {\n      this._previousSocket._removeStream(this)\n      this._previousSocket = null\n    }\n\n    // no error, we don't need to do anything\n    if (!err) return this._destroyContinue(null)\n\n    if (this._ondestroy === null) this.destroy(err)\n    else this._destroyContinue(err)\n  }\n\n  _onfirewall(socket, port, host, family) {\n    return this._firewall(socket, port, host, family) ? 1 : 0\n  }\n\n  _onremotechanged() {\n    if (this._previousSocket) {\n      this._previousSocket._removeStream(this)\n      this._previousSocket = null\n    }\n\n    this._remoteChanging = null\n    this.emit('remote-changed')\n  }\n\n  _consumeData(len) {\n    const next = this._buffer.subarray(0, len)\n    this._buffer = this._buffer.subarray(len)\n    if (this._buffer.byteLength < MAX_PACKET) this._reallocData()\n    return next\n  }\n\n  _reallocData() {\n    this._buffer = b4a.allocUnsafe(BUFFER_SIZE)\n    return this._buffer\n  }\n\n  _reallocMessage() {\n    return this.udx._reallocMessage()\n  }\n\n  _allocWrite(size) {\n    if (this._wfree.length === 0) {\n      const handle = b4a.allocUnsafe(binding.udx_napi_stream_write_sizeof(size))\n      return (\n        this._wreqs.push({\n          handle,\n          size,\n          buffers: null,\n          buffer: null,\n          flush: 0\n        }) - 1\n      )\n    }\n\n    const free = this._wfree.pop()\n    if (size === 1) return free\n\n    const next = this._wreqs[free]\n    if (next.size < size) {\n      next.handle = b4a.allocUnsafe(binding.udx_napi_stream_write_sizeof(size))\n      next.size = size\n    }\n\n    return free\n  }\n\n  _allocSend() {\n    if (this._sfree.length > 0) return this._sfree.pop()\n    const handle = b4a.allocUnsafe(binding.sizeof_udx_stream_send_t)\n    return this._sreqs.push({ handle, buffer: null, resolve: null, reject: null }) - 1\n  }\n}\n\nfunction noop() {}\n\nfunction toBuffer(data) {\n  return typeof data === 'string' ? b4a.from(data) : data\n}\n\nfunction firewallAll(socket, port, host) {\n  return true\n}\n\nfunction customError(message, code) {\n  const error = new Error(message)\n  error.code = code\n  return error\n}\n\nfunction nextBatchSize(n) {\n  // try to coerce the the writevs into sameish size\n  if (n === 1) return 1\n  // group all < 8 to the same size, low mem overhead but save some small allocs\n  if (n < 8) return 8\n  if (n < 16) return 16\n  if (n < 32) return 32\n  if (n < 64) return 64\n  return n\n}\nconst b4a = require('b4a')\nconst binding = require('../binding')\nconst ip = require('./ip')\nconst Socket = require('./socket')\nconst Stream = require('./stream')\nconst NetworkInterfaces = require('./network-interfaces')\n\nconst MAX_MESSAGE = 4096\nconst BUFFER_SIZE = 65536 + MAX_MESSAGE\n\nmodule.exports = class UDX {\n  constructor() {\n    this._handle = b4a.alloc(binding.sizeof_udx_napi_t)\n    this._watchers = new Set()\n    this._view64 = new BigUint64Array(\n      this._handle.buffer,\n      this._handle.byteOffset,\n      this._handle.byteLength >> 3\n    )\n\n    this._buffer = null\n    this._reallocMessage()\n\n    binding.udx_napi_init(this._handle, this._buffer)\n  }\n\n  static isIPv4(host) {\n    return ip.isIPv4(host)\n  }\n\n  static isIPv6(host) {\n    return ip.isIPv6(host)\n  }\n\n  static isIP(host) {\n    return ip.isIP(host)\n  }\n\n  get bytesTransmitted() {\n    return Number(this._view64[binding.offsetof_udx_t_bytes_tx >> 3])\n  }\n\n  get packetsTransmitted() {\n    return Number(this._view64[binding.offsetof_udx_t_packets_tx >> 3])\n  }\n\n  get bytesReceived() {\n    return Number(this._view64[binding.offsetof_udx_t_bytes_rx >> 3])\n  }\n\n  get packetsReceived() {\n    return Number(this._view64[binding.offsetof_udx_t_packets_rx >> 3])\n  }\n\n  get packetsDroppedByKernel() {\n    return Number(this._view64[binding.offsetof_udx_t_packets_dropped_by_kernel >> 3])\n  }\n\n  _consumeMessage(len) {\n    const next = this._buffer.subarray(0, len)\n    this._buffer = this._buffer.subarray(len)\n    if (this._buffer.byteLength < MAX_MESSAGE) this._reallocMessage()\n    return next\n  }\n\n  _reallocMessage() {\n    // TODO: move reallocation to native\n    this._buffer = b4a.allocUnsafe(BUFFER_SIZE)\n    return this._buffer\n  }\n\n  createSocket(opts) {\n    return new Socket(this, opts)\n  }\n\n  createStream(id, opts) {\n    return new Stream(this, id, opts)\n  }\n\n  networkInterfaces() {\n    let [watcher = null] = this._watchers\n    if (watcher) return watcher.interfaces\n\n    watcher = new NetworkInterfaces(this)\n    watcher.destroy()\n\n    return watcher.interfaces\n  }\n\n  watchNetworkInterfaces(onchange) {\n    const watcher = new NetworkInterfaces(this)\n\n    this._watchers.add(watcher)\n    watcher.on('close', () => {\n      this._watchers.delete(watcher)\n    })\n\n    if (onchange) watcher.on('change', onchange)\n\n    return watcher.watch()\n  }\n\n  async lookup(host, opts = {}) {\n    const { family = 0 } = opts\n\n    const req = b4a.alloc(binding.sizeof_udx_napi_lookup_t)\n    const ctx = {\n      req,\n      resolve: null,\n      reject: null\n    }\n\n    const promise = new Promise((resolve, reject) => {\n      ctx.resolve = resolve\n      ctx.reject = reject\n    })\n\n    binding.udx_napi_lookup(this._handle, req, host, family, ctx, onlookup)\n\n    return promise\n  }\n}\n\nfunction onlookup(err, host, family) {\n  if (err) this.reject(err)\n  else this.resolve({ host, family })\n}\n{\n  \"name\": \"udx-native\",\n  \"version\": \"1.19.2\",\n  \"description\": \"udx is reliable, multiplexed, and congestion-controlled streams over udp\",\n  \"main\": \"lib/udx.js\",\n  \"files\": [\n    \"lib\",\n    \"prebuilds\",\n    \"binding.cc\",\n    \"binding.js\",\n    \"CMakeLists.txt\"\n  ],\n  \"imports\": {\n    \"events\": {\n      \"bare\": \"bare-events\",\n      \"default\": \"events\"\n    }\n  },\n  \"addon\": true,\n  \"scripts\": {\n    \"format\": \"prettier --write .\",\n    \"lint\": \"prettier --check .\",\n    \"test\": \"npm run lint && npm run test:bare && npm run test:node\",\n    \"test:node\": \"node test/all.js\",\n    \"test:bare\": \"bare test/all.js\",\n    \"test:all\": \"brittle test/*.js test/slow/*.js\",\n    \"test:generate\": \"brittle -r test/all.js test/*.js\",\n    \"bench\": \"brittle test/bench/*.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/holepunchto/udx-native.git\"\n  },\n  \"keywords\": [\n    \"tcp\",\n    \"udp\",\n    \"stream\",\n    \"reliable\"\n  ],\n  \"author\": \"Holepunch Inc.\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/udx-native/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/udx-native#readme\",\n  \"engines\": {\n    \"bare\": \">=1.17.4\"\n  },\n  \"dependencies\": {\n    \"b4a\": \"^1.5.0\",\n    \"bare-events\": \"^2.2.0\",\n    \"require-addon\": \"^1.1.0\",\n    \"streamx\": \"^2.22.0\"\n  },\n  \"devDependencies\": {\n    \"bare-compat-napi\": \"^1.3.0\",\n    \"brittle\": \"^3.1.0\",\n    \"cmake-bare\": \"^1.1.10\",\n    \"cmake-fetch\": \"^1.0.1\",\n    \"cmake-napi\": \"^1.0.5\",\n    \"is-ci\": \"^3.0.1\",\n    \"prettier\": \"^3.6.2\",\n    \"prettier-config-holepunch\": \"^2.0.0\",\n    \"tiny-byte-size\": \"^1.1.0\"\n  }\n}\nexports.add = add\nexports.has = has\nexports.remove = remove\nexports.swap = swap\n\nfunction add (list, item) {\n  if (has(list, item)) return item\n  item._index = list.length\n  list.push(item)\n  return item\n}\n\nfunction has (list, item) {\n  return item._index < list.length && list[item._index] === item\n}\n\nfunction remove (list, item) {\n  if (!has(list, item)) return null\n\n  var last = list.pop()\n  if (last !== item) {\n    list[item._index] = last\n    last._index = item._index\n  }\n\n  return item\n}\n\nfunction swap (list, a, b) {\n  if (!has(list, a) || !has(list, b)) return\n  var tmp = a._index\n  a._index = b._index\n  list[a._index] = a\n  b._index = tmp\n  list[b._index] = b\n}\n{\n  \"name\": \"unordered-set\",\n  \"version\": \"2.0.1\",\n  \"description\": \"A couple of functions that make it easy to maintain an unordered set as an array in an efficient way\",\n  \"main\": \"index.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"standard\": \"^6.0.4\",\n    \"tape\": \"^4.4.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && tape test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/unordered-set.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/unordered-set/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/unordered-set\"\n}\nconst b4a = require('b4a')\n\nunslab.all = all\nunslab.is = is\n\nmodule.exports = unslab\n\nfunction unslab (buf) {\n  if (buf === null || buf.buffer.byteLength === buf.byteLength) return buf\n  const copy = b4a.allocUnsafeSlow(buf.byteLength)\n  copy.set(buf, 0)\n  return copy\n}\n\nfunction is (buf) {\n  return buf.buffer.byteLength !== buf.byteLength\n}\n\nfunction all (list) {\n  let size = 0\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i]\n    size += buf === null || buf.buffer.byteLength === buf.byteLength ? 0 : buf.byteLength\n  }\n\n  const copy = b4a.allocUnsafeSlow(size)\n  const result = new Array(list.length)\n\n  let offset = 0\n  for (let i = 0; i < list.length; i++) {\n    let buf = list[i]\n\n    if (buf !== null && buf.buffer.byteLength !== buf.byteLength) {\n      copy.set(buf, offset)\n      buf = copy.subarray(offset, offset += buf.byteLength)\n    }\n\n    result[i] = buf\n  }\n\n  return result\n}\n{\n  \"name\": \"unslab\",\n  \"version\": \"1.3.0\",\n  \"description\": \"Unslab some slab'ed buffers\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"dependencies\": {\n    \"b4a\": \"^1.6.6\"\n  },\n  \"devDependencies\": {\n    \"brittle\": \"^3.5.2\",\n    \"standard\": \"^17.1.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/holepunchto/unslab.git\"\n  },\n  \"author\": \"Holepunch\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/unslab/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/unslab\"\n}\nconst { runtime, platform, arch } = typeof Bare !== 'undefined'\n  ? { runtime: 'bare', platform: global.Bare.platform, arch: global.Bare.arch }\n  : typeof process !== 'undefined'\n    ? { runtime: 'node', platform: global.process.platform, arch: global.process.arch }\n    : typeof Window !== 'undefined'\n      ? { runtime: 'browser', platform: 'unknown', arch: 'unknown' }\n      : { runtime: 'unknown', platform: 'unknown', arch: 'unknown' }\n\nexports.runtime = runtime\nexports.platform = platform\nexports.arch = arch\nexports.isBare = runtime === 'bare'\nexports.isBareKit = exports.isBare && typeof BareKit !== 'undefined'\nexports.isPear = typeof Pear !== 'undefined'\nexports.isNode = runtime === 'node'\nexports.isBrowser = runtime === 'browser'\nexports.isWindows = platform === 'win32'\nexports.isLinux = platform === 'linux'\nexports.isMac = platform === 'darwin'\nexports.isIOS = platform === 'ios' || platform === 'ios-simulator'\nexports.isAndroid = platform === 'android'\nexports.isElectron = typeof process !== 'undefined' && !!global.process.versions?.electron\nexports.isElectronRenderer = exports.isElectron && global.process.type === 'renderer'\nexports.isElectronWorker = exports.isElectron && global.process.type === 'worker'\n{\n  \"name\": \"which-runtime\",\n  \"version\": \"1.3.2\",\n  \"description\": \"Detect if you are in Bare or Node and which os etc\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"standard\": \"^17.0.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/holepunchto/which-runtime.git\"\n  },\n  \"author\": \"Holepunch Inc.\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/holepunchto/which-runtime/issues\"\n  },\n  \"homepage\": \"https://github.com/holepunchto/which-runtime\"\n}\nmodule.exports = class MaxCache {\n  constructor ({ maxSize, maxAge, createMap, ongc }) {\n    this.maxSize = maxSize\n    this.maxAge = maxAge\n    this.ongc = ongc || null\n\n    this._createMap = createMap || defaultCreateMap\n    this._latest = this._createMap()\n    this._oldest = this._createMap()\n    this._retained = this._createMap()\n    this._gced = false\n    this._interval = null\n\n    if (this.maxAge > 0 && this.maxAge < Infinity) {\n      const tick = Math.ceil(2 / 3 * this.maxAge)\n      this._interval = setInterval(this._gcAuto.bind(this), tick)\n      if (this._interval.unref) this._interval.unref()\n    }\n  }\n\n  * [Symbol.iterator] () {\n    for (const it of [this._latest, this._oldest, this._retained]) {\n      yield * it\n    }\n  }\n\n  * keys () {\n    for (const it of [this._latest, this._oldest, this._retained]) {\n      yield * it.keys()\n    }\n  }\n\n  * values () {\n    for (const it of [this._latest, this._oldest, this._retained]) {\n      yield * it.values()\n    }\n  }\n\n  destroy () {\n    this.clear()\n    clearInterval(this._interval)\n    this._interval = null\n  }\n\n  clear () {\n    this._gced = true\n    this._latest.clear()\n    this._oldest.clear()\n    this._retained.clear()\n  }\n\n  set (k, v) {\n    if (this._retained.has(k)) return this\n    this._latest.set(k, v)\n    this._oldest.delete(k) || this._retained.delete(k)\n    if (this._latest.size >= this.maxSize) this._gc()\n    return this\n  }\n\n  retain (k, v) {\n    this._retained.set(k, v)\n    this._latest.delete(k) || this._oldest.delete(k)\n    return this\n  }\n\n  delete (k) {\n    return this._latest.delete(k) || this._oldest.delete(k) || this._retained.delete(k)\n  }\n\n  has (k) {\n    return this._latest.has(k) || this._oldest.has(k) || this._retained.has(k)\n  }\n\n  get (k) {\n    if (this._latest.has(k)) {\n      return this._latest.get(k)\n    }\n\n    if (this._oldest.has(k)) {\n      const v = this._oldest.get(k)\n      this._latest.set(k, v)\n      this._oldest.delete(k)\n      return v\n    }\n\n    if (this._retained.has(k)) {\n      return this._retained.get(k)\n    }\n\n    return null\n  }\n\n  _gcAuto () {\n    if (!this._gced) this._gc()\n    this._gced = false\n  }\n\n  _gc () {\n    this._gced = true\n    if (this.ongc !== null && this._oldest.size > 0) this.ongc(this._oldest)\n    this._oldest = this._latest\n    this._latest = this._createMap()\n  }\n}\n\nfunction defaultCreateMap () {\n  return new Map()\n}\n{\n  \"name\": \"xache\",\n  \"version\": \"1.2.1\",\n  \"description\": \"Yet another auto expiring, max sizable cache\",\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"devDependencies\": {\n    \"brittle\": \"^3.3.2\",\n    \"standard\": \"^17.1.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/xache.git\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/xache/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/xache\"\n}\nconst b4a = require('b4a')\n\nconst ALPHABET = 'ybndrfg8ejkmcpqxot1uwisza345h769'\nconst MIN = 0x31 // 1\nconst MAX = 0x7a // z\nconst REVERSE = new Int8Array(1 + MAX - MIN)\n\nREVERSE.fill(-1)\n\nfor (let i = 0; i < ALPHABET.length; i++) {\n  const v = ALPHABET.charCodeAt(i) - MIN\n  REVERSE[v] = i\n}\n\nexports.encode = encode\nexports.decode = decode\nexports.ALPHABET = ALPHABET\n\nfunction decode (s, out) {\n  let pb = 0\n  let ps = 0\n\n  const r = s.length & 7\n  const q = (s.length - r) / 8\n\n  if (!out) out = b4a.allocUnsafe(Math.ceil(s.length * 5 / 8))\n\n  // 0 5 2 7 4 1 6 3 (+5 mod 8)\n  for (let i = 0; i < q; i++) {\n    const a = quintet(s, ps++)\n    const b = quintet(s, ps++)\n    const c = quintet(s, ps++)\n    const d = quintet(s, ps++)\n    const e = quintet(s, ps++)\n    const f = quintet(s, ps++)\n    const g = quintet(s, ps++)\n    const h = quintet(s, ps++)\n\n    out[pb++] = (a << 3) | (b >>> 2)\n    out[pb++] = ((b & 0b11) << 6) | (c << 1) | (d >>> 4)\n    out[pb++] = ((d & 0b1111) << 4) | (e >>> 1)\n    out[pb++] = ((e & 0b1) << 7) | (f << 2) | (g >>> 3)\n    out[pb++] = ((g & 0b111) << 5) | h\n  }\n\n  if (r === 0) return out.subarray(0, pb)\n\n  const a = quintet(s, ps++)\n  const b = quintet(s, ps++)\n\n  out[pb++] = (a << 3) | (b >>> 2)\n\n  if (r <= 2) return out.subarray(0, pb)\n\n  const c = quintet(s, ps++)\n  const d = quintet(s, ps++)\n\n  out[pb++] = ((b & 0b11) << 6) | (c << 1) | (d >>> 4)\n\n  if (r <= 4) return out.subarray(0, pb)\n\n  const e = quintet(s, ps++)\n\n  out[pb++] = ((d & 0b1111) << 4) | (e >>> 1)\n\n  if (r <= 5) return out.subarray(0, pb)\n\n  const f = quintet(s, ps++)\n  const g = quintet(s, ps++)\n\n  out[pb++] = ((e & 0b1) << 7) | (f << 2) | (g >>> 3)\n\n  if (r <= 7) return out.subarray(0, pb)\n\n  const h = quintet(s, ps++)\n\n  out[pb++] = ((g & 0b111) << 5) | h\n\n  return out.subarray(0, pb)\n}\n\nfunction encode (buf) {\n  if (typeof buf === 'string') buf = b4a.from(buf)\n\n  const max = buf.byteLength * 8\n\n  let s = ''\n\n  for (let p = 0; p < max; p += 5) {\n    const i = p >>> 3\n    const j = p & 7\n\n    if (j <= 3) {\n      s += ALPHABET[(buf[i] >>> (3 - j)) & 0b11111]\n      continue\n    }\n\n    const of = j - 3\n    const h = (buf[i] << of) & 0b11111\n    const l = (i >= buf.byteLength ? 0 : buf[i + 1]) >>> (8 - of)\n\n    s += ALPHABET[h | l]\n  }\n\n  return s\n}\n\nfunction quintet (s, i) {\n  if (i > s.length) {\n    return 0\n  }\n\n  const v = s.charCodeAt(i)\n\n  if (v < MIN || v > MAX) {\n    throw Error('Invalid character in base32 input: \"' + s[i] + '\" at position ' + i)\n  }\n\n  const bits = REVERSE[v - MIN]\n\n  if (bits === -1) {\n    throw Error('Invalid character in base32 input: \"' + s[i] + '\" at position ' + i)\n  }\n\n  return bits\n}\n{\n  \"name\": \"z32\",\n  \"version\": \"1.1.0\",\n  \"description\": \"Encode & decode z-base32\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"b4a\": \"^1.5.3\"\n  },\n  \"devDependencies\": {\n    \"base-x\": \"^4.0.0\",\n    \"base32\": \"0.0.7\",\n    \"brittle\": \"^3.1.3\",\n    \"nanobench\": \"^3.0.0\",\n    \"rfc4648\": \"^1.5.2\",\n    \"standard\": \"^17.0.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/mafintosh/z32.git\"\n  },\n  \"scripts\": {\n    \"test\": \"standard && brittle test.js\",\n    \"bench\": \"node benchmark.js\"\n  },\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/z32/issues\"\n  },\n  \"homepage\": \"https://github.com/mafintosh/z32\"\n}\n\nconst { IPC } = BareKit\n\nconst MAX_PROMPT_SIZE = 8192\nconst MAX_INBOUND_BUFFER_BYTES = 64 * 1024\nconst SERVER_INFO_TIMEOUT_MS = 15000\nconst REQUEST_TIMEOUT_MS = 30000\nconst BARE_HOOK_RETRY_MAX_ATTEMPTS = 20\nconst BREADCRUMB_BUFFER_SIZE = 120\nconst BREADCRUMB_DUMP_LIMIT = 80\nconst DIAGNOSTIC_PREFIX = '[worklet-diag]'\nconst CONNECT_DIAGNOSTIC_PHASE_FULL = 'full'\nconst CONNECT_DIAGNOSTIC_PHASE_DECODE_ONLY = 'decode_only'\nconst CONNECT_DIAGNOSTIC_PHASE_JOIN_ONLY = 'join_only'\n\nlet swarm = null\nlet discovery = null\nlet socket = null\nlet HyperswarmFactory = null\nlet SafeHyperswarmFactory = null\nlet inboundBuffer = ''\nlet activeRequestId = null\nlet closing = false\nlet serverInfoTimeoutId = null\nlet requestTimeoutId = null\nlet serverInfoReceived = false\nlet unhandledHooksInstalled = false\nlet bareHooksInstalled = false\nlet promiseSafetyNetInstalled = false\nlet bareHookRetryScheduled = false\nlet bareHookRetryAttempts = 0\nlet connectDiagnosticPhase = CONNECT_DIAGNOSTIC_PHASE_FULL\nlet breadcrumbSequence = 0\nlet breadcrumbBuffer = []\nlet breadcrumbDumped = false\n\nfunction emit(event) {\n  try {\n    IPC.write(Buffer.from(JSON.stringify(event) + '\\\\n'))\n  } catch {}\n}\n\nfunction normalizeDiagnosticPhase(value) {\n  if (value === CONNECT_DIAGNOSTIC_PHASE_DECODE_ONLY) {\n    return CONNECT_DIAGNOSTIC_PHASE_DECODE_ONLY\n  }\n\n  if (value === CONNECT_DIAGNOSTIC_PHASE_JOIN_ONLY) {\n    return CONNECT_DIAGNOSTIC_PHASE_JOIN_ONLY\n  }\n\n  return CONNECT_DIAGNOSTIC_PHASE_FULL\n}\n\nfunction setDiagnosticPhase(value) {\n  connectDiagnosticPhase = normalizeDiagnosticPhase(value)\n  addBreadcrumb('connect.phase', connectDiagnosticPhase)\n}\n\nfunction addBreadcrumb(edge, detail) {\n  const entry = {\n    seq: ++breadcrumbSequence,\n    t: Date.now(),\n    edge\n  }\n\n  if (detail !== undefined) {\n    entry.detail = detail\n  }\n\n  breadcrumbBuffer.push(entry)\n  if (breadcrumbBuffer.length > BREADCRUMB_BUFFER_SIZE) {\n    breadcrumbBuffer.shift()\n  }\n}\n\nfunction dumpBreadcrumbsOnce(trigger, detail) {\n  if (breadcrumbDumped) {\n    return\n  }\n\n  breadcrumbDumped = true\n  const payload = {\n    type: 'worklet_failure_breadcrumbs',\n    trigger,\n    detail,\n    phase: connectDiagnosticPhase,\n    requestId: activeRequestId || null,\n    breadcrumbs: breadcrumbBuffer.slice(-BREADCRUMB_DUMP_LIMIT)\n  }\n\n  emit({\n    type: 'onRawMessage',\n    direction: 'out',\n    text: DIAGNOSTIC_PREFIX + ' ' + JSON.stringify(payload)\n  })\n}\n\nfunction toErrorMessage(value) {\n  if (value && typeof value === 'object' && typeof value.message === 'string') {\n    return value.message\n  }\n\n  if (typeof value === 'string') {\n    return value\n  }\n\n  try {\n    return JSON.stringify(value)\n  } catch {\n    return 'Unknown error'\n  }\n}\n\nfunction handleThenable(result, onReject) {\n  if (!result || typeof result.then !== 'function') {\n    return false\n  }\n\n  addBreadcrumb('promise.observe')\n  result.catch((error) => {\n    addBreadcrumb('promise.reject', toErrorMessage(error))\n    try {\n      onReject(error)\n    } catch {}\n  })\n\n  return true\n}\n\nfunction guarded(fn, code, fallbackMessage) {\n  return (...args) => {\n    addBreadcrumb('callback.enter', fallbackMessage)\n    try {\n      const result = fn(...args)\n      if (result && typeof result.then === 'function') {\n        addBreadcrumb('callback.promise', fallbackMessage)\n        result.catch((error) => {\n          addBreadcrumb('callback.reject', fallbackMessage + ': ' + toErrorMessage(error))\n          emitError(code, fallbackMessage + ': ' + toErrorMessage(error), activeRequestId || undefined)\n        })\n      }\n    } catch (error) {\n      addBreadcrumb('callback.throw', fallbackMessage + ': ' + toErrorMessage(error))\n      emitError(code, fallbackMessage + ': ' + toErrorMessage(error), activeRequestId || undefined)\n    }\n  }\n}\n\nfunction resolveUnhandledReason(eventOrReason) {\n  if (eventOrReason !== null && typeof eventOrReason === 'object' && 'reason' in eventOrReason) {\n    return eventOrReason.reason\n  }\n\n  return eventOrReason\n}\n\nfunction reportUnhandledRejection(eventOrReason) {\n  addBreadcrumb('unhandledRejection', toErrorMessage(resolveUnhandledReason(eventOrReason)))\n  try {\n    emitError(\n      'CONNECT_FAILED',\n      'Worklet unhandled rejection: ' + toErrorMessage(resolveUnhandledReason(eventOrReason)),\n      activeRequestId || undefined\n    )\n  } catch {}\n}\n\nfunction reportUncaughtException(error) {\n  addBreadcrumb('uncaughtException', toErrorMessage(error))\n  try {\n    emitError(\n      'CONNECT_FAILED',\n      'Worklet uncaught exception: ' + toErrorMessage(error),\n      activeRequestId || undefined\n    )\n  } catch {}\n}\n\nfunction getBareRuntime() {\n  if (typeof globalThis !== 'undefined' && globalThis && globalThis.Bare) {\n    return globalThis.Bare\n  }\n\n  if (typeof Bare !== 'undefined') {\n    return Bare\n  }\n\n  return null\n}\n\nfunction scheduleBareHookRetry() {\n  if (bareHooksInstalled || bareHookRetryScheduled || bareHookRetryAttempts >= BARE_HOOK_RETRY_MAX_ATTEMPTS) {\n    return\n  }\n\n  addBreadcrumb('hooks.bare.retry.schedule', bareHookRetryAttempts + 1)\n  bareHookRetryScheduled = true\n  setTimeout(() => {\n    bareHookRetryScheduled = false\n    bareHookRetryAttempts += 1\n    addBreadcrumb('hooks.bare.retry.run', bareHookRetryAttempts)\n    installUnhandledHooks()\n  }, 0)\n}\n\nfunction installUnhandledHooks() {\n  const bareRuntime = getBareRuntime()\n  if (\n    !bareHooksInstalled &&\n    bareRuntime &&\n    typeof bareRuntime.on === 'function'\n  ) {\n    bareHooksInstalled = true\n    addBreadcrumb('hooks.bare.installed')\n    bareRuntime.on('unhandledRejection', (reason) => {\n      reportUnhandledRejection(reason)\n      return true\n    })\n    bareRuntime.on('unhandledrejection', (reason) => {\n      reportUnhandledRejection(reason)\n      return true\n    })\n    bareRuntime.on('uncaughtException', (error) => {\n      reportUncaughtException(error)\n      return true\n    })\n    bareRuntime.on('uncaughtexception', (error) => {\n      reportUncaughtException(error)\n      return true\n    })\n  } else if (!bareHooksInstalled) {\n    scheduleBareHookRetry()\n  }\n\n  if (unhandledHooksInstalled) {\n    return\n  }\n\n  unhandledHooksInstalled = true\n  addBreadcrumb('hooks.global.installed')\n\n  if (typeof globalThis !== 'undefined') {\n    const handleUnhandledRejection = (event) => {\n      try {\n        if (event && typeof event === 'object' && typeof event.preventDefault === 'function') {\n          event.preventDefault()\n        }\n      } catch {}\n\n      reportUnhandledRejection(event)\n      return true\n    }\n\n    if (typeof globalThis.addEventListener === 'function') {\n      try {\n        globalThis.addEventListener('unhandledrejection', handleUnhandledRejection)\n      } catch {}\n    }\n\n    try {\n      globalThis.onunhandledrejection = handleUnhandledRejection\n    } catch {}\n\n    try {\n      globalThis.onerror = (message) => {\n        try {\n          emitError(\n            'CONNECT_FAILED',\n            'Worklet runtime error: ' + toErrorMessage(message),\n            activeRequestId || undefined\n          )\n        } catch {}\n        return true\n      }\n    } catch {}\n  }\n\n  if (typeof process !== 'undefined' && process && typeof process.on === 'function') {\n    process.on('unhandledRejection', (reason) => {\n      reportUnhandledRejection(reason)\n    })\n\n    process.on('uncaughtException', (error) => {\n      reportUncaughtException(error)\n    })\n  }\n}\n\nfunction installPromiseSafetyNet() {\n  if (promiseSafetyNetInstalled || typeof Promise === 'undefined' || !Promise || !Promise.prototype) {\n    return\n  }\n\n  const originalThen = Promise.prototype.then\n  if (typeof originalThen !== 'function') {\n    return\n  }\n\n  promiseSafetyNetInstalled = true\n  addBreadcrumb('hooks.promise.patch')\n\n  Promise.prototype.then = function patchedThen(onFulfilled, onRejected) {\n    const next = originalThen.call(this, onFulfilled, onRejected)\n\n    try {\n      // Mark chained promises as observed to avoid fatal unhandled-rejection aborts in Bare.\n      originalThen.call(next, undefined, () => {})\n    } catch {}\n\n    return next\n  }\n}\n\nfunction emitError(code, message, requestId) {\n  addBreadcrumb('emit.error', code + ': ' + message)\n  dumpBreadcrumbsOnce('emitError', code + ': ' + message)\n\n  const payload = {\n    type: 'onError',\n    code,\n    message\n  }\n\n  if (requestId) {\n    payload.requestId = requestId\n  }\n\n  emit(payload)\n}\n\nfunction emitRawMessage(direction, text) {\n  emit({\n    type: 'onRawMessage',\n    direction,\n    text\n  })\n}\n\nfunction suppressRejection(result) {\n  addBreadcrumb('promise.suppress')\n  handleThenable(result, () => {})\n}\n\nfunction destroySocket(targetSocket) {\n  if (!targetSocket) {\n    return\n  }\n\n  addBreadcrumb('socket.destroy')\n  try {\n    suppressRejection(targetSocket.destroy())\n  } catch {}\n}\n\nfunction attachDiscoveryErrorHandler(value) {\n  const target = value && value.discovery ? value.discovery : value\n  if (!target || typeof target !== 'object') {\n    return\n  }\n\n  try {\n    addBreadcrumb('discovery.onerror.patch')\n    target._onerror = (error) => {\n      addBreadcrumb('discovery.onerror.callback', toErrorMessage(error))\n      emitError('CONNECT_FAILED', 'Discovery error: ' + toErrorMessage(error))\n    }\n  } catch {}\n}\n\nfunction onDiscoveryError(error) {\n  addBreadcrumb('discovery.onerror.option', toErrorMessage(error))\n  emitError('CONNECT_FAILED', 'Discovery error: ' + toErrorMessage(error))\n}\n\nfunction getSafeHyperswarmFactory(factory) {\n  if (SafeHyperswarmFactory) {\n    return SafeHyperswarmFactory\n  }\n\n  SafeHyperswarmFactory = class SafeHyperswarm extends factory {\n    async _handleNetworkUpdate(...args) {\n      try {\n        addBreadcrumb('swarm.networkUpdate.start')\n        return await super._handleNetworkUpdate(...args)\n      } catch (error) {\n        addBreadcrumb('swarm.networkUpdate.error', toErrorMessage(error))\n        emitError('CONNECT_FAILED', 'Swarm network update failed: ' + toErrorMessage(error))\n        return false\n      }\n    }\n\n    async _handleNetworkChange(...args) {\n      try {\n        addBreadcrumb('swarm.networkChange.start')\n        return await super._handleNetworkChange(...args)\n      } catch (error) {\n        addBreadcrumb('swarm.networkChange.error', toErrorMessage(error))\n        emitError('CONNECT_FAILED', 'Swarm network change failed: ' + toErrorMessage(error))\n        return false\n      }\n    }\n\n    join(topic, opts = {}) {\n      addBreadcrumb('swarm.join.call')\n      const session = super.join(topic, opts)\n      attachDiscoveryErrorHandler(session)\n      return session\n    }\n  }\n\n  return SafeHyperswarmFactory\n}\n\nfunction writeSocketMessage(targetSocket, message, requestId, failureMessage) {\n  try {\n    addBreadcrumb('socket.write.start', failureMessage)\n    const writeResult = targetSocket.write(message)\n    handleThenable(writeResult, (error) => {\n      addBreadcrumb('socket.write.reject', toErrorMessage(error))\n      if (requestId && activeRequestId === requestId) {\n        activeRequestId = null\n        clearRequestTimeout()\n      }\n\n      emitError(\n        'HOST_DISCONNECTED',\n        failureMessage + ': ' + toErrorMessage(error),\n        requestId\n      )\n    })\n    return true\n  } catch (error) {\n    addBreadcrumb('socket.write.throw', toErrorMessage(error))\n    emitError(\n      'HOST_DISCONNECTED',\n      failureMessage + ': ' + toErrorMessage(error),\n      requestId\n    )\n    return false\n  }\n}\n\nfunction clearServerInfoTimeout() {\n  if (serverInfoTimeoutId) {\n    clearTimeout(serverInfoTimeoutId)\n    serverInfoTimeoutId = null\n  }\n}\n\nfunction clearRequestTimeout() {\n  if (requestTimeoutId) {\n    clearTimeout(requestTimeoutId)\n    requestTimeoutId = null\n  }\n}\n\nfunction resetRequestTimeout() {\n  if (!activeRequestId) {\n    clearRequestTimeout()\n    return\n  }\n\n  const timedRequestId = activeRequestId\n  clearRequestTimeout()\n  addBreadcrumb('request.timeout.start', timedRequestId)\n  requestTimeoutId = setTimeout(() => {\n    if (activeRequestId !== timedRequestId) {\n      return\n    }\n\n    addBreadcrumb('request.timeout.fire', timedRequestId)\n    activeRequestId = null\n    clearRequestTimeout()\n    emitError('TIMEOUT_NO_RESPONSE', 'No response chunk received within 30 seconds', timedRequestId)\n  }, REQUEST_TIMEOUT_MS)\n}\n\nfunction emitProtocolError(message) {\n  emitError('BAD_MESSAGE', message, activeRequestId || undefined)\n}\n\nfunction startServerInfoTimeout(targetSocket) {\n  clearServerInfoTimeout()\n  addBreadcrumb('serverInfo.timeout.start')\n  serverInfoTimeoutId = setTimeout(guarded(() => {\n    if (socket !== targetSocket || serverInfoReceived) {\n      return\n    }\n\n    addBreadcrumb('serverInfo.timeout.fire')\n    emitError('TIMEOUT_NO_RESPONSE', 'No server_info received within 15 seconds')\n    closeResources()\n    emit({\n      type: 'onDisconnect',\n      code: 'TIMEOUT_NO_RESPONSE',\n      message: 'Connection timed out'\n    })\n  }, 'CONNECT_FAILED', 'Failed while waiting for server info'), SERVER_INFO_TIMEOUT_MS)\n}\n\nfunction closeResources() {\n  if (closing) {\n    return\n  }\n\n  addBreadcrumb('resources.close.start')\n  closing = true\n  clearServerInfoTimeout()\n  clearRequestTimeout()\n  serverInfoReceived = false\n\n  const previousSocket = socket\n  socket = null\n  inboundBuffer = ''\n  activeRequestId = null\n\n  if (previousSocket) {\n    try {\n      previousSocket.removeAllListeners()\n    } catch {}\n\n    destroySocket(previousSocket)\n  }\n\n  if (discovery) {\n    try {\n      addBreadcrumb('discovery.destroy')\n      suppressRejection(discovery.destroy())\n    } catch {}\n    discovery = null\n  }\n\n  if (swarm) {\n    try {\n      addBreadcrumb('swarm.destroy')\n      suppressRejection(swarm.destroy())\n    } catch {}\n    swarm = null\n  }\n\n  closing = false\n  addBreadcrumb('resources.close.end')\n}\n\nfunction nextRequestId() {\n  return 'req-' + Date.now() + '-' + Math.floor(Math.random() * 100000)\n}\n\nfunction handleProtocolLine(line) {\n  emitRawMessage('in', line)\n\n  let message\n  try {\n    message = JSON.parse(line)\n  } catch {\n    emitProtocolError('Malformed protocol payload')\n    return\n  }\n\n  if (!message || typeof message.type !== 'string') {\n    emitProtocolError('Protocol message missing type')\n    return\n  }\n\n  if (message.type === 'server_info') {\n    const payload = message.payload\n    if (\n      payload &&\n      typeof payload.host_name === 'string' &&\n      typeof payload.model === 'string' &&\n      (payload.status === 'ready' || payload.status === 'busy')\n    ) {\n      serverInfoReceived = true\n      clearServerInfoTimeout()\n      emit({\n        type: 'onServerInfo',\n        hostName: payload.host_name,\n        model: payload.model,\n        status: payload.status\n      })\n      return\n    }\n\n    emitProtocolError('Invalid server_info payload')\n    return\n  }\n\n  if (message.type === 'chat_chunk') {\n    const requestId = message.request_id\n    const payload = message.payload\n\n    if (typeof requestId === 'string' && payload && typeof payload.text === 'string') {\n      if (activeRequestId === requestId) {\n        resetRequestTimeout()\n      }\n\n      emit({\n        type: 'onChunk',\n        requestId,\n        text: payload.text\n      })\n      return\n    }\n\n    emitProtocolError('Invalid chat_chunk payload')\n    return\n  }\n\n  if (message.type === 'chat_end') {\n    const requestId = message.request_id\n    const payload = message.payload\n\n    if (\n      typeof requestId === 'string' &&\n      payload &&\n      (payload.finish_reason === 'stop' || payload.finish_reason === 'abort' || payload.finish_reason === 'error')\n    ) {\n      if (activeRequestId === requestId) {\n        activeRequestId = null\n        clearRequestTimeout()\n      }\n\n      emit({\n        type: 'onChatEnd',\n        requestId,\n        finishReason: payload.finish_reason\n      })\n      return\n    }\n\n    emitProtocolError('Invalid chat_end payload')\n    return\n  }\n\n  if (message.type === 'error') {\n    const payload = message.payload\n\n    if (payload && typeof payload.code === 'string' && typeof payload.message === 'string') {\n      const requestId = typeof message.request_id === 'string' ? message.request_id : undefined\n      if (requestId && activeRequestId === requestId) {\n        activeRequestId = null\n        clearRequestTimeout()\n      }\n\n      emitError(payload.code, payload.message, requestId)\n      return\n    }\n\n    emitProtocolError('Invalid error payload')\n    return\n  }\n\n  emitProtocolError('Unsupported protocol message type')\n}\n\nfunction disconnectForBadInboundBuffer() {\n  emitError('BAD_MESSAGE', 'Inbound protocol buffer exceeded 64 KB', activeRequestId || undefined)\n  closeResources()\n  emit({\n    type: 'onDisconnect',\n    code: 'BAD_MESSAGE',\n    message: 'Disconnected due to malformed protocol stream'\n  })\n}\n\nfunction onSocketData(chunk) {\n  addBreadcrumb('socket.data', String(chunk && chunk.length ? chunk.length : 0))\n  inboundBuffer += chunk.toString()\n\n  if (Buffer.byteLength(inboundBuffer, 'utf8') > MAX_INBOUND_BUFFER_BYTES) {\n    disconnectForBadInboundBuffer()\n    return\n  }\n\n  while (true) {\n    const newlineIndex = inboundBuffer.indexOf('\\\\n')\n    if (newlineIndex === -1) {\n      return\n    }\n\n    const line = inboundBuffer.slice(0, newlineIndex).trim()\n    inboundBuffer = inboundBuffer.slice(newlineIndex + 1)\n\n    if (!line) {\n      continue\n    }\n\n    handleProtocolLine(line)\n  }\n}\n\nfunction attachSocket(nextSocket) {\n  if (socket) {\n    addBreadcrumb('socket.attach.ignored')\n    destroySocket(nextSocket)\n    return\n  }\n\n  addBreadcrumb('socket.attach')\n  socket = nextSocket\n  serverInfoReceived = false\n  startServerInfoTimeout(nextSocket)\n\n  nextSocket.on('data', guarded(onSocketData, 'BAD_MESSAGE', 'Failed handling socket data'))\n\n  nextSocket.on('close', guarded(() => {\n    addBreadcrumb('socket.close')\n    if (closing || socket !== nextSocket) {\n      return\n    }\n\n    closeResources()\n    emit({\n      type: 'onDisconnect',\n      code: 'HOST_DISCONNECTED',\n      message: 'Host disconnected'\n    })\n  }, 'HOST_DISCONNECTED', 'Socket close handler failed'))\n\n  nextSocket.on('error', guarded(() => {\n    addBreadcrumb('socket.error')\n    if (closing || socket !== nextSocket) {\n      return\n    }\n\n    closeResources()\n    emit({\n      type: 'onDisconnect',\n      code: 'HOST_DISCONNECTED',\n      message: 'Connection error'\n    })\n  }, 'HOST_DISCONNECTED', 'Socket error handler failed'))\n}\n\nfunction handleConnect(topicBytes, diagnosticPhase) {\n  breadcrumbDumped = false\n  breadcrumbSequence = 0\n  breadcrumbBuffer = []\n  setDiagnosticPhase(diagnosticPhase)\n  addBreadcrumb('connect.start')\n  closeResources()\n\n  if (!Array.isArray(topicBytes)) {\n    emitError('INVALID_SERVER_ID', 'Topic must be an array of bytes')\n    return\n  }\n\n  const validLength = topicBytes.length === 32\n  const validByteValues = topicBytes.every((value) => Number.isInteger(value) && value >= 0 && value <= 255)\n  if (!validLength || !validByteValues) {\n    emitError('INVALID_SERVER_ID', 'Topic must contain exactly 32 bytes')\n    return\n  }\n\n  const topic = Buffer.from(topicBytes)\n  addBreadcrumb('connect.topic.valid')\n\n  if (connectDiagnosticPhase === CONNECT_DIAGNOSTIC_PHASE_DECODE_ONLY) {\n    addBreadcrumb('connect.stop.decode_only')\n    emitError('CONNECT_FAILED', 'Diagnostic mode decode_only stopped before swarm.join')\n    return\n  }\n\n  try {\n    if (!HyperswarmFactory) {\n      addBreadcrumb('swarm.require.start')\n      HyperswarmFactory = require('hyperswarm')\n    }\n  } catch (error) {\n    addBreadcrumb('swarm.require.error', toErrorMessage(error))\n    emitError('CONNECT_FAILED', 'Failed to load Hyperswarm: ' + toErrorMessage(error))\n    return\n  }\n\n  try {\n    const HyperswarmCtor = getSafeHyperswarmFactory(HyperswarmFactory)\n    addBreadcrumb('swarm.create.start')\n    swarm = new HyperswarmCtor()\n    addBreadcrumb('swarm.create.done')\n\n    swarm.on('connection', guarded((nextSocket) => {\n      addBreadcrumb('swarm.connection')\n      if (connectDiagnosticPhase === CONNECT_DIAGNOSTIC_PHASE_JOIN_ONLY) {\n        addBreadcrumb('connect.stop.join_only.connection')\n        destroySocket(nextSocket)\n        closeResources()\n        emit({\n          type: 'onDisconnect',\n          code: 'USER_DISCONNECTED',\n          message: 'Diagnostic mode join_only short-circuited after swarm.join'\n        })\n        return\n      }\n\n      attachSocket(nextSocket)\n    }, 'CONNECT_FAILED', 'Failed to attach socket'))\n\n    swarm.on('error', guarded((error) => {\n      addBreadcrumb('swarm.error', toErrorMessage(error))\n      emitError('CONNECT_FAILED', 'Failed to start Hyperswarm client: ' + toErrorMessage(error))\n    }, 'CONNECT_FAILED', 'Swarm error handler failed'))\n\n    addBreadcrumb('swarm.join.start')\n    discovery = swarm.join(topic, {\n      server: false,\n      client: true,\n      onerror: onDiscoveryError\n    })\n    addBreadcrumb('swarm.join.done')\n    attachDiscoveryErrorHandler(discovery)\n\n    if (connectDiagnosticPhase === CONNECT_DIAGNOSTIC_PHASE_JOIN_ONLY) {\n      addBreadcrumb('connect.stop.join_only.after_join')\n    }\n\n    suppressRejection(\n      discovery.flushed().then(() => {\n        addBreadcrumb('swarm.join.flushed')\n        if (connectDiagnosticPhase === CONNECT_DIAGNOSTIC_PHASE_JOIN_ONLY && swarm) {\n          addBreadcrumb('connect.stop.join_only.flushed')\n          closeResources()\n          emit({\n            type: 'onDisconnect',\n            code: 'USER_DISCONNECTED',\n            message: 'Diagnostic mode join_only stopped after swarm.join flush'\n          })\n        }\n      }).catch((error) => {\n        addBreadcrumb('swarm.join.flushed.error', toErrorMessage(error))\n        closeResources()\n        emitError('CONNECT_FAILED', 'Failed to join host topic')\n      })\n    )\n  } catch (error) {\n    addBreadcrumb('swarm.join.throw', toErrorMessage(error))\n    closeResources()\n    emitError('CONNECT_FAILED', 'Failed to join host topic: ' + toErrorMessage(error))\n  }\n}\n\nfunction handleSendPrompt(prompt) {\n  addBreadcrumb('prompt.send.start')\n  if (typeof prompt !== 'string') {\n    emitError('BAD_MESSAGE', 'Prompt must be a string')\n    return\n  }\n\n  const normalized = prompt.trim()\n  if (!normalized) {\n    emitError('BAD_MESSAGE', 'Prompt cannot be empty')\n    return\n  }\n\n  const promptByteLength = new TextEncoder().encode(normalized).byteLength\n  if (promptByteLength > MAX_PROMPT_SIZE) {\n    emitError('BAD_MESSAGE', 'Prompt exceeds max size')\n    return\n  }\n\n  if (!socket) {\n    emitError('HOST_OFFLINE', 'No connected host peer')\n    return\n  }\n\n  if (activeRequestId) {\n    emitError('MODEL_BUSY', 'A request is already active', activeRequestId)\n    return\n  }\n\n  const requestId = nextRequestId()\n  addBreadcrumb('prompt.send.request', requestId)\n  const message = JSON.stringify({\n    type: 'chat_start',\n    request_id: requestId,\n    payload: { prompt: normalized }\n  }) + '\\\\n'\n\n  try {\n    emitRawMessage('out', message.trim())\n    if (!writeSocketMessage(socket, message, requestId, 'Failed to write to host peer')) {\n      return\n    }\n    activeRequestId = requestId\n    resetRequestTimeout()\n  } catch {}\n}\n\nfunction handleAbort() {\n  if (!socket || !activeRequestId) {\n    return\n  }\n\n  addBreadcrumb('prompt.abort', activeRequestId)\n  const requestId = activeRequestId\n  const message = JSON.stringify({\n    type: 'abort',\n    request_id: requestId\n  }) + '\\\\n'\n\n  try {\n    emitRawMessage('out', message.trim())\n    if (!writeSocketMessage(socket, message, requestId, 'Failed to send abort')) {\n      return\n    }\n    activeRequestId = null\n    clearRequestTimeout()\n  } catch {}\n}\n\ninstallUnhandledHooks()\ninstallPromiseSafetyNet()\n\nIPC.on('data', guarded((chunk) => {\n  installUnhandledHooks()\n  installPromiseSafetyNet()\n  addBreadcrumb('ipc.command.chunk')\n\n  let command\n  try {\n    command = JSON.parse(Buffer.from(chunk).toString())\n  } catch {\n    emitError('BAD_MESSAGE', 'Bad worklet command')\n    return\n  }\n\n  if (!command || typeof command.type !== 'string') {\n    emitError('BAD_MESSAGE', 'Missing worklet command type')\n    return\n  }\n  addBreadcrumb('ipc.command.type', command.type)\n\n  if (command.type === 'connect') {\n    handleConnect(command.topic, command.diagnosticMode)\n    return\n  }\n\n  if (command.type === 'disconnect') {\n    closeResources()\n    emit({\n      type: 'onDisconnect',\n      code: 'USER_DISCONNECTED',\n      message: 'Disconnected'\n    })\n    return\n  }\n\n  if (command.type === 'sendPrompt') {\n    handleSendPrompt(command.prompt)\n    return\n  }\n\n  if (command.type === 'abort') {\n    handleAbort()\n    return\n  }\n\n  emitError('BAD_MESSAGE', 'Unknown worklet command')\n}, 'BAD_MESSAGE', 'Worklet command handler failed'))\n{\n  \"name\": \"client\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.ts\",\n  \"scripts\": {\n    \"start\": \"expo start --dev-client\",\n    \"start:go\": \"expo start\",\n    \"android\": \"expo run:android\",\n    \"ios\": \"expo run:ios\",\n    \"web\": \"expo start --web\",\n    \"build\": \"expo export --platform ios --output-dir dist\",\n    \"bundle:worklet\": \"node scripts/bundleWorklet.mjs\",\n    \"test\": \"jest --runInBand\",\n    \"test:watch\": \"jest --watch\"\n  },\n  \"dependencies\": {\n    \"@localllm/protocol\": \"file:../../packages/protocol\",\n    \"bs58\": \"^6.0.0\",\n    \"expo\": \"~54.0.33\",\n    \"expo-camera\": \"^17.0.10\",\n    \"expo-status-bar\": \"~3.0.9\",\n    \"hyperswarm\": \"^4.16.0\",\n    \"react\": \"19.1.0\",\n    \"react-native\": \"0.81.5\",\n    \"react-native-bare-kit\": \"^0.12.1\"\n  },\n  \"devDependencies\": {\n    \"@types/jest\": \"^29.5.14\",\n    \"@types/react\": \"~19.1.0\",\n    \"bare-pack\": \"^1.0.0\",\n    \"jest\": \"^29.7.0\",\n    \"jest-expo\": \"~54.0.13\",\n    \"typescript\": \"~5.9.2\"\n  },\n  \"private\": true\n}\n"
